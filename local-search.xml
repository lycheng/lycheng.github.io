<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Python Development At 2024</title>
    <link href="/2024/03/24/python-development-at-2024/"/>
    <url>/2024/03/24/python-development-at-2024/</url>
    
    <content type="html"><![CDATA[<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>与之对比是 2020 年左右自己 Python 开发相关技术栈，那时以 Python 3.6 为主，主要做 Flask Web 开发。现在则是以 Python 3.10 作为新的版本来进行学习。</p><p>本文会涉及一些我觉得挺重要的一些改动，包括</p><ul><li>语法上的更新</li><li>async &#x2F; await</li><li>框架和工具</li></ul><h2 id="Language-Changes"><a href="#Language-Changes" class="headerlink" title="Language Changes"></a>Language Changes</h2><h3 id="PEP-557-Data-Classes"><a href="#PEP-557-Data-Classes" class="headerlink" title="PEP 557 Data Classes"></a>PEP 557 Data Classes</h3><p>以前没怎么太详细读过 PEP，这次认真看了几个，第一次从语言开发者的角度了解语言 feature 前后，感觉也不错。</p><p>在讲 PEP 557 之前需要了解下 PEP 526。PEP 526 主要讲的是 variable annotation。之前在 Python 3.6 阶段已经有了 PEP 484，但其更多关注是类型推断。PEP 526 则更进一步扩展到 class and instance variable 用途上。</p><p>其中一个重要用途</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BasicStarship</span>:<br>    captain: <span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27;Picard&#x27;</span>               <span class="hljs-comment"># instance variable with default</span><br>    damage: <span class="hljs-built_in">int</span>                           <span class="hljs-comment"># instance variable without default</span><br>    stats: ClassVar[<span class="hljs-type">Dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-built_in">int</span>]] = &#123;&#125;  <span class="hljs-comment"># class variable</span><br><br>bss = BasicStarship()<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">vars</span>(bss))  <span class="hljs-comment"># &#123;&#125;, instance without attribute</span><br></code></pre></td></tr></table></figure><p>上述代码中，能通过 type annotation 标记出其是属于 instance 还是 class 的 variable。但需要注意的是，这种 type annotaition 属于标记，并不会影响实际程序逻辑，即上述的代码中，<code>captain</code> 依旧还是 class variable。直到 PEP 557 则可以借助类装饰器来更好的完成类定义。</p><blockquote><p>A class decorator is provided which inspects a class definition for variables with type annotations as defined in <a href="https://peps.python.org/pep-0526/" title="PEP 526 – Syntax for Variable Annotations">PEP 526</a>, “Syntax for Variable Annotations”.</p></blockquote><p>同样是上述例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@dataclass</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BasicStarship</span>:<br>    damage: <span class="hljs-built_in">int</span>                           <span class="hljs-comment"># instance variable without default</span><br>    captain: <span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27;Picard&#x27;</span>               <span class="hljs-comment"># instance variable with default</span><br>    stats: ClassVar[<span class="hljs-type">Dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-built_in">int</span>]] = &#123;&#125;  <span class="hljs-comment"># class variable</span><br><br><br>bss = BasicStarship(damage=<span class="hljs-number">1</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">vars</span>(bss))  <span class="hljs-comment"># &#123;&#x27;damage&#x27;: 1, &#x27;captain&#x27;: &#x27;Picard&#x27;&#125;</span><br></code></pre></td></tr></table></figure><p>这里的关键是，这个类装饰器可以帮你自动实现如 <code>__init__</code> 和 <code>__ne__</code> 等一些常用的 magic method。这一特性可以更方便实现一些只需要进行序列化和反序列化的类。此外借助 dataclass 的 <code>field</code> 可以对不同的属性进行定制。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@dataclass</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span>:<br>    x: <span class="hljs-built_in">list</span> = field(default_factory=<span class="hljs-built_in">list</span>)  <span class="hljs-comment"># init the mutable variable</span><br>    y: <span class="hljs-built_in">int</span> = field(<span class="hljs-built_in">repr</span>=<span class="hljs-literal">False</span>, default=<span class="hljs-number">10</span>)<br>    z: <span class="hljs-built_in">int</span> = <span class="hljs-number">20</span><br><br><br><span class="hljs-keyword">assert</span> D().x <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> D().x  <span class="hljs-comment"># True</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">vars</span>(D()))  <span class="hljs-comment"># &#123;&#x27;x&#x27;: [], &#x27;y&#x27;: 10, &#x27;z&#x27;: 20&#125;</span><br></code></pre></td></tr></table></figure><p>更多用法请参考 dataclasses 的文档。</p><h3 id="PEP-636-Structural-Pattern-Matching"><a href="#PEP-636-Structural-Pattern-Matching" class="headerlink" title="PEP 636 Structural Pattern Matching"></a>PEP 636 Structural Pattern Matching</h3><p>这个是我最感兴趣的特性，在 Python 3.10 引入。模式匹配这个语法层面的支持可能不同语言都大差不差，但看了下一些样例，能很好支持 Python 已有的 packing &#x2F; unpacking 的语法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">match</span> command.split():<br>    <span class="hljs-keyword">case</span> [<span class="hljs-string">&quot;quit&quot;</span>]:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Goodbye!&quot;</span>)<br>        quit_game()<br>    <span class="hljs-keyword">case</span> [<span class="hljs-string">&quot;look&quot;</span>]:<br>        current_room.describe()<br>    <span class="hljs-keyword">case</span> [<span class="hljs-string">&quot;get&quot;</span>, obj]:<br>        character.get(obj, current_room)<br>    <span class="hljs-keyword">case</span> [<span class="hljs-string">&quot;go&quot;</span>, direction] <span class="hljs-keyword">if</span> direction <span class="hljs-keyword">in</span> current_room.exits: <span class="hljs-comment"># if guard</span><br>        current_room = current_room.neighbor(direction)<br>    <span class="hljs-keyword">case</span> [<span class="hljs-string">&quot;drop&quot;</span>, *objects]:<br>    <span class="hljs-built_in">print</span>(objects)<br>    <span class="hljs-keyword">case</span> [<span class="hljs-string">&quot;north&quot;</span>] | [<span class="hljs-string">&quot;go&quot;</span>, <span class="hljs-string">&quot;north&quot;</span>]:  <span class="hljs-comment"># OR pattern</span><br>        current_room = current_room.neighbor(<span class="hljs-string">&quot;north&quot;</span>)<br>    <span class="hljs-keyword">case</span> _:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Sorry, I couldn&#x27;t understand <span class="hljs-subst">&#123;command!r&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="Dict-Keys-Ordering"><a href="#Dict-Keys-Ordering" class="headerlink" title="Dict Keys Ordering"></a>Dict Keys Ordering</h3><p>这个功能的更新记录</p><blockquote><p>Dictionaries preserve insertion order. Note that updating a key does not affect the order. Keys added after deletion are inserted at the end.</p></blockquote><blockquote><p>Changed in version 3.7: Dictionary order is guaranteed to be insertion order. This behavior was an implementation detail of CPython from 3.6.</p></blockquote><blockquote><p>Changed in version 3.8: Dictionaries are now reversible.</p></blockquote><p>当时出的时候还关注了一下，但实际需要用到已经是 2024 年了，在实际写需要这个功能的时候，第一反应其实是 <code>OrderedDict</code>。现在回想起来，在这种不断进步的时代，所谓经验有时候的确会变成阻碍。现在已经是 3.1X 的版本了，已经不需要考虑这个东西是不是会存在前向兼容的问题了。</p><h2 id="Async"><a href="#Async" class="headerlink" title="Async"></a>Async</h2><p>async 相关功能引入实际上是在 3.5 版本。但在 2019 年主要用着 3.6，项目实际上还是以 Flask 为主，并没有相应的尝试。但在 2024 年这个时间点，async 的使用则是广泛了许多。async &#x2F; await 是新引进的两个 keyword，asyncio 则是在新语法基础上，为 Python 编写相应 async 功能的支持库。</p><blockquote><p>Coroutines are a more generalized form of subroutines. Subroutines are entered at one point and exited at another point. Coroutines can be entered, exited, and resumed at many different points. They can be implemented with the async def statement.</p></blockquote><blockquote><p>Coroutines behave like generators. In older versions of Python, coroutines are defined by generators.</p></blockquote><p>其实有过 async &#x2F; await 类似 pattern 的其它语言使用经验可以很快接受，PEP 492 也说了采用这种语法是因为其它语言也是这么做的，里面也介绍了很多新 async magic method 应用例子。</p><p>这里主要想讲下 ASGI。</p><h3 id="ASGI"><a href="#ASGI" class="headerlink" title="ASGI"></a>ASGI</h3><p>和以前的 WSGI 相比</p><blockquote><p>The WSGI specification has worked well since it was introduced, and allowed for great flexibility in Python framework and web server choice. However, its design is irrevocably tied to the HTTP-style request&#x2F;response cycle, and more and more protocols that do not follow this pattern are becoming a standard part of web programming (most notably, WebSocket).</p></blockquote><blockquote><p>Unlike WSGI, however, applications are asynchronous callables rather than simple callables, and they communicate with the server by receiving and sending asynchronous event messages rather than receiving a single input stream and returning a single iterable.</p></blockquote><p>WSGI 只专注于一个请求的上下文。</p><p>ASGI 关注一个连接上下文，根据不同的 scope 和 event 能处理好不同协议的不同流程，不再仅仅局限于 HTTP，也可以支持如 WebSocket 和 HTTP2。</p><blockquote><p>ASGI decomposes protocols into a series of events that an application must receive and react to, and events the application might send in response.</p></blockquote><blockquote><p>ASGI is structured as a single, asynchronous callable. It takes a <code>scope</code>, which is a <code>dict</code> containing details about the specific connection, <code>send</code>, an asynchronous callable, that lets the application send event messages to the client, and <code>receive</code>, an asynchronous callable which lets the application receive event messages from the client.</p></blockquote><p>一段不借助 web framework 的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">application</span>(<span class="hljs-params">scope, receive, send</span>):<br>    event = <span class="hljs-keyword">await</span> receive()<br>    ...<br>    <span class="hljs-keyword">await</span> send(&#123;<span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;websocket.send&quot;</span>, ...&#125;)<br></code></pre></td></tr></table></figure><p>不同协议，events 有多种，每个 event 是一个 dict，都包含一个指明类型的 <code>type</code> 字段。如对于 HTTP</p><ul><li><code>http.request</code></li><li><code>http.disconnect</code></li></ul><p>对于 WebSocket</p><ul><li><code>websocket.connect</code></li><li><code>websocket.send</code></li><li><code>websocket.receive</code></li><li><code>websocket.disconnect</code></li></ul><p>以下是用 starlette 来编写的样例，需要注意的是，去到 framework 阶段，我们就可以借助 framework 更好的与 scope &#x2F; receive 打交道</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># app.py</span><br><span class="hljs-keyword">from</span> starlette.responses <span class="hljs-keyword">import</span> PlainTextResponse<br><span class="hljs-keyword">from</span> starlette.requests <span class="hljs-keyword">import</span> Request<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">app</span>(<span class="hljs-params">scope, receive, send</span>):<br>    event = <span class="hljs-keyword">await</span> receive()<br>    // ... do something<br>    <span class="hljs-keyword">assert</span> scope[<span class="hljs-string">&quot;type&quot;</span>] == <span class="hljs-string">&quot;http&quot;</span><br><br>// Starlette includes a `Request` <span class="hljs-keyword">class</span> <span class="hljs-title class_">that</span> gives you a nicer interface onto the incoming<br>//   request, rather than accessing the ASGI scope <span class="hljs-keyword">and</span> receive channel directly.<br>request = Request(scope, receive)<br>// ... do something <span class="hljs-keyword">with</span> request<br><br>    response = PlainTextResponse(<span class="hljs-string">&quot;Hello, world!&quot;</span>)<br>    <span class="hljs-keyword">await</span> response(scope, receive, send)<br></code></pre></td></tr></table></figure><h2 id="Frameworks-and-Tools"><a href="#Frameworks-and-Tools" class="headerlink" title="Frameworks and Tools"></a>Frameworks and Tools</h2><h3 id="poetry"><a href="#poetry" class="headerlink" title="poetry"></a>poetry</h3><p>2019 年接手的一个项目，最开始使用的是 pipenv 来进行项目管理，当时使用下来最大的问题是，它太慢了。在当时日常开发和部署体验都非常糟糕。当时去看它的文档的时候还注意到，它 18 年最好一次更新之后就一直停在那里了。在写这篇文章的时候再去看了下，我们当时注意到的最新的更新时间是 2018-11-26 然后再下一次更新就是 2020 年的 5 月。在此之前，我们所有的项目都全部替换掉了 pipenv。</p><p>当时我们的解决方法是，只使用最原始的 requirement 文件。对几个项目的一些共用的库，如 Flask &#x2F; schema &#x2F; requests 都统一版本。在部署的时候，所有的 Python 都用同一个 base docker image，里面已经预先 build 好了所有的共有的 pip packages。这样就能减少在部署的时候需要重新 install 一些 packages。但这个方案只能解决</p><p>一些 pipenv 问题的参考文章，和我当时的体验差不多</p><ul><li><a href="https://greyli.com/do-not-use-pipenv/">https://greyli.com/do-not-use-pipenv/</a></li><li><a href="https://zhuanlan.zhihu.com/p/80695813">https://zhuanlan.zhihu.com/p/80695813</a></li></ul><p>现在站在 2024 年的角度去看重新看这个问题的话，感觉已经有了更多更好的方案，如 poetry。当时 pipenv 有一个好处其实是能帮我们管理 env，后面去掉之后，开发者们就只能自己来用额外的 env 工具来开发了。</p><p>还有一点比较重要的是，poetry 的命令本身也将一些业界约定俗成的用法整合了进来。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">build wheel package</span><br>poetry build<br><br>poetry new my-package<br>poetry new --src my-package<br></code></pre></td></tr></table></figure><p>上述代码中，new 可以加一个 <code>--src</code> 参数就可以在 src 目录下新建一个 my-package 的 package。</p><h3 id="Pydantic"><a href="#Pydantic" class="headerlink" title="Pydantic"></a>Pydantic</h3><p>最开始我们是用 <a href="https://github.com/keleshev/schema">schema</a> 这个 library 去做 data validation。现在 type hint 语法出来之后，Pydantic 可以很好的完成这个工作。</p><blockquote><p>At the time of writing there are 214,100 repositories on GitHub and 8,119 packages on PyPI that depend on Pydantic.</p></blockquote><blockquote><p>Some notable libraries that depend on Pydantic:</p></blockquote><blockquote><ul><li><a href="https://github.com/huggingface/transformers"><code>huggingface/transformers</code></a> 107,475 stars</li><li><a href="https://github.com/tiangolo/fastapi"><code>tiangolo/fastapi</code></a> 60,355 stars</li><li><a href="https://github.com/hwchase17/langchain"><code>hwchase17/langchain</code></a> 54,514 stars</li><li><a href="https://github.com/apache/airflow"><code>apache/airflow</code></a> 30,955 stars</li></ul></blockquote><p>当时的选择其实也挺多的，如 <a href="https://github.com/marshmallow-code/marshmallow">marshmallow</a> 和追求效率的 binary serialization format <a href="https://github.com/msgpack/msgpack-python">msgpack</a>。现在这些 library 也还在更新，应该会很长一段时间会维持这两种不同风格的序列化方案。</p><h3 id="FastAPI"><a href="#FastAPI" class="headerlink" title="FastAPI"></a>FastAPI</h3><blockquote><p>FastAPI stands on the shoulders of giants:</p><ul><li><a href="https://www.starlette.io/">Starlette</a> for the web parts.</li><li><a href="https://pydantic-docs.helpmanual.io/">Pydantic</a> for the data parts.</li></ul></blockquote><p>3.6 版本的时代，感觉上是 Flask 和 Django 两个框架基本上是各取所需，前者更轻便，后者则是集成了很多东西。现在 fastapi 则是更好了。它可以很快的写出简单的样例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Union</span><br><br><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI<br><br>app = FastAPI()<br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">read_root</span>():<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;Hello&quot;</span>: <span class="hljs-string">&quot;World&quot;</span>&#125;<br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">read_item</span>(<span class="hljs-params">item_id: <span class="hljs-built_in">int</span>, q: <span class="hljs-type">Union</span>[<span class="hljs-built_in">str</span>, <span class="hljs-literal">None</span>] = <span class="hljs-literal">None</span></span>):<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;item_id&quot;</span>: item_id, <span class="hljs-string">&quot;q&quot;</span>: q&#125;<br></code></pre></td></tr></table></figure><p>但通过 Pydantic 去定义 request &#x2F; reponse 的 schema，借助其自带的 Swagger &#x2F; ReDoc 支持，则可以直接生成对应 API 文档。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Union</span><br><br><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI<br><span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> BaseModel<br><br>app = FastAPI()<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Item</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):<br>    name: <span class="hljs-built_in">str</span><br>    price: <span class="hljs-built_in">float</span><br>    is_offer: <span class="hljs-type">Union</span>[<span class="hljs-built_in">bool</span>, <span class="hljs-literal">None</span>] = <span class="hljs-literal">None</span><br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">read_root</span>():<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;Hello&quot;</span>: <span class="hljs-string">&quot;World&quot;</span>&#125;<br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">read_item</span>(<span class="hljs-params">item_id: <span class="hljs-built_in">int</span>, q: <span class="hljs-type">Union</span>[<span class="hljs-built_in">str</span>, <span class="hljs-literal">None</span>] = <span class="hljs-literal">None</span></span>):<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;item_id&quot;</span>: item_id, <span class="hljs-string">&quot;q&quot;</span>: q&#125;<br><br><span class="hljs-meta">@app.put(<span class="hljs-params"><span class="hljs-string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">update_item</span>(<span class="hljs-params">item_id: <span class="hljs-built_in">int</span>, item: Item</span>):<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;item_name&quot;</span>: item.name, <span class="hljs-string">&quot;item_id&quot;</span>: item_id&#125;<br></code></pre></td></tr></table></figure><p>实际效果，如同前面介绍的，站在巨人的肩膀上。</p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>语言层面的变更还挺有趣的，感觉在保持 Python 语言有趣的情况下，又增加了许多严谨的特性。希望未来有更多机会用上这些新特性。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://peps.python.org/pep-0492">https://peps.python.org/pep-0492</a></li><li><a href="https://peps.python.org/pep-0526">https://peps.python.org/pep-0526</a></li><li><a href="https://peps.python.org/pep-0557">https://peps.python.org/pep-0557</a></li><li><a href="https://peps.python.org/pep-0636/">https://peps.python.org/pep-0636/</a></li><li><a href="https://docs.python.org/3/library/dataclasses.html">https://docs.python.org/3/library/dataclasses.html</a></li><li><a href="https://docs.python.org/3/library/stdtypes.html#typesmapping">https://docs.python.org/3/library/stdtypes.html#typesmapping</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Farewell 2023</title>
    <link href="/2024/01/04/farewell-2023/"/>
    <url>/2024/01/04/farewell-2023/</url>
    
    <content type="html"><![CDATA[<h2 id="印象最深的事"><a href="#印象最深的事" class="headerlink" title="印象最深的事"></a>印象最深的事</h2><p>今年印象最深的应该是两个人搞的户外婚礼了。我以前一直挺反感这些所谓的仪式和传统的东西。但两个人准备的和二三十个朋友的户外婚礼倒是挺有趣的。虽然中间出了很多意外，包括仪式前的和仪式中的，但和朋友有说有笑的完成了一件事的感觉是完全不同的。</p><p><img src="/images/oor-song.png" alt="学了很久也不会唱的歌，就像那个准备不足的婚礼"></p><p>以前我一个人住，厨房就是油盐酱油简单的排列组合，追求速度，能吃就行。现在在她的教育下，做饭的工序也多了起来。除此以外，家里多了咖啡机，还有一只下班回来会在你脚边转圈的兔子。生活开始不止于生存，一个人是可以生存下来，但两个人的生活更是精彩。</p><p>还有一个重要的事情就是完成了一次私教课程。重新开始审视自己的身体，以前看运动员的职业生涯可能 30 岁就到退役串口了，现在猩猩不也还在球场蹦跶嘛。各式各样运动科学都进步了，感觉上只要加强锻炼，还是可以健康工作 30 年。最起码愿望是，到 50 岁还能下场去打羽毛球。</p><h2 id="今年去过的地方"><a href="#今年去过的地方" class="headerlink" title="今年去过的地方"></a>今年去过的地方</h2><p>去过澳门，去过香港。去了一次杭州，丽水和福建泉州。现在这个点再来看，以为去了很多地方，实际就这几个。香港是我第一次去，还挺新鲜的。小时候看着 TVB 长大，总有一层童年滤镜在那里，高楼大厦配上英粤夹杂的对话。随着年岁渐长，那些童年滤镜开始破碎之后，感觉这个地方就变得没那么耀眼了。这期间我一直有个疑问，这些东西不是淘宝都有得卖吗，你们为啥一定要花时间过去买。</p><p>当时去的是故宫博物馆，回来之后搜了下发现还有不少更有趣的展。其中包括兽首真品的展览。当时才理解了香港独到之处，作为中西文化交流的缓冲区，能很方便的看到各种各样有意思的东西。以前的童年滤镜可能是硬件层面的，现在才理解它软件层面的魅力。不过嘛，未来不知道怎样了，中美冲突的大背景下，OpenAI 的禁用也可见一斑。</p><p>24 年的话，希望能到国外去看看。日本，或者更远的不知名的东欧，中欧国家也是不错的选择。之前国庆还想去印尼的 Bromo 火山看看，结果在看机票时他们那边火灾了。希望之后的出行一切顺利吧。</p><h2 id="书影音记录"><a href="#书影音记录" class="headerlink" title="书影音记录"></a>书影音记录</h2><p><img src="/images/2023-douban-books.jpg" alt="2023 豆瓣书籍记录"></p><p><img src="/images/2023-douban-movies.jpg" alt="2023 豆瓣影视记录"></p><p>2023 年的一些主观推荐</p><h3 id="电影"><a href="#电影" class="headerlink" title="电影"></a>电影</h3><ul><li>流浪地球 2，不过我当时看完电影激情下单的模型还没拼完</li><li>灌篮高手，灌篮高手永远是我动漫里面的 TOP 1，井上还能在其完结之后另起一个角度来讲故事真是需要莫大的勇气</li><li>奥本海默，诺兰的电影一直是顶级的视听盛宴</li></ul><h3 id="电视剧和纪录片"><a href="#电视剧和纪录片" class="headerlink" title="电视剧和纪录片"></a>电视剧和纪录片</h3><ul><li>重启人生，日常治愈向的好片子</li><li>黑暗荣耀，两季看下来，就爽剧来讲感觉没明显的漏洞感觉就挺厉害的</li><li>漫长的季节，可能是我看过最好的国产电视剧，剧情和故事背景都很扎实，相对而言年初的狂飙结尾是在太可惜了</li><li>克拉克森农场，第一季是与天斗的农业体验，第二季脱欧之后与人斗的英国农场生活</li><li>这货哪来的，国内一些小商品产业的科普纪录片，非常有意思</li></ul><h3 id="书"><a href="#书" class="headerlink" title="书"></a>书</h3><p>今年的话感觉印象深的书真不多</p><ul><li>置身事内，感觉属于有逻辑去理解当下社会运行规律的介绍性书籍了</li><li>逻辑的引擎，讲的是计算机发展史里面思想的那一部分，原谅我第一遍看下来没有相应的知识储备去理解其实际意义</li><li>帷幕，如果看过大部分阿加莎的波洛侦探系列可以看看，这最后一集不会让你失望</li></ul><h3 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h3><p>今年通关的游戏就屈指可数了</p><ul><li>十三机兵防卫圈，近年玩过最好的科幻游戏</li><li>机器人大战 V，上次玩机战类游戏还是在高中 PSP 时代，CG 动画都比印象里好多了，这作最吸引我的大概就是大和号剧情</li><li>宠物小精灵 朱，阿尔宙斯给我一种 GF 也能进步的错觉，朱紫系列就拉回了现实。主线里的剧情放在别的游戏都不够看，放在小精灵里面就变成了进步，GF 罪大恶极啊。不过回归传统对战的话还是好玩</li></ul><p>与之相对，2022 年豆瓣记录是 58 部作品，2021 年是 89 部作品，2020 年是 171 部作品。回看这个数量感觉挺有意思的。可能 2020 年是会感觉尚存希望的暂时挫折，但后续体感就是压力本身是渐进的，你以为对你影响不大，但实际上一直在蚕食你的心态。</p><p>反映到读书观影上，其实就是随手点开短视频的频次变多了，或者在选择观看的视频时，会选择那些心智负担不大，即视频时常较短的。今年年中我意识到这个问题，才开始有意识压缩短视频时间，开始回归长文和电影电视剧，库存里面可以看的作品还是挺多的。短视频最大的问题大概就是注意力剥夺，让人无法长时间聚焦在某个事情上。希望明年能看更多的好作品。</p><h2 id="AI"><a href="#AI" class="headerlink" title="AI"></a>AI</h2><p>今年最绕不过的话题大概就是 AI 了吧。前些年的 AI，印象最深的还是那些中韩和 Alpha Go 的棋局，还有就是在 Dota2 和星际上战胜人类的新闻。其余的 AI，就好像统计之于大数据的尴尬，你真的要把能通过统计就能得出的数据叫做大数据技术吗？现在世界真的不同了。一年以来，真的很难想象这个技术的进步程度会如此之大。有段时间，所有关注的技术类相关的资讯都是 AI &#x2F; GPT 一类的主题。后面淡了一点之后，有评论说终于有不是 AI 主题的文章了。</p><p>ChatGPT 和各类 GPT 工具一年下来用过不少，代码生成的工具也用过。以写代码为例，我个人的感受是，如果这些年技术，语言，框架一类工具的演变和进化是 0 到 1 或者，1 到 2 或者 3 的效率进化，那么这类工具则是 1 到 10 或者 20 这样子的程度。它们能理解我在说什么，这在我看来是最厉害的。以更通用的寻求问题解决方法的场景为例，以往借助搜索引擎，搜索关键字，然后更理解问题之后收敛搜索的范围，最终在一个或者多个答案里面得到自己想要的东西。</p><p>以往我的经验，在搜索问题收敛关键字的过程中，其实会有更多有趣的发现。像是在 Stack Overflow &#x2F; 知乎 &#x2F; 博客里发现的其它问题或者其它有意思的文章。然后我会在最终解决一个问题 10 分钟的时间内，可能会花一半或者更多的时间去翻这些意外的发现。就结果而言，这些意外发现，可能会没用。那回到一个基本的问题上，你如果没有相应的知识储备，你是否能问出正确的问题或者判断出 AI 给出的答案是否具备相应质量？</p><p>最近看到的一篇文章 <a href="https://stackoverflow.blog/2023/12/11/three-types-of-ai-assisted-programmers/">https://stackoverflow.blog/2023/12/11/three-types-of-ai-assisted-programmers/</a> 也讲了类似的问题。对于初学者，如果通过 AI 能解决入门问题，就像是甜蜜的毒药。但对于有经验的，AI 则是一个快速筛选的工具。还有一个重要的场景是，对只具备专业知识的人能借助 AI 进行编程的快速验证。或者还有一个，对于我们这种不具备某些行业专业知识的，能借助 AI 进行快速入门？</p><blockquote><p>That’s the expectation you should have. It’s the AI’s job to be fast, but it’s your job to be good.</p></blockquote><p>当年的 Alpha Go 的后续新闻也挺有意思的。柯洁在败于 Alpha Go 之后的连胜，以及韩国的“申工智能”通过 AI 来练习一直雄踞世界第一。现在再来看这些事，感觉就不同了。那时候还觉得只是围棋这类规则以内的游戏而已。现在则是会去想，当年驾马车的人，是怎么看汽车的出现？</p><p>PS：这篇文章我也试图找 AI 润色一下，但改完之后我觉得措辞太正式了，没意思。</p><h2 id="Happy-New-Year"><a href="#Happy-New-Year" class="headerlink" title="Happy New Year"></a>Happy New Year</h2><p>新年展望往往是最难的，在跨年前夕，你回望过去发现一事无成。又要开始以希望的心态去畅想未来，人类真是矛盾的生物。</p><p>目标往年写得太多了，大部分都没有实现。这里就不写这么多技术上或者工作上的一些追求了。2024 年的目标的话，除了日常的学习生活，运动健康以外，就写一个：学习一门乐器，如口琴。这里写口琴其实是因为我几年前买过一个，然后啥都没学会搬家的时候顺手扔了。另外还有个重要的，最近一年明显感觉自己攻击性强了很多，每次意识到这个问题时，总有一种声音和我说环境影响得，跟你关系不大。但人还是有主观能动性的，不然就和畜生没什么区别了。</p><p>近些年来越来越意识到，人生应该追求无限游戏，即以延续为目的的游戏。追求在延续的过程中产生的各种结果。注重过程，寻求能一直玩下去的办法。说人话大概就是加强锻炼，继续努力工作 30 年。</p>]]></content>
    
    
    
    <tags>
      
      <tag>ai</tag>
      
      <tag>throughs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>教老婆 Python</title>
    <link href="/2023/07/02/about-teach-wife-python/"/>
    <url>/2023/07/02/about-teach-wife-python/</url>
    
    <content type="html"><![CDATA[<p>教老婆学 Python</p><p>故事开始是源于她想学习 Python，发了我一篇文章。文章内容大概是使用 jieba 对一篇文章进行分词，然后做一些词频统计一类的工作。文章链接就不贴出来了，我当时看了一眼说写这文章的应该不是专门写代码的。</p><blockquote><p>为什么这么说?</p></blockquote><p>因为文章里变量命名上与 Python 本身的约定的小写下划线的命名方式不同。用的还是大写开头加下划线分隔的形式。</p><blockquote><p>写代码也要有这种规范吗？</p></blockquote><p>是的，语言本身会有一些社区规范，做开发基本也是团队协作，所以会有这种约定的写法。一般来讲会有首字母大写区分单词还有就是单词都小写使用下划线分隔的形式。这文章里两种混用了。我在哪种语言里都没见过这种命名方式。</p><p>后面就是安装 Jupyter 然后演示文章内容。问题就更多了</p><h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><blockquote><p>为什么是 localhost，我是一定可以访问这个地址吗？我在别的电脑能访问这个地址吗？</p></blockquote><p>localhost 也是一个习惯性的用法，它指向的是一个你电脑的本地 IP，具体就是 127.0.0.1，所以当你启动 Jupyter 之后，直接访问这个地址就行（实际上浏览器会自动打开）。所以你换一台电脑也是访问这个地址，但可能数据就不一样了。你如果与程序员打交道，你会经常听到一个词，本地环境，大部分指的就是这个地址。</p><blockquote><p>为什么会有 loop 这种东西？</p></blockquote><p>这个问题真的是问倒我了，毕竟我们上学的时候就学这个东西怎么用。硬要掰扯出一个理由的话，对程序来讲，有一类数据是会逻辑上连续存在于内存上，就像一个数轴 0 1 2 这样去读数据。所以为了访问这样的数据，我们需要一种类似的结构去重复类似的操作。</p><p>以上是当时猜的。但后面越想越觉得这个回答有问题，因果倒置了。应该是一个更高效处理类似的逻辑的控制结构。</p><blockquote><p>Looping allows a programmer to execute a block of code multiple times. This can be useful for performing repetitive tasks, such as iterating through a list of items or running a specific process a certain number of times. Looping can also be used to control the flow of a program, such as in a while loop, where a certain condition must be met before the loop will continue to execute. Overall, looping is a powerful tool that allows for efficient and effective program execution.</p></blockquote><p>以上是来自 ChatGPT 的回答。</p><blockquote><p>我是不是在这里直接敲 pip install 命令就好了？</p></blockquote><p>这个问题也很有意思，她问这个问题的时候，我已经安装好了 Jupyter 然后在它的页面里面演示相关的语法一类的东西。但这时候还需要安装如 pandas 一类的 library，于是我切换回命令行的环境去敲命令。此时就有了上面的问题。</p><p>我的回答是，Python 也是软件的一种，写代码只是把符合规范的指令告诉这个软件怎么做。这个网页的页面是 Python 的 runtime，而 pip install 是系统的命令，相当于给 Python 这个软件安装插件。所以你必须退回到原来系统环境去给软件安装插件。</p><p>我在想，使用电脑和使用电脑进行开发，同样是面对屏幕打字，但差距也是挺大的。</p><blockquote><p>那什么是 runtime？</p></blockquote><p>runtime 直译过来是运行时环境。就是所谓代码的执行环境。根据某种语法写出来的代码就是在这样的环境里面一句接着一句来执行。pip install 这些呢就不是代码，所以它就不能在 runtime 里面执行。</p><blockquote><p>为什么有时候不用 print 就可以输出这个结果</p></blockquote><p>这个问题是在演示 Jupyter 时候问的，如果你在输入一个变量或者一个数字，Jupyter 也能输出其内容。但在最开始的文章里面，也有用到 print 这个函数。</p><p>我的回答是，在 Jupyter 的环境里面呢，它提供了一个很方便的特性，就是你输入一个变量或者是一个算式，它直接就给你输出这个结果了。但在实际程序的执行里面，程序是不会给你看到这些信息的，如果你需要看到某个变量的值，你就需要 print 出来。当然 print 只是其中一种将变量的值显示出来的办法。</p><p>但往深的讲，这里还涉及到 statement 和 expression 的区别。我之前用 ipython 时的确是留意到它不需要 print 就能打印出结果。但其实它是把 expression 的非 None 结果都显示出来了。另外，它如果 print 又会是另一种形式</p><h2 id="一些想法"><a href="#一些想法" class="headerlink" title="一些想法"></a>一些想法</h2><p>这个故事实际上发生在 3 月底，当时想着写下来记录下的，结果拖着拖着就到了 6 月底了。老婆的学习也随着海拉鲁新旅程的到来而暂停。这就是不是一家人不进一家门吗？</p><p>写这篇文章时我在想，我还没有到那种向非专业的人普及专业问题能简单直接说出来的程度。回想这些问题的时候，总有一种需要查漏补缺的危机感。完全要做跨行学习的话，难度的确是大，有些我们认为属于 1 + 1 &#x3D; 2 的知识可能还需要额外科普。但在科普过程中，我发现这些 1 + 1 &#x3D; 2 也有可能先入为主。像别人科普真是一个学习的好方法。</p><p>另外，最近看吴恩达的机器学习视频，在里面他会用 Jupyter 去演示相关算法。他还认真说我还挺喜欢 Jupyter 的，经常用。啊真好啊。感慨万千，身处行业顶端的人都会去做这种工作，会去做这些面向小白的科普，十分佩服。</p><p>知识需要沉淀，但知识也要与时俱进，愿你我都在终身学习路上。</p>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>ai</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>About Unit Tests</title>
    <link href="/2022/06/14/about-unit-tests/"/>
    <url>/2022/06/14/about-unit-tests/</url>
    
    <content type="html"><![CDATA[<p>本文为公司组内的一次关于在 Java 项目上的单元测试的分享，面向的是实习生以及工作年限并不长的员工。</p><h1 id="What-is-Unit-Tests"><a href="#What-is-Unit-Tests" class="headerlink" title="What is Unit Tests"></a>What is Unit Tests</h1><p><strong>UNIT TESTING</strong> is a type of software testing where individual units or components of a software are tested. The purpose is to validate that each unit of the software code performs as expected. Unit Testing is done during the development (coding phase) of an application by the developers. Unit Tests isolate a section of code and verify its correctness. A unit may be an <strong>individual function</strong>, <strong>method</strong>, <strong>procedure</strong>, <strong>module</strong>, or <strong>object</strong>.</p><p>There are levels of testing in current software engineering</p><ul><li>Unit Testing</li><li>Integration Testing</li><li>System Testing</li><li>Acceptance Testing</li></ul><p>And the Unit Testing is the most easy and most cheap way to guarantee the quality of your development.</p><h1 id="How-to-write-Unit-Tests"><a href="#How-to-write-Unit-Tests" class="headerlink" title="How to write Unit Tests"></a>How to write Unit Tests</h1><h2 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h2><h3 id="Simple-tests"><a href="#Simple-tests" class="headerlink" title="Simple tests"></a>Simple tests</h3><p>When you test codes without status, like some string handling, Utlis class. You should write test cases to cover all situation. For example</p><ul><li>if-else statement all conditions</li><li>for loop once, 0 times or max times</li><li>test throw all exceptions that you expect</li><li>test null String, empty string, normal string, invalid string</li><li>test null integer (or double), 0, positive number, negative number, number exceed your demand</li><li>…</li></ul><p>Test for Utils class is the easiest. What you need to do is to cover all the conditions and some invalid cases.</p><h3 id="Advanced-tests"><a href="#Advanced-tests" class="headerlink" title="Advanced tests"></a>Advanced tests</h3><p>Simple tests focus on the Utils class, all the input data you can very easily to generate. But when you write some tests for</p><ul><li>module rely on the database or cache like Redis</li><li>module rely on file or network</li></ul><p>For these cases, you need to mock some data for tests.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">when(mockedBookDAL.getAllBooks()).thenReturn(Arrays.asList(book1, book2));<br>when(mockedBookDAL.getBook(<span class="hljs-string">&quot;8131721019&quot;</span>)).thenReturn(book1);<br>when(mockedBookDAL.update(any(), any())).thenReturn(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>You can check these examples. When you mock the functions belong to other module, you can use these mock codes for your module test cases. The most import thing is that you should not mock too much. The third line of the example is not acceptable, you need to update to</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">when(mockedBookDAL.update(eq(book1), any())).thenReturn(<span class="hljs-number">1</span>);<br><span class="hljs-comment">// OR</span><br>when(mockedBookDAL.update(eq(book2), eq(<span class="hljs-number">1</span>))).thenReturn(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>Mock all the arguments means that you dose not test the interaction between your module and dependences. You need to test with the excepted argument that your module will pass to the dependence.</p><p>And the second import thing is that you should rely on the package that is fully tested. This may be your Utils class or some famous third-party opensource.</p><h2 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h2><p>Mockito</p><ul><li>very easy to use, mock and stub</li><li>There are some suggestions form the Mockito <a href="https://site.mockito.org/">home page</a><ul><li>Do not mock types you don’t own</li><li>Don’t mock value objects</li><li>Don’t mock everything</li><li>Show love with your tests!</li></ul></li></ul><p>Lombok</p><ul><li>Class with annotation <code>@Data</code> will reduce the test coverage percentages</li><li><a href="https://dzone.com/articles/lombok-data-improve-your-code-coverage">Improve Your Code Coverage With Lombok @Data - DZone Java</a></li></ul><p>Docker</p><ul><li>you can use them to setup a database or Redis for tests, so you don’t need to mock the database operations</li><li>need the pipeline support</li></ul><p>Jenkins</p><ul><li>Will trigger unit tests running at pipeline and export the test reports to the Sonarqube</li></ul><h1 id="When-to-write-Unit-Tests"><a href="#When-to-write-Unit-Tests" class="headerlink" title="When to write Unit Tests"></a>When to write Unit Tests</h1><p>First of all, write the unit tests based on your design document. You know the input and output of your module or class, so you cat write the good cases and bad cases of them. At this time, you will get first version of your program like <code>v1.0</code>.</p><p>After that you will go to integration tests or system tests, find some bugs or need to add some new features. You should write some unit tests for these changes. At this time, you will get <code>v1.1</code>.</p><p>After that you find the performance is bad or some code need to refactor. You need to update some codes but keep the business logic would not be changed. You can rely on the unit tests codes you have finished at <code>v1.1</code> and <code>v1.0</code>.</p><h1 id="Why-we-need-Unit-Tests"><a href="#Why-we-need-Unit-Tests" class="headerlink" title="Why we need Unit Tests"></a>Why we need Unit Tests</h1><p>First of all, we need to verify our module or functions working as expected. Of course, you can verify your code with some demos or setup local environment to check it’s OK or not. But we are working at a team, someone may change your codes and forget to test all the situations. With Jenkins now, we can rely on the pipeline to run our unit tests at each commit. You can check the tests result conveniently.</p><p>Secondly, I think the unit tests are some kinds of document of your module or functions. You can find the valid and invalid input for these codes. You will know when it will raise exception.</p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>单元测试除了保证代码的准确性以外，还有一个重要作用就是当你需要改动或者重构代码时，如果已经有单元测试覆盖到相关代码，那么你的改动就不会影响到已有功能。</p><p>我不认同 100% 的单元测试覆盖率的就是 100 分的软件质量。单元测试保证质量是自底向上的，但如 API 或者数据库的设计这样更高层级的设计有问题的话，代码写得再好没有用。设计能提高程序的上限，单元测试能提供程序的下限。</p><p>另一方面，我认为在测试的时候遇到测试代码很难写的情况，有可能是设计问题，需要去考虑是否需要进行代码上的重构或者设计上的更新。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://www.guru99.com/unit-testing-guide.html">Unit Testing Tutorial: What is, Types, Tools &amp; Test EXAMPLE (guru99.com)</a></p><p><a href="https://dzone.com/articles/getting-started-mocking-java">Getting Started with Mocking in Java using Mockito - DZone Java</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>engineering</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Designing Data-Intensive Applications Notes</title>
    <link href="/2021/12/15/designing-data-intensive-applications-note/"/>
    <url>/2021/12/15/designing-data-intensive-applications-note/</url>
    
    <content type="html"><![CDATA[<h1 id="Chapter-1-可靠系统"><a href="#Chapter-1-可靠系统" class="headerlink" title="Chapter 1 - 可靠系统"></a>Chapter 1 - 可靠系统</h1><ul><li>以最小出错的方式来设计系统，减少人为出错</li><li>想办法分离出最容易出错的地方和容易引发故障的接口</li><li>充分的测试</li><li>快速的恢复机制以尽量减少故障影响</li><li>详细而清晰的监控子系统</li><li>流程化</li></ul><h1 id="Chapter-2-数据模型和查询语言"><a href="#Chapter-2-数据模型和查询语言" class="headerlink" title="Chapter 2 - 数据模型和查询语言"></a>Chapter 2 - 数据模型和查询语言</h1><p>关系型和文档型数据库现状</p><ul><li>文档型：读时模式，读取的时候才去解析具体的字段</li><li>RDS：写时模式，已有的关系经由表结构来确定</li></ul><p>关注存储的局部性</p><p>SQL 是声明式查询语言，隐藏了数据库引擎的实现细节。如果交由命令式语言，则语句间有顺序关系，无法并行</p><h1 id="Chapter-3-数据存储和检索"><a href="#Chapter-3-数据存储和检索" class="headerlink" title="Chapter 3 - 数据存储和检索"></a>Chapter 3 - 数据存储和检索</h1><p>SSTables 基本结构和 LSM-Tree</p><ul><li>每个日志结构的存储段都是一组 key-value 的序列</li><li>每个段中的 key 只能出现一次，且按 key 的值进行排序</li><li>Log-Structured Merge-Tree</li></ul><p>优缺点</p><ul><li>合并段可以使用类似归并排序的做法</li><li>每个段都是按照 key 进行排序，则可知道每个段的取值范围，有利于查找 key</li><li>写入较快，读取较慢</li></ul><p>B-trees</p><ul><li>将数据库分解成可变大小的段，并始终按顺序写入，这种设计更靠近底层硬件</li><li>预写日志 WAL</li></ul><p>事务处理</p><ul><li>OLTP</li><li>OLAP</li></ul><p>数据仓库</p><ul><li>可能包含 OLTP 数据库的只读副本</li><li>从 OLTP 数据库中提取（Extract）然后转换（Transform）数据，加载（Load）到数据仓库中，成为 ETL 的过程</li></ul><p>列式存储</p><ul><li>将每列中的所有值存储在一起</li><li>列压缩，对于同一列来说，可能的值范围会小于等于数据量</li></ul><h1 id="Chapter-4-数据编码与演化"><a href="#Chapter-4-数据编码与演化" class="headerlink" title="Chapter 4 - 数据编码与演化"></a>Chapter 4 - 数据编码与演化</h1><p>数据格式和模式变更</p><ul><li>服务端升级</li><li>客户端升级并且很长一段时间存在新旧版本</li><li>向前兼容和向后兼容</li></ul><p>数据表示形式</p><ul><li>内存中，程序的数据结构<ul><li>不同的语言并不兼容，如 Python pickle 和 Java 的 io.Serializable</li><li>并没有考虑版本和向前向后的兼容性</li></ul></li><li>文件或者网络中的字节序列</li></ul><p>编码格式</p><ul><li>JSON，XML 和 CSV，对人类更友好</li><li>二进制格式，对机器更友好</li><li>对不同组织使用同一数据编码格式的难度更高</li></ul><p>Thrift 和 Protobuf</p><ul><li>都是通过格式描述文件生成对应语言的编码解码用的代码</li><li>最终用于传输是二进制编码数据</li><li>对于 schema 的变化也都只能对新增字段更好的支持</li></ul><p>Avro</p><ul><li>通过 IDL 来确定传输数据的 schema</li><li>区分 reader 和 writer 的 schema</li><li>可用 union 和 null 来规避数据变更问题</li><li>可以提供一个可查的版本数据库来获知当前的 schema</li></ul><h1 id="Chapter-5-数据复制"><a href="#Chapter-5-数据复制" class="headerlink" title="Chapter 5 - 数据复制"></a>Chapter 5 - 数据复制</h1><p>主节点和从节点</p><ul><li>主节点接收写入请求，从节点在主节点写入后获取其变更日志，保持顺序写入</li><li>主从节点都能接收读请求</li></ul><p>同步复制和异步复制</p><ul><li>都是关系到主节点的写更新如何复制到从节点中</li><li>同步复制则保证了主从节点的同步</li><li>异步复制则有可能导致数据丢失，但相应的吞吐量更高</li></ul><p>节点失效，追赶式恢复</p><p>主节点失效</p><ul><li>采用了异步复制，新的主节点出现数据丢失</li><li>例如使用自增主键，那如果外部的数据系统缓存了某些 id，但恢复时新的主节点计数器落后</li></ul><p>复制日志</p><ul><li>基于语句复制，并不能保证唯一性，如包含 <code>NOW()</code> 语句，或者带自增 ID，多个语句执行顺序不一致</li><li>基于 WAL（Write Ahead Log） 传输，WAL 的描述偏向底层，如果出现版本升级导致存储格式变化，则会出现恢复失败</li><li>基于行的逻辑日志复制，如 binlog，表示的是存储引擎层面的改动</li></ul><p>复制滞后问题</p><ul><li><strong>读自己写</strong>，写入到了主节点，但还没同步到从节点，这就违反了读写一致性<ul><li>考虑数据中心的位置也不一定在附近</li><li>记录时间戳（逻辑时钟，如版本或者实际时钟），请求时带上用以获取最新的数据</li><li>一个账号的多设备</li></ul></li><li><strong>单调读</strong><ul><li>不同的请求落到了同步情况不同的从节点上</li><li>可以通过 id hash 到同一个从节点上</li></ul></li><li><strong>前缀一致性读</strong><ul><li>多个关联的数据写入实际上物理存储是隔离的，写入时并不按照顺序来</li></ul></li></ul><p>复制滞后的解决方案</p><ul><li>多主节点复制<ul><li>离线客户端操作，会出现断线好久之后重新同步的情况，类同于多主</li><li>协作编辑，本地数据同步到服务器和别的正在编辑的用户，需要解决写冲突</li><li>冲突解决策略，最终收敛的策略</li></ul></li><li>无主节点复制<ul><li>客户端一次发送多个请求到后端写入</li><li>读取时带版本信息，用以确认其最新值</li><li>quorum &amp;&amp; happen-before?</li></ul></li></ul><h1 id="Chapter-6-数据分区"><a href="#Chapter-6-数据分区" class="headerlink" title="Chapter 6 - 数据分区"></a>Chapter 6 - 数据分区</h1><p>每一条数据只属于一个分区，分区的主要目的是为了将数据和查询均匀分布在所有的节点上。</p><p>基于哈希分区无法应对如社交媒体名人或者热点信息带来的高度倾斜的负载，只能通过应用层去来减轻不平衡的程度</p><ul><li>在关键字头或者尾添加随机数将写操作重新分区，但带来读操作需要应用层进行合并</li></ul><p>二级索引</p><ul><li>二级索引往往不能准确标识一条数据</li><li>基于文档的二级索引，不同的数据分区有不同的索引，查询需要查多个并合并</li><li>基于词条的二级索引，全局索引，索引自身也分区方便快速查询，写入速度一般，二级索引更新可以异步</li></ul><p>分区再平衡</p><ul><li>直接取模，任何新节点的引入或者节点的删除都会导致所有数据迁移</li><li>固定分区，分区数小于节点数，每个节点负责某一些分区，分区数需要创建时就确定好</li><li>动态分区，根据当前实际数据量创建或者删除分区</li><li>节点比例分区</li></ul><p>请求路由</p><ul><li>典型的服务发现问题，使用如 ZooKeeper 来存放对应关系</li><li>P2P 的模式同步集群状态</li></ul><p>一致性哈希？</p><h1 id="Chapter-7-事务"><a href="#Chapter-7-事务" class="headerlink" title="Chapter 7 - 事务"></a>Chapter 7 - 事务</h1><p>磁盘和 SSD 都各有好处，如</p><ul><li>磁盘的坏道率很低，但是整盘完全失效的情况却会概率高点</li><li>SSD 对温度的要求会更高</li></ul><p>除了硬件上的各种优劣，软件上的问题也会导致数据的丢失</p><h2 id="弱隔离级别"><a href="#弱隔离级别" class="headerlink" title="弱隔离级别"></a>弱隔离级别</h2><p>这里的弱是相对串行化来的</p><p>读提交，read-committed</p><ul><li>防止脏读，snapshot</li><li>防止脏写，通常采用行级锁</li></ul><p>其会导致读倾斜，即不可重复读，需要 MVCC，即快照级别的隔离</p><p>防止更新丢失，如需要执行 +1 操作，可</p><ul><li>update set value &#x3D; value + 1，但这种操作可能在 ORM 层面丢失了，回退回原来的两次操作</li><li>显式加锁</li><li>数据库可能提供隐式支持，如 PostgreSQL 的可重复读</li></ul><p>有些不支持事务的数据库，可能支持原子的 CAS（Compare And Swap）</p><p>写倾斜</p><ul><li>对多个对象的约束，并行的事务无法检测合法性，如排班和会议室的预订</li><li>可使用显式的加锁</li><li>可额外加入可暴露出冲突的锁条件，如会议室和时间的所有组合</li></ul><h2 id="可串行化"><a href="#可串行化" class="headerlink" title="可串行化"></a>可串行化</h2><p>适用串行化的理由</p><ul><li>不同的隔离级别，各家数据库实现不同</li><li>应用层代码无法判断是否安全</li><li>OLTP 事务执行很快，只有少量的读写操作，而长时间的分析操作一般是只读</li><li>内存越来越便宜，可加载全部的数据到内存中</li></ul><p><strong>存储过程</strong></p><p>采用单线程串行执行的系统往往不支持交互式的多语句事务，相对而言对网络和 IO 的要求更低，但实际上</p><ul><li>存储过程不好管理，版本管理，调试都相对麻烦</li><li>现代的也有像 Redis 采用 Lua 来实现存储过程</li></ul><p>需要注意的是，这里需要存储过程和内存数据库才能再单线程上执行所有事务变得可能。</p><p>而分区问题，又需要组织好数据集来使得单个线程能在单个分区内执行事务。而跨分区的事务就又需要额外的资源来进行协调。 </p><p><strong>两阶段加锁</strong></p><p>two-phase locking, 2PL，现阶段唯一的串行化算法。</p><p>多个事务可以同时读取同一对象，但只要出现任何写操作，则必须加锁来进行独占访问。实际实现中，则以共享锁和互斥锁来实现，如 MySQL 中的 Share Lock 和 Exclusive Lock，都需要在 SQL 显式使用，否则就是使用 MVCC 来处理多事务问题。</p><p><strong>谓词锁</strong></p><p>并不属于某一个对象，而是属于符合某些特定查询条件的所有对象，就是为了防止出现上面说过的会议室预定问题。在实际实现中，则以索引区间锁作为简化和近似。</p><h1 id="Chapter-8-分布式系统的挑战"><a href="#Chapter-8-分布式系统的挑战" class="headerlink" title="Chapter 8 - 分布式系统的挑战"></a>Chapter 8 - 分布式系统的挑战</h1><p>故障和部分失效</p><p>不可靠网络</p><ul><li>硬件不可靠</li><li>IP 协议本身也不可靠</li><li>人为配置错误</li></ul><p>需要故障检测，如下线失败节点，重试机制。</p><p><strong>不可靠的时钟</strong></p><ul><li>墙上时钟，即根据某个日历返回当前时间和日期，如编程语言中的 get current time</li><li>单调时钟，如 Java 中的 <code>System.nanoTIme()</code> ，用于单机上的差值比较，从而为应用层提供单调递增计时，不同节点上的单调时钟没有任何意义</li><li>墙上时钟需要 NTP 来进行同步，但同步就会遇到如网络问题，服务器故障一类导致收到的结果不可用</li><li>移动设备用户可调墙上时钟</li><li>在分布式系统中采用墙上时要严格保证节点的时间同步，如果需要进行排序，最好采用递增计数器</li><li>线程暂停（gc，线程切换）之前如果进行时间的比较，有可能出现错误的结果，哪怕是单调时钟，最好依赖如信号量等线程同步工具</li></ul><p>知识，真相和谎言</p><ul><li>节点可能已经被认为失效，但其仍可能认为自身没问题</li><li>用 fencing 令牌来检测无意的误操作，已经过时的节点拒绝请求</li><li>拜占庭故障，指的是存在可能破环系统的节点，如航天中辐射之后的 CPU 寄存器的不可预测的行为，还有软件的 bug</li></ul><h1 id="Chapter-9-一致性与共识"><a href="#Chapter-9-一致性与共识" class="headerlink" title="Chapter 9 - 一致性与共识"></a>Chapter 9 - 一致性与共识</h1><p>为了构建容错系统，最好先建立一套通用的抽象机制和与之对应的技术保证。</p><p>事务隔离主要是为了处理并发执行事务时的各种临界条件，而分布式一致性则主要针对延迟和故障等问题来协调副本之间的状态。</p><h2 id="可线性化"><a href="#可线性化" class="headerlink" title="可线性化"></a>可线性化</h2><p>可串行化强调的是事务执行的结果是与串行执行一致的，可线性化强调的是对单个对象的读写最新值的保证。</p><p>依赖条件</p><ul><li>加锁和主节点选举</li><li>约束和唯一性保证</li><li>跨通道的时间依赖<ul><li>如同时存在队列和 RPC 调用，两者到达顺序不同导致出现不一致的情况</li></ul></li></ul><h2 id="线性化的代价"><a href="#线性化的代价" class="headerlink" title="线性化的代价"></a>线性化的代价</h2><p>CAP 理论，可用性和分区容错性，系统只能支持其中两个。但实际上网络分区是一定存在的，一旦发生网络故障要么选择线性，要么选择可用性。</p><p>CAP 理论有争议，实际上节点延迟和其它相对网络分区更弱的情况没有考虑进去，并且在多核环境下，也很难考虑线性化。</p><h2 id="顺序保证"><a href="#顺序保证" class="headerlink" title="顺序保证 *"></a>顺序保证 *</h2><p>概念</p><ul><li><strong>全序</strong>是指，集合中的任两个元素之间都可以比较的关系。 比如实数中的任两个数都可以比较大小，那么“大小”就是实数集的一个<strong>全序</strong>关系</li><li><strong>偏序</strong>是指，集合中只有部分元素之间可以比较的关系。 比如复数集中并不是所有的数都可以比较大小，那么“大小”就是复数集的一个<strong>偏序</strong>关系。</li><li>在一个可线性化的系统中，存在全序操作关系。</li><li>因果关系至少可以定义为偏序</li></ul><p>因果关系对所发生的事件施加了某种排序，某件事应该发生在某件事之前。我们称之为因果一致性。如</p><ul><li>Git 基于数字签名的上下文关系</li></ul><p>可线性化是全序操作关系，系统的行为像是只有一个数据副本。而对因果关系而言，如果两个操作没有 happens-before 的关系，则它们就是并发关系，并发的关系无法排序，这表明因果关系是可定义为偏序。同时，并发就意味着分支和合并。</p><p>因果关系可以认为是一种可以容忍网络延迟，又能对网络故障提供容错的最强一致性模型。看似需要线性化的系统，实际上是需要因果一致性。</p><h3 id="序列号排序"><a href="#序列号排序" class="headerlink" title="序列号排序"></a>序列号排序</h3><p>在存在唯一主节点的系统里面，主节点可生成单调递增的 id 来为每个操作复制。这样结果一定满足因果一致性。而不存在主节点的分布式系统，则需要外部手段来生成唯一自增 ID，如</p><ul><li>不同节点奇偶 id</li><li>不同节点负责不同区间</li><li>通过墙上时钟</li></ul><p>Lamport 时间戳</p><ul><li>每个节点都有一个唯一的标识符</li><li>每个节点都有一个计数器</li><li>每个节点都追踪迄今为止看到的最大计数器值，如果发现比自己维护的要大，则修改成该值</li></ul><p>实际上，处理时还是需要去收集到所有的请求信息才能去构造请求顺序。所以，还是主从复制的做法更直接有效。为了解决主节点的限制，以及故障时的节点切换，需要全序关系广播和原子广播。</p><blockquote><p>顺序保证的范围是作用在分区之上，如果需要跨分区则需要非常多的工作（如 Kafka）</p></blockquote><p>全序广播通常是指节点间交换信息的协议，要满足以下的基本安全属性</p><ul><li>可靠发送，如果发送到了一个节点，也必须发送到其它所有节点</li><li>发送到每个节点的顺序相同</li></ul><p>可以将其视为日志，如复制日志，事务日志和预写日志，传递信息则是通过追加日志的形式更新。全序关系模型是基于异步的模型，保证顺序可以发送，但不保证发送成功，而可线性化则强调就近性，读取时保证可以看到最新的输入。</p><h2 id="分布式事务和共识"><a href="#分布式事务和共识" class="headerlink" title="分布式事务和共识"></a>分布式事务和共识</h2><p>集群节点一致</p><ul><li>主节点选举</li><li>原子事务提</li></ul><h3 id="两阶段提交-2PC"><a href="#两阶段提交-2PC" class="headerlink" title="两阶段提交 2PC"></a>两阶段提交 2PC</h3><p>引入中间的协调者，其通常实现为共享库，运行在相同的进程中</p><ul><li>阶段 1，协调者询问所有的参与者（多个数据节点）是否可以提交请求</li><li>阶段 2，提交请求</li></ul><p>如果 1 中有任何的节点拒绝，则协调者在 2 中会向所有的节点发送放弃的请求。 而参与者确定了可以提交之后后续不会有放弃的选择，除非协调者确定不提交。对于单点系统而言，两个步骤是合二为一的，即写入事务日志即提交。如果协调者已经确定了阶段 1，则如果在阶段 2 之前失败，则参与者也不会单方面进行放弃。没有协调者的消息，参与者无法知道下一步的行动。协调者本身也应该拥有事务日志，在恢复后来决定是否需要继续未完成的事务。  </p><h3 id="XA-交易"><a href="#XA-交易" class="headerlink" title="XA 交易"></a>XA 交易</h3><p>异构系统下如何实施两阶段提交的一个工业标准。</p><ul><li>停顿时仍持有锁</li><li>启发式决策，参与节点在紧急情况下单方面做出决定，放弃或者继续那些停顿的事务</li></ul><p>如果协调者是应用服务器的一部分时，则其日志也变成了可靠系统的重要组成部分，要求与数据库本身一样重要。此时，已经不是无状态的系统了。</p><h3 id="支持容错的共识"><a href="#支持容错的共识" class="headerlink" title="支持容错的共识"></a>支持容错的共识</h3><p>共识算法的基本性质</p><ul><li>协商一致性（Uniform agreement），所有的节点都接受相同的决议</li><li>诚实性（Integrity），不能反悔，即不能对一项决议有两次决定</li><li>合法性（Validity），如果决定了值 v，则一定是由某个节点提议的</li><li>可终止性（Termination），节点如果不崩溃，则最终一定可以达成某项协议</li></ul><p>容错体现在可终止性上，强调一个共识算法不能空转，必须取得实质性的进展。此处，前提是发生崩溃和不可用的节点数必须小于半数。常见算法有</p><ul><li>VSR</li><li>Paxos</li><li>Raft</li><li>Zab</li></ul><p><strong>Epoch 和 Quorum</strong></p><p>协议定义了一个世代编号，在每个世代里面，主节点是唯一确定的。如果主节点挂掉，则其余节点进行新一轮的选举，选举会赋予一个单调递增的 epoch 号。如果出现两个不同的 epoch 号则更高的获胜。</p><p>主节点如果想要做出决定，则须将提议发给其它所有节点，如果没有更高的 epoch 主节点存在时，在对当前提议进行投票。</p><p>算上之前的主节点投票，这里会有两轮投票，其中参与投票的节点必须至少有一个参与了最近一次主节点选举。换言之，如果在针对提议的投票中没有出现更高 epoch 号码，则可以认为当前的主节点没有替换。</p><h1 id="Chapter-10-批处理系统"><a href="#Chapter-10-批处理系统" class="headerlink" title="Chapter 10 - 批处理系统"></a>Chapter 10 - 批处理系统</h1><p>最简单的批处理就是使用如 awk 等工具进行日志分析。其特点</p><ul><li>将字节序列视为 ASCII 文本</li><li>如果需要功能的组合则通过管道进行连接</li><li>避免使用严格的格式或者二进制</li><li>避免交互式输入</li></ul><p>最大的局限性就是其只能在一台机器上运行。而 MapReduce 就是一个类似于分布式的 UNIX 工具，其进行输入和输出依赖于像 HDFS 这样的分布式文件系统。</p><h1 id="Chapter-11-流处理系统"><a href="#Chapter-11-流处理系统" class="headerlink" title="Chapter 11 - 流处理系统"></a>Chapter 11 - 流处理系统</h1><p>流处理系统即把时间流视为一种数据管理机制：一种无界的，持续增量处理的方式。在批处理系统中，通过文件名来标识一组相关的数据，流系统中，则被视为主题或者流。</p><h2 id="消息系统"><a href="#消息系统" class="headerlink" title="消息系统"></a>消息系统</h2><p>对于不同的消息系统，会有两个问题</p><ul><li>如果生产者发送消息的速度比消费者快，会发生什么？<ul><li>TCP 和 UNIX 管道会有个固定的缓冲区，如果填满了，发送者会堵塞</li></ul></li><li>如果节点崩溃或者暂时离线，是否有消息丢失？<ul><li>持久性和吞吐量并不能同时满足</li></ul></li></ul><p>如果不通过消息系统，则可以考虑</p><ul><li>UDP 组播，适用于低延迟的场景</li><li>无代理的消息库（如 ZeroMQ）</li><li>HTTP 或者 RPC 请求</li></ul><p>这些方法都需要一个在应用层失效的重传机制，还需要生产者和消费者都是一直在线的。</p><p>消息代理，即消息队列，允许一个第三方服务来缓存需要传递的消息。具体体现在 JMS 和 AMQP 的标准上，常见的实现有 RabbitMQ，ActiveMQ。对于已经确认过的消息就会从代理中删除，就无法再接收该消息了。引入了像数据库的持久化存储的日志思想，就有了基于日志的消息存储。常见就是 Kafka。</p><h2 id="数据库与流"><a href="#数据库与流" class="headerlink" title="数据库与流"></a>数据库与流</h2><p>在使用数据库的过程中，难免会因为缓慢增添外部的缓存，这样就容易出现不一致的情况。</p><p>Change Data Capture，CDC，即变更数据捕获。记录了写入数据库的所有变更，并可以复制到其它系统的实行来提取数据。数据库的复制日志解析可以从数据源处拿 CDC。有了这些日志，就可以进行数据的重放。在需要重建索引或者外部缓存时，也可以通过从偏移量为 0 处开始，扫描日志中的所有消息，这也是一个数据库内容的完整副本。相关的日志压缩也是通过扫描指定的 key 获取其最新值来压缩合并。</p><p>事件溯源，也可以将涉及到的所有对应用程序状态的变保存为事件的日志。不同的是，事件存储仅支持追加，不鼓励更新和删除。事件通常用来表达用户行为的意图，而不是一种对行为结果进行相应状态更新的机制。用户会发出一个命令，当命令检查完成（合法性校验）之后就变成了一个事件，这是命令和事件的区分。</p><h2 id="状态，流和不可变性"><a href="#状态，流和不可变性" class="headerlink" title="状态，流和不可变性"></a>状态，流和不可变性</h2><p>通过不可变事件的追加日志，判断问题和恢复也会很方便。除此以外，还会捕获很多的信息，如顾客的意图而不只是购买的最终订单。</p><p>通过相同的事件日志可以派生出多个视图，如 Druid 和 Pistachio 都使用 Kafka 作为输入源，通过从事件日志到数据库的转换，能得到基于不同 key 的数据库。这种将数据写入和读取形式分开，并允许不同的读取视图的想法被称为命令查询职责分离（Command Query Responsibility Segregation，CQRS），与此相对的，传统数据库和模式设计的方法是基于数据查询和数据写入的形式相同。</p><p>这种模式最大的问题是，事件的捕获和变更日志的捕获通常是异步的，需要处理 “读自己写的” 这种问题。</p><ul><li>同步执行读取视图的更新，这写入一个事务将写操作合并到一个原子处理中，所以要么是事件日志和读取视图都在同一个存储系统，要不跨不同系统的分布式事务，或者是全序广播</li><li>从事件日志中导出当前状态<ul><li>对多对象事务的大部分需求源自单个用户需要在不同地方修改数据的操作</li><li>通过事件溯源可以设计一个事件使其成为用户操作的独立描述，将其追加到日志中，这样原子化就会很容易</li><li>如果以相同的方式对日志和应用程序进行分区（分区 3 的用户需要更新应用程序分区 3），则简单的单线程消费者不需要对写操作进行并发控制</li></ul></li></ul><h2 id="流处理"><a href="#流处理" class="headerlink" title="流处理"></a>流处理</h2><p>和批处理作业最大的不同是，流处理是不会结束的，因此排序无意义，也不能使用排序合并 join，容错机制也必须改变，从头开始运行运作了几年的流处理作业，几乎是不可能的。</p><p>长期以来流处理都被用于监控目的，则需要长期对特定事件进行分析，如信用卡消费，交易系统的价格变化。</p><p>复杂事件处理（Complex Event Processing）与正则表达式在字符串中搜索特定的字符模式类似，CEP 允许指定规则在流中搜索特定模式的事件。CEP 的查询是长久存储的，来自输入流的事件不断流过他们以匹配事件模式。实现有类似 Samza 这种支持声明式的 SQL 查询。</p><p>与 CEP 相对的则是流分析，CEP 专注特定的事件序列，而流分析更多关注大量时间累积的效果和统计指标，如</p><ul><li>速率</li><li>在时间窗口的平均值</li><li>趋势的变化</li></ul><p>有时也使用概率算法，如布隆过滤器，常见的实现为 Flink 和 Kafka Streams。</p><h2 id="流的事件问题"><a href="#流的事件问题" class="headerlink" title="流的事件问题"></a>流的事件问题</h2><p>需要关注的是事件时间和处理时间，如果使用的是处理节点上的本地系统时钟来确定窗口，在节点出现排队，网络故障或性能下降导致节点重启去处理过去的事件，就会出现事件事件和处理时间上延迟会非常明显。</p><p>为了调整不正确的设备时钟，需要记录三个时间戳</p><ul><li>事件发生的事件</li><li>事件发送到服务器的时间</li><li>服务器收到事件的时间</li></ul><p>第三个时间戳减去第二个则可以估计出设备时钟和服务器时钟的偏移量（还要考虑到网络延迟），将偏移量应用于第一个时间即可估计出一个事件实际发生的真实时间。</p><h3 id="窗口类型"><a href="#窗口类型" class="headerlink" title="窗口类型"></a>窗口类型</h3><p>定义用于作事件统计的一个事件范围</p><ul><li>轮转窗口，即一个固定的时间范围，如下午 2 点到 3 点，晚上 7 点 30 分到 7 点 31 分</li><li>跳跃窗口，有固定的长度，但是允许平滑过渡，如一个五分钟的窗口，之前在统计 10:30 到 10:35 内的事件，设定 hop 是 1 分钟，那下一个窗口则可以是 10:31 到 10:36</li><li>滑动窗口，包含在彼此的某个间隔内发生的所有事件，然后在事件过期之后从缓冲区中删除</li><li>会话窗口，将同一用户相关的事件都分组在一起，一旦一个用户一段时间没有活动，则窗口结束</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>花了大半年时间看了两遍，看下来的总体感觉是我知道了一些东西，以及我还是有很多东西不懂。</p><p>特别是第 8 章和第 9 章，分布式的事务和共识的一些知识，属于都了解，但在应用层做开发很少会接触，知道其存在，但有时会不知道其为何要如此设计。整本书算是一个后端开发整体技术的一个总览，并且在很多地方也有较为深入的介绍。是一本好书，希望 2 3 年后再看一遍，希望那时能看懂更多。</p>]]></content>
    
    
    
    <tags>
      
      <tag>security</tag>
      
      <tag>network</tag>
      
      <tag>protocol</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OAuth Introduction</title>
    <link href="/2021/10/23/oauth-introduction/"/>
    <url>/2021/10/23/oauth-introduction/</url>
    
    <content type="html"><![CDATA[<p>上下文中的 OAuth 仅考虑 OAuth 2.0，不考虑旧版的协议。</p><h1 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a>Protocol</h1><blockquote><p>OAuth 2.0 is not an authentication protocol.</p></blockquote><blockquote><p>As far as an OAuth client is concerned, it asked for a token, got a token, and eventually used that token to access some API. It doesn’t know anything about who authorized the application or if there was even a user there at all.</p></blockquote><p>OAuth 并不是一个用户认证协议，并不关注用户是谁和或者谁在使用 API。它关注授权和维护 token。用户认证是一个更大的主题，你可以以 OAuth 来实现。</p><h1 id="Roles"><a href="#Roles" class="headerlink" title="Roles"></a>Roles</h1><p>OAuth defines four roles:</p><ul><li><strong>Resource Owner</strong>: The resource owner is the <em>user</em> who authorizes an <em>application</em> to access their account. The application’s access to the user’s account is limited to the scope of the authorization granted (e.g. read or write access)</li><li><strong>Client</strong>: The client is the <em>application</em> that wants to access the <em>user</em>’s account. Before it may do so, it must be authorized by the user, and the authorization must be validated by the API.</li><li><strong>Resource Server</strong>: The resource server hosts the protected user accounts.</li><li><strong>Authorization Server</strong>: The authorization server verifies the identity of the <em>user</em> then issues access tokens to the <em>application</em>.</li></ul><p>Resource Owner 就是用户，用户委托 Client 以其去获取相应资源。如 Facebook &#x2F; GitHub &#x2F; Google 登陆是第三方网站希望获取 ID 信息，在授权确认的网页上会写有需要获取的权限，如邮箱地址。</p><p><img src="/images/oauth-abstract-flow.png" alt="oauth-abstrac-flow"></p><ol><li>The <em>application</em> requests authorization to access service resources from the <em>user</em></li><li>If the <em>user</em> authorized the request, the <em>application</em> receives an authorization grant</li><li>The <em>application</em> requests an access token from the <em>authorization server</em> (API) by presenting authentication of its own identity, and the authorization grant</li><li>If the application identity is authenticated and the authorization grant is valid, the <em>authorization server</em> (API) issues an access token to the application. Authorization is complete.</li><li>The <em>application</em> requests the resource from the <em>resource server</em> (API) and presents the access token for authentication</li><li>If the access token is valid, the <em>resource server</em> (API) serves the resource to the <em>application</em></li></ol><h1 id="Grant-Types"><a href="#Grant-Types" class="headerlink" title="Grant Types"></a>Grant Types</h1><p>在上面 Abstract Protocol Flow 图中，首先是需要获取 authorization grant 以此来获取 access token，OAuth 2 包含有以下几种类型</p><h2 id="Authorization-Code"><a href="#Authorization-Code" class="headerlink" title="Authorization Code"></a><strong>Authorization Code</strong></h2><p>对浏览器友好，基于 HTTP 不断地 redirect</p><ol><li>请求 authorization server 的 API，其中包含一个注册时的 <code>client_id</code> 和想要获取的权限 <code>scope</code>，<code>redirect_uri</code> 和 <code>response_type=code</code></li><li>弹出给用户的是一个权限描述页面，用户确认后，redirect 到 client 的 <code>redirect_uri</code>，请求中包含一个 authorization code</li><li>client 再以 code 去 authorization server 请求 token 接口获取 access token</li><li>authorization server 会返回相应 access token 给到 client<ol><li>payload 中可能会包含一个有效期更长的 refresh token</li></ol></li></ol><p>此外，最开始 authorization code 的 request 会带有一个随机字符串 <code>state</code> ，客户端可以存在 cookie 中，authorization server 返回时，也会带有 <code>state</code> 字段以防 CSRF 攻击。</p><h3 id="PKCE-Proof-Key-for-Code-Exchange"><a href="#PKCE-Proof-Key-for-Code-Exchange" class="headerlink" title="PKCE - Proof Key for Code Exchange"></a>PKCE - Proof Key for Code Exchange</h3><p>在 Authorization Code 流程中，authorization code 可能会被拦截，需要额外安全措施来保证 token 的生成，PKCE 就是一个该协议的扩展来帮助降低安全风险</p><ol><li>请求 authorization server 的 API 时，Client 会新增一个随机的 <code>code_challenge</code> 和相应的 hash 算法 <code>code_challenge_method</code> 字段</li><li>authorization server 记录这些字段，在 Client 请求 access token 时，其会新增一个 <code>code_verifier</code> 字段（使用 hash 算法转换的值）</li><li>authorization server 验证该字段和之前提供的 <code>code_challenge</code> 转换之后的值一致，则认为该 client 合法</li><li>返回 access token</li></ol><p>在 OKTA 服务中，提及到如果需要在浏览器端使用 PKCE，则需要浏览器支持 Web Crypto API，具体可见该 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API">文档</a>。</p><h2 id="Client-Credentials"><a href="#Client-Credentials" class="headerlink" title="Client Credentials"></a>Client Credentials</h2><p>不是针对实际用户的，而是用于 server to server 的 API 认证</p><ol><li>向 authorization server 发送请求，其中 <code>grant_type=client_credentials</code> ，还包括事前约定的 <code>client_id</code> 和 <code>client_secret</code></li><li>authorization server 认证之后就返回 access token</li></ol><h2 id="Device-Code"><a href="#Device-Code" class="headerlink" title="Device Code"></a>Device Code</h2><blockquote><p>The device code grant type provides a means for devices that lack a browser or have limited inputs to obtain an access token and access a user’s account.</p></blockquote><p>为没有浏览器，或者不方便进行输入的设备而设</p><ol><li>client 向 authorization server 发送请求，endpoint 和上述两种类型不同，需要提供 <code>client_id</code></li><li>返回带 <code>device_code</code> 和 <code>user_code</code></li><li>此时设备可以提供一个 QR Code，以 <code>device_code</code> 构成链接，用户端输入 <code>user_code</code> 来即可完成校验</li></ol><h1 id="OpenID-Connect-OIDC"><a href="#OpenID-Connect-OIDC" class="headerlink" title="OpenID Connect - OIDC"></a>OpenID Connect - OIDC</h1><blockquote><p>OpenID Connect protocol is built on the OAuth 2.0 protocol and helps authenticate users and convey information about them. It is also more opinionated than plain OAuth 2.0, for example in its scope definitions.</p></blockquote><p>OAuth 本身其实不关心用户，它是一个授权协议，关注使用 token 去请求 API。OIDC 则是复用其获取 token 的流程，加以扩展功能。</p><blockquote><p>OAuth 2.0 leaves a lot of details up to implementers. For instance, it supports scopes, but scope names are not specified. It supports access tokens, but the format of those tokens are not specified.</p></blockquote><p>OIDC 完善了很多 OAuth 细节，包括 <code>scope</code> 定义，以及一个用于获取用户信息 <a href="https://openid.net/specs/openid-connect-core-1_0.html#UserInfo">API</a> 等。此外一个重要的不同是，在返回 access token 时，带上了一个 <code>id_token</code> 。这是一个 JWT 格式的字段，解析出来就是用户信息。</p><p>OAuth 定义好了流程，OIDC 则是复用了流程定义好了如字段和格式，而且定义好了 meta 信息的 API，用以做自动发现等功能（此功能是一个 Optional 选项，详情可见 <a href="https://openid.net/connect/">文档</a>）。</p><p>一些常用的 API</p><ul><li>&#x2F;userinfo - 获取用户信息</li><li>&#x2F;introspect - 检查 token</li><li>&#x2F;token - 获取新的 token</li><li>&#x2F;revoke - 取消一个 access token 或者 refresh token</li></ul><h2 id="Single-Sign-On-SSO"><a href="#Single-Sign-On-SSO" class="headerlink" title="Single Sign On - SSO"></a>Single Sign On - SSO</h2><p><img src="/images/single-sign-on.png" alt="single-sign-on"></p><p>上图是浏览器端的 SSO 流程。一个场景如下</p><ol><li>用户登录 domain1 时，此时没有 cookie，则需要跳转到 domain3 进行登录</li><li>domain3 登录成功后，则使用返回 token 和 redirect 到 domain1，domain1 使用该 token 即可完成登录</li><li>在登录成功 domain3 时，浏览存会存放有 domain3 的 cookie</li><li>当 domain2 需要登录，跳转到 domain3 则不需要进行用户认证，通过 cookie 即可确认登录状态</li><li>返回 token 和 redirect 到 domain2</li></ol><p>这么做的原因首先是浏览器的 Same Origin Policy 限制，不同域名 cookie 不可见。所以只能通过跳转到入口 domain 来使用其 cookie。</p><h1 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h1><p>OIDC 授权结束后，client 可以拿到三个 token</p><ul><li>access token</li><li>refresh token</li><li>id token</li></ul><p>access token 用于访问资源，refresh token 则用于申请新的 access token ，id token 则是 JWT 格式封装的用户信息，除了 id token 限制使用 JWT 之外，其余没有格式要求。不同 token 的生命周期不同，以 OKTA 平台为例，其默认 token 生命周期为</p><ul><li><strong>ID token:</strong> 60 minutes</li><li><strong>Access token:</strong> 60 minutes</li><li><strong>Refresh token:</strong> 90 days</li></ul><p>OKTA 中 access token 也是使用 JWT 封装，resource server 收到请求时，也可以进行时间和签名认证。其中，JWT header 包含一个 <code>kid</code> 字段，通过一个无需认证 endpoint <code>/.well-known/oauth-authorization-server</code>（这个就是上文提到的 OIDC 用于接口发现的 meta endpoint）可以查询到一个 <code>/keys</code> 的 URI，通过 <code>client_id</code> 和 <code>kid</code> 即可查到相应的公钥，有了公钥就可以进行 access token 的合法性校验。</p><p>access token 到期后，需要使用 refresh token 请求 <code>/token</code> 接口获取新的 access token 。refresh token 生命周期更长，为了防止被滥用，可以考虑</p><ul><li>使用 Native App 需要保证 refresh token 存放到只有自己程序可以访问的区域</li><li>每次申请新的 access token 之后，会带新 refresh token 下来，revoke 旧 refresh token</li><li>用户退出后，revoke 旧 refresh token</li></ul><p>在 OKTA 中，Browser-based 的 App 甚至不支持 refresh token</p><blockquote><p>Note: The Authorization Code flow with PKCE doesn’t support refresh tokens for SPAs and other browser-based apps.</p></blockquote><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>本文是对 OKTA 平台进行调研的一些笔记，我倒是重新认真看了 OAuth &#x2F; SSO 的一些概念，受益颇多。个人感觉从 OAuth 进化到 OIDC 的路倒是挺有意思的。有文章介绍道说最开始是用了一个 <code>/me</code> 的 endpoint 来获得用户信息，但这样是有违 OAuth 设计的，于是在 OAuth 基础上实现了 OIDC。</p><p>协议的设计和使用范围的确是一个很难平衡的点，总是很容易将就使用某个协议去越级做一些事情。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2">An Introduction To Oauth 2</a></li><li><a href="https://www.oauth.com/playground/index.html">https://www.oauth.com/playground/index.html</a></li><li><a href="https://oauth.net/articles/authentication/">https://oauth.net/articles/authentication/</a></li><li><a href="https://datatracker.ietf.org/doc/html/rfc6749">https://datatracker.ietf.org/doc/html/rfc6749</a></li><li><a href="https://developer.okta.com/blog/2017/06/21/what-the-heck-is-oauth#pseudo-authentication-with-oauth-20">https://developer.okta.com/blog/2017/06/21/what-the-heck-is-oauth#pseudo-authentication-with-oauth-20</a></li><li><a href="https://auth0.com/blog/what-is-and-how-does-single-sign-on-work/">https://auth0.com/blog/what-is-and-how-does-single-sign-on-work/</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API">https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API</a></li><li><a href="https://openid.net/connect/">https://openid.net/connect/</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>security</tag>
      
      <tag>network</tag>
      
      <tag>protocol</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL InnoDB Introduction</title>
    <link href="/2020/11/13/mysql-innodb/"/>
    <url>/2020/11/13/mysql-innodb/</url>
    
    <content type="html"><![CDATA[<p>用了 MySQL 这么久，现在才第一次看了下官方关于 InnoDB 的<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-introduction.html" title="innodb-introduction">文档</a></p><h2 id="Base"><a href="#Base" class="headerlink" title="Base"></a>Base</h2><p>先简单说一些 InnoDB 的特性</p><ul><li>ACID，支持事务 commit 和 rollback</li><li>Row-level Locking</li><li>聚簇索引（<a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_clustered_index">clustered index</a>）</li><li>Foreign Key</li></ul><h3 id="Benefits"><a href="#Benefits" class="headerlink" title="Benefits"></a>Benefits</h3><ul><li>自动 crash recovery</li><li>用 buffer pool 缓存表和索引的数据</li><li>可以压缩表和索引</li><li>adaptive hash index，对于 <code>=</code> 和 <code>IN</code> 操作，能缓存常用 pages</li></ul><h3 id="Best-Practices"><a href="#Best-Practices" class="headerlink" title="Best Practices"></a>Best Practices</h3><ul><li>指定主键或者 auto-increment</li><li>关闭 autocommit</li><li>不要使用 <code>LOCK TABLES</code> 而是 <code>SELECT ... FOR UPDATE</code> 锁对应行</li></ul><h2 id="Advanced"><a href="#Advanced" class="headerlink" title="Advanced"></a>Advanced</h2><h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><p>Atomicity</p><ul><li><p>Autocommit setting</p></li><li><p>COMMIT &#x2F; ROLLBACK</p></li></ul><p>Consistency</p><ul><li>doublewrite buffer</li><li>crash recovery</li></ul><p>Isolation</p><ul><li>Autocommit setting</li><li><code>SET ISOLATION LEVEL</code> 语句</li><li>Locking</li></ul><p>Durability</p><ul><li>doublewrite buffer</li><li><code>fsync() </code> system call</li></ul><p>其中，Consistency 和 Durability 着重点有点不同，前者是指数据上的一致性，满足相应的约束设置，通过一些策略保证数据在 crash 之后不会丢失或者出现脏数据。后者则是关注与硬件打交道，保证数据库软件上的稳定性。</p><p>上述提到的 <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_doublewrite_buffer" title="glos_doublewrite_buffer">doublewrite buffer</a> 是一个为了故障恢复的设计。</p><blockquote><p>Before writing <strong>pages</strong> to the <strong>data files</strong>, <code>InnoDB</code> first writes them to a storage area called the doublewrite buffer. Only after the write and the flush to the doublewrite buffer have completed, does <code>InnoDB</code> write the pages to their proper positions in the data file.</p></blockquote><p>意思是先写 buffer，然后确认 buffer 没问题再写到对应的磁盘位置。如果中间出现了 crash，就能直接从 buffer 写到对应的文件。需要注意的是，这里的数据单位是 page，这里的 page 也不是 OS 的 page 的概念，而是引擎本身定义的数据单元。</p><p>如 InnoDB 默认是 16K，计算校验和也是以 16K 作为单位，但如果系统的 page 大小小于 16K 的话，则意味这有多次写入。如果出现 crash 的情况，只要计算 buffer 和磁盘处的校验和是否一致即可。此外，buffer 的写入是线性的，buffer 到实际的磁盘写入是随机的，所以实际上没有 100% 的性能损耗，更详细的可见 <a href="https://www.percona.com/blog/2006/08/04/innodb-double-write/" title="innodb-double-write">这篇文章</a>。</p><h3 id="Multi-Versioning"><a href="#Multi-Versioning" class="headerlink" title="Multi-Versioning"></a>Multi-Versioning</h3><p>InnoDB 是一个 multi-versioned 的存储引擎， 保留了修改前的信息，用以并发和事务回滚。实现上，有额外三个字段来支持这个功能</p><ul><li><code>DB_TRX_ID</code> insert 或者 update 当前行的上一个事务 ID，此外，删除也会有</li><li><code>DB_ROLL_PTR</code> 指向一个 undo log 记录</li><li><code>DB_ROW_ID</code> 一个单调递增的 row ID，如果没有指定主键，则会自动创建一个聚簇索引指向这个 ID，否则不会有任何索引引用该 ID</li></ul><p>undo log 有两种，一种是 insert undo log，当事务提交之后就可以删除。另一种是 update undo log，与事务生命周期绑定，只有还有事务引用该版本，则会一直保留。如果还有对应的 update undo log 存在，则该行数据则不会实际删除，只有相关事务提交了，update undo log 不在了才会进行删除，这由额外的线程进行 purge 操作。</p><p>而对于聚簇索引和二级索引，两者处理逻辑也不同。前者直接在当前记录上更新，后者则不包含隐藏字段，标记删除然后新增记录。如果标记删除后，则通过聚簇索引相关的 undo log 反查去当时版本的记录。</p><h3 id="In-Memory-Structures"><a href="#In-Memory-Structures" class="headerlink" title="In-Memory Structures"></a>In-Memory Structures</h3><h4 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h4><blockquote><p>The buffer pool is an area in main memory where <code>InnoDB</code> caches table and index data as it is accessed. The buffer pool permits frequently used data to be processed directly from memory, which speeds up processing. On dedicated servers, up to 80% of physical memory is often assigned to the buffer pool.</p></blockquote><p>具体实现是基于 LRU 算法的 linked list，以 page 为元素。实现上有 new sublist 和 old sublist 两种。</p><p><img src="https://dev.mysql.com/doc/refman/8.0/en/images/innodb-buffer-pool-list.png" alt="innodb-buffer-pool-list"></p><p>insert 位置设计得挺巧妙，看了解释，触发 insert 有两种情况，一是实际调用 SQL，还有就是 read-ahead 产生的数据。那些用一次的 SQL 就会不断淘汰 old sublist 的元素，而不会影响 new sublist 的元素。</p><h4 id="Change-Buffer"><a href="#Change-Buffer" class="headerlink" title="Change Buffer"></a>Change Buffer</h4><blockquote><p>The change buffer is a special data structure that caches changes to secondary index pages when those pages are not in the buffer pool.</p></blockquote><p>与聚簇索引不同，二级索引的写入很多是无序的，所以如果需要对二级索引的更新需要现在缓存中聚合不然会浪费大量 IO。在闲置或者在 slow shutdown 的过程中，才会将 buffer 中的改动同步到磁盘。</p><h4 id="Adaptive-Hash-Index-amp-amp-Log-Buffer"><a href="#Adaptive-Hash-Index-amp-amp-Log-Buffer" class="headerlink" title="Adaptive Hash Index &amp;&amp; Log Buffer"></a>Adaptive Hash Index &amp;&amp; Log Buffer</h4><p>AHI (Adaptive Hash Index) 由引擎本身监控判断如果创建 hash index 会提升速度，才会去创建。其缓存的是 index 和 pages 的关系，其可作用于几乎所有的涉及到 index 使用的场景，如 <code>JOIN</code>，但对 <code>LIKE</code> 的作用则不大。</p><p>Log Buffer 用作 redo log 缓存，减少磁盘 IO。</p><h3 id="On-Disk-Structures"><a href="#On-Disk-Structures" class="headerlink" title="On-Disk Structures"></a>On-Disk Structures</h3><h4 id="AUTO-INCREMENT"><a href="#AUTO-INCREMENT" class="headerlink" title="AUTO_INCREMENT"></a>AUTO_INCREMENT</h4><p>InnoDB 有配置项来针对 auto increment 字段。[<code>innodb_autoinc_lock_mode</code>][3] 有三个选项</p><ul><li>0 - traditional</li><li>1 - consecutive</li><li>2 - interleaved</li></ul><p>旧版本 MySQL 用的是 1，MySQL 8.0 用的是 2。这个反映了 8.0 的同步机制从 statement-based replication（SBR） 到 row based replication （RBR）的改变。前者对语句的确定性要求很高，但 auto increment 的字段有可能出现不连续的情况，后者则对此并不敏感。创建表需指定 auto increment 的字段为 primary key 或者 unique key 才行（需要查询其最大值），而常见就是作为表的主键。</p><p>目前有几种场景会产生新的记录</p><ul><li>simple insert - 简单的 insert 语句，可以预先得知插入行数</li><li>bulk insert - 不能预先得知插入的行数</li><li>mixed-mode - 插入语句中指定了 auto increment 字段的值和 <code>INSERT ... ON DUPLICATE KEY UPDATE</code>。后者会出现新分配的 auto increment 的值不会被使用的情况</li></ul><p>traditional 是有一个表级锁 AUTO-INC 来限制，而锁的使用是针对 insert 语句的，而不是事务，保证了 binary log 的执行顺序，那么就能保证同步之后的数据也是确定的。</p><p>consecutive 机制是针对 bulk insert。如果在做 bulk insert 的时候，源表和结果表不一致，则目的表在源表进行第一行查询时上一个 shared lock 之后再上一个 AUTO-INC 锁。如果源表和目的表一致，则在所有的行都查询出来时加上 shared lock 再上一个 AUTO-INC 锁。</p><p>如果是 simple insert，则没有 AUTO-INC 锁，而是通过一个 mutex 来获取已知的自增的值。这个 mutex 获取是在资源的阶段，而不是一直持有到语句结束。如果别的事务在使用 bulk insert 则意味着需要等待。目前而言，auto increment 产生的值都是连续的，而在 mixed mode 的情况下，会预先生成多几个值，而用不上的几个就丢失了。</p><p>interleaved 机制则是没有表级别的 AUTO-INC 锁。语句可以同时执行，auto increment 的字段则是保证单调递增的生成，所以无法确定语句最后分配的值是多少。</p><p>上述三种策略都是针对语句级别，意味着在事务回滚的时候，还是会有空缺的 auto increment 的值。第三种情况性能最好，但不能保证生成的值是连续的。</p><h4 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h4><p>InnoDB 用 primary key 或者是第一个 unique index 作为 clustered index。每个表只有一个，如果不定义则会默认生成一个，和别的 index 即 secondary index 相比，其性能好很多。clustered index 指向数据的 page 而 secondary index 指向 clustered index，即 secondary index 会多一次 IO 操作。</p><h4 id="Tablespaces"><a href="#Tablespaces" class="headerlink" title="Tablespaces"></a>Tablespaces</h4><p>system tablespace 是 change buffer 的存储区域，也存放创建于该区域的表和索引。</p><p>file-per-table tablespaces 存放一个 InnoDB 表数据和索引。单个文件的实现在管理上非常方便，如果多个表混用一个文件，涉及到文件磁盘空间管理，备份等操作都相对复杂。相对地，做 <code>fsync</code> 操作时，如果一次写入多个表就涉及到多个 <code>fysnc</code> 的调用。</p><p>general tablespace 通过 <code>CREATE TABLESPACE xx</code> 来创建，是一个 InnoDB 的 shared tablespace。相比上述的 file-per-table tablespaces，general tablespace 可以定义再 MySQL 的目录之外来做数据管理或者数据备份，也有更好的内存优化来做内存表。</p><p>还有如 undo tablespace，temporary tablespace 等在运行时针对特定功能的 tablespace，在实际应用层使用上不会涉及，更多是后续针对实际使用的性能指标来进行微调。</p><h4 id="Redo-Log-and-Undo-Logs"><a href="#Redo-Log-and-Undo-Logs" class="headerlink" title="Redo Log and Undo Logs"></a>Redo Log and Undo Logs</h4><blockquote><p>The redo log is a disk-based data structure used during crash recovery to correct data written by incomplete transactions. During normal operations, the redo log encodes requests to change table data that result from SQL statements or low-level API calls.</p></blockquote><p>Redo Log 是记录准备要去变更数据的 SQL 或者 API。InnoDB 事务中的 A C D 特性就是由 Redo Log 去实现。在故障中恢复时，就是依赖 Redo Log 去将还没持久化的数据写到磁盘中。</p><p>Redo Log 不是直接写磁盘，而是写到一个 log buffer 先，然后由 log buffer 再写到磁盘。在 8.0 之前的版本，log buffer 的写入需要先获取一个全局的 mutex 来，8.0 之后改用了一个基于 atomic 的操作来在 log buffer 预分配空间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">sn_t</span> start_sn = log.sn.<span class="hljs-built_in">fetch_add</span>(len);<br><span class="hljs-type">const</span> <span class="hljs-type">sn_t</span> end_sn = start_sn + len;<br></code></pre></td></tr></table></figure><p>此外还有一个 link buf 来维护 log buffer 到磁盘的写入磁盘的进度，详细细节可见 [这篇文章][4]。log buffer 的写入是需要保证顺序的，每一次写入到 log buffer 则会携带一个自增的 LSN（Log Sequence Number），之后顺序写入到磁盘。写如了 log 之后，后续的实际修改数据或者故障恢复就有了保证。</p><p>Undo Logs 相对简单，它记录了需要回滚时用到的旧记录和在多个事务操作过程中需要看修改前的记录的场景。因为仅仅在系统运行时使用，它设计上没有像 Redo Log 那样需要多个 IO 来保证写入，性能上比 Redo Log 好很多。</p><h3 id="Locking-and-Transaction"><a href="#Locking-and-Transaction" class="headerlink" title="Locking and Transaction"></a>Locking and Transaction</h3><h4 id="Shared-x2F-Exclusive-x2F-Intention-Locks"><a href="#Shared-x2F-Exclusive-x2F-Intention-Locks" class="headerlink" title="Shared &#x2F; Exclusive &#x2F; Intention Locks"></a>Shared &#x2F; Exclusive &#x2F; Intention Locks</h4><p>InnoDB 有两种行级别锁</p><ul><li>A shared (S) lock permits the transaction that holds the lock to read a row.</li><li>An exclusive (X) lock permits the transaction that holds the lock to update or delete a row.</li></ul><p>对数据读是共享锁，写时是互斥锁。此外还有一个意向锁</p><ul><li>An intention shared lock (IS) indicates that a transaction intends to set a shared lock on individual rows in a table.</li><li>An intention exclusive lock (IX) indicates that a transaction intends to set an exclusive lock on individual rows in a table.</li></ul><p>意向锁是表级锁</p><blockquote><p>Before a transaction can acquire a shared lock on a row in a table, it must first acquire an IS lock or stronger on the table.<br>Before a transaction can acquire an exclusive lock on a row in a table, it must first acquire an IX lock on the table.</p></blockquote><p>它们的关系如下</p><table><thead><tr><th>*</th><th>X</th><th>IX</th><th>S</th><th>IS</th></tr></thead><tbody><tr><td>X</td><td>Conflict</td><td>Conflict</td><td>Conflict</td><td>Conflict</td></tr><tr><td>IX</td><td>Conflict</td><td>Compatible</td><td>Conflict</td><td>Compatible</td></tr><tr><td>S</td><td>Conflict</td><td>Conflict</td><td>Compatible</td><td>Compatible</td></tr><tr><td>IS</td><td>Conflict</td><td>Compatible</td><td>Compatible</td><td>Compatible</td></tr></tbody></table><blockquote><p>A lock is granted to a requesting transaction if it is compatible with existing locks, but not if it conflicts with existing locks. A transaction waits until the conflicting existing lock is released. If a lock request conflicts with an existing lock and cannot be granted because it would cause <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_deadlock">deadlock</a>, an error occurs.</p></blockquote><p>行锁请求前必须先请求对应意向锁，意向锁间不互斥。意向锁是为了更快地判断是否存在互斥的行锁而不用进行全表扫描，如已经申请了 IX 锁，那么 S 锁就申请失败（这个 S 锁前会有一个 IS 锁但不会与 IX 互斥）。意向锁由系统自身进行控制，我们能操作的是显示声明需要用共享锁或者互斥锁。</p><h4 id="Record-Locks"><a href="#Record-Locks" class="headerlink" title="Record Locks"></a>Record Locks</h4><blockquote><p>A record lock is a lock on an index record. For example, <code>SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE;</code> prevents any other transaction from inserting, updating, or deleting rows where the value of <code>t.c1</code> is <code>10</code>.</p></blockquote><p><code>SELECT ... FOR UPDATE</code> 会申请一个针对索引的锁，即使没有创建索引也会根据其隐含的聚簇索引来加锁，任何 insert &#x2F; update &#x2F; delete 相关记录的操作都会被禁止。</p><h4 id="Gap-Locks"><a href="#Gap-Locks" class="headerlink" title="Gap Locks"></a>Gap Locks</h4><blockquote><p>A gap lock is a lock on a gap between index records, or a lock on the gap before the first or after the last index record.</p></blockquote><p>当隔离级别是 <code>READ COMMITTED</code> 时，gap lock 不会生效。与别的锁不一样， 两个事务可以对同一个范围申请 gap lock，只有插入数据到该范围时 lock 才生效。</p><h4 id="Next-Key-Locks"><a href="#Next-Key-Locks" class="headerlink" title="Next-Key Locks"></a>Next-Key Locks</h4><blockquote><p>A next-key lock is a combination of a record lock on the index record and a gap lock on the gap before the index record.</p></blockquote><p>InnoDB 的共享锁和互斥锁实际上是作用在 index 上的。为了解决 <code>REPEATABLE READ</code> 隔离级别情况下的幻读，在申请锁时，会连同数据索引附近的数据范围也会上锁。而如果是唯一索引，则会降级为 Record Lock。</p><h4 id="Insert-Intention-Locks"><a href="#Insert-Intention-Locks" class="headerlink" title="Insert Intention Locks"></a>Insert Intention Locks</h4><p>插入意向锁是一种由 <code>INSERT</code> 语句带来的锁。插入时在相应索引位置的附近的范围申请一个 index gap lock，如果其它事务同时插入到相同位置则需要等待锁释放。</p><p>此外还有一个为地理坐标系数据 Spatial index 设计的 Predicate 锁，这里就不展开说了。在不显示声明使用锁的情况下，不同的隔离级别会有不同的默认锁操作</p><ul><li>READ COMMITTED - 读不加锁，写入加锁，导致事务进行中时读取到别的事务提交的数据</li><li>REPEATABLE READ - 默认的隔离级别，第一次读时生成 snapshot，后续所有的 nonlocking select 都是读取到同一份数据，这部分是 MVCC 在起作用。而如果需要获取最新的数据，则需要 <code>SELECT ... FOR SHARE</code> 或者 <code>SELECT ... FOR UPDATE</code> 来读取，此时则是需要 Next-Key lock 来锁定一个范围，这样就能防止 Phantom Rows（幻读）出现。</li></ul><h3 id="Transaction"><a href="#Transaction" class="headerlink" title="Transaction"></a>Transaction</h3><h4 id="Isolation-Levels"><a href="#Isolation-Levels" class="headerlink" title="Isolation Levels"></a>Isolation Levels</h4><p>REPEATABLE READ，默认的隔离级别，MVCC 和 locking select 相互作用解决幻读问题。</p><p>READ COMMITTED，每一次 nonlocking select 都是最新的数据，显式使用 locking select 也仅仅是 index lock 而不带 gap lock。</p><p>READ UNCOMMITTED 则是性能最好的一个，但是几乎不可能在现实中用到，会出现脏读的现象。</p><p>SERIALIZABLE 与 REPEATABLE READ 类似。如果 autocommit disabled 则每个 SELECT 都会隐式加上共享锁。如果 autocommit enabled 则每个 SELECT 是个单独的事务，在该隔离等级下，所有事务都是串行执行。</p><h4 id="Autocommit-Commit-and-Rollback"><a href="#Autocommit-Commit-and-Rollback" class="headerlink" title="Autocommit, Commit and Rollback"></a>Autocommit, Commit and Rollback</h4><p>默认情况下，autocommit enabled。没有明确 <code>START TRANSACTION</code> 或者 <code>BEGIN</code> 语句则会自动提交每一个语句。在事务中如果使用 <code>COMMIT</code> 则会将当前改动落盘，即对别的事务可见，即 autocommit disabled 的话，则 locking read 是无效的。</p><h4 id="Consistent-Nonlocking-Reads"><a href="#Consistent-Nonlocking-Reads" class="headerlink" title="Consistent Nonlocking Reads"></a>Consistent Nonlocking Reads</h4><blockquote><p>A consistent read means that InnoDB uses multi-versioning to present to a query a snapshot of the database at a point in time. The query sees the changes made by transactions that committed before that point of time, and no changes made by later or uncommitted transactions.</p></blockquote><p>在 RR 的隔离等级下，每一次查询相同的数据都是第一次请求时的 snapshot，如果需要查看最新的数据，则需要先 commit 当前的数据或者使用 blocking select。</p><h3 id="Deadlocks"><a href="#Deadlocks" class="headerlink" title="Deadlocks"></a>Deadlocks</h3><blockquote><p>A deadlock is a situation where different transactions are unable to proceed because each holds a lock that the other needs. Because both transactions are waiting for a resource to become available, neither ever release the locks it holds.</p></blockquote><p>文中提到的例子</p><table><thead><tr><th>transaction</th><th>A</th><th>B</th></tr></thead><tbody><tr><td>1</td><td><code>SELECT * FROM t WHERE i = 1 FOR SHARE</code></td><td></td></tr><tr><td>2</td><td></td><td><code>DELETE FROM t WHERE i = 1</code></td></tr><tr><td>3</td><td><code>DELETE FROM t WHERE i = 1</code></td><td></td></tr></tbody></table><p>因为事务 A 在 i &#x3D; 1 上有共享锁，B 申请互斥锁时需要等，之后 A 再申请互斥锁时则形成死锁。当死锁检测开启之后，会尝试回滚或者终止影响行数较小的事务。</p><p>避免死锁的方法</p><ul><li>需要记住，死锁不是问题，程序应该支持重试事务</li><li>尽量减少事务大小</li><li>如果业务逻辑上需要很多 <code>SELECT ... FOR UPDATE</code> 或者 <code>SELECT ... FOR SHARE</code>，也可以考虑 READ COMMITTED 的隔离等级</li></ul><h2 id="Replication"><a href="#Replication" class="headerlink" title="Replication"></a>Replication</h2><blockquote><p>Transactions that fail on the source do not affect replication. MySQL replication is based on the binary log where MySQL writes SQL statements that modify data</p></blockquote><p>这里有一个有意思的地方，replica 可以使用 MyISAM 来做引擎，这样一来像外键就没办法生效。如果你有一个表配置了外键的级联删除 <code>DELETE CASCADE</code> 则该表就不会删除关联的数据。不管是 statement-based 还是 row-based 复制也只是能够处理显式更新，而级联删除这种是引擎内部处理就没办法同步了。</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>其余的如数据压缩，I&#x2F;O，参数配置等一些章节就选择性跳过了，目前更多地使用像 AWS 的 RDS 也很少接触实际的数据库配置了。个人感觉最有用的是锁和事务相关的介绍，数据写入磁盘的考虑也是很精彩。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://draveness.me/whys-the-design-mysql-auto-increment/">https://draveness.me/whys-the-design-mysql-auto-increment/</a></li></ul><p>[3]: <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_autoinc_lock_mode">https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_autoinc_lock_mode</a>“innodb_autoinc_lock_mode”<br>[4]: <a href="https://mysqlserverteam.com/mysql-8-0-new-lock-free-scalable-wal-design/">https://mysqlserverteam.com/mysql-8-0-new-lock-free-scalable-wal-design/</a>“8.0-wal-design”</p>]]></content>
    
    
    
    <tags>
      
      <tag>mysql</tag>
      
      <tag>innodb</tag>
      
      <tag>database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cloud Design Patterns</title>
    <link href="/2020/09/14/cloud-design-patterns/"/>
    <url>/2020/09/14/cloud-design-patterns/</url>
    
    <content type="html"><![CDATA[<p>Link: <a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/">https://docs.microsoft.com/en-us/azure/architecture/patterns/</a></p><h2 id="Ambassador"><a href="#Ambassador" class="headerlink" title="Ambassador"></a>Ambassador</h2><p>代理人模式</p><blockquote><p>Resilient cloud-based applications require features such as circuit breaking, routing, metering and monitoring, and the ability to make network-related configuration updates. It may be difficult or impossible to update legacy applications or existing code libraries to add these features, because the code is no longer maintained or can’t be easily modified by the development team.</p></blockquote><p>统一代理网络请求，兼容多个语言的服务，统一配置服务地址，重试，Rate limits，验证需要的配置等等。类似于 sidecar 模式，集中处理请求。也可以担任一个注册中心的角色，统一对外的请求地址，别的进程只需要配置一个地址即可。</p><p>增加了 latency，如果是同一个语言的客户端，那么一个 package 也是一个更好的选择</p><h2 id="Anti-Corruption-Layer"><a href="#Anti-Corruption-Layer" class="headerlink" title="Anti-Corruption Layer"></a>Anti-Corruption Layer</h2><p>防腐层设计</p><blockquote><p>Most applications rely on other systems for some data or functionality. For example, when a legacy application is migrated to a modern system, it may still need existing legacy resources. New features must be able to call the legacy system. This is especially true of gradual migrations, where different features of a larger application are moved to a modern system over time.<br>Often these legacy systems suffer from quality issues such as convoluted data schemas or obsolete APIs. The features and technologies used in legacy systems can vary widely from more modern systems. To interoperate with the legacy system, the new application may need to support outdated infrastructure, protocols, data models, APIs, or other features that you wouldn’t otherwise put into a modern application.</p></blockquote><p>用于新老系统间的交互，防止旧系统的一些设计污染到新系统，两者中间沟通做了一个翻译层</p><h2 id="Asynchronous-Request-Reply"><a href="#Asynchronous-Request-Reply" class="headerlink" title="Asynchronous Request-Reply"></a>Asynchronous Request-Reply</h2><p>异步请求 &#x2F; 响应模式</p><blockquote><p>Decouple backend processing from a frontend host, where backend processing needs to be asynchronous, but the frontend still needs a clear response.</p></blockquote><p>后端处理是异步的，但是前端需要及时的响应。</p><blockquote><p>One solution to this problem is to use HTTP polling. Polling is useful to client-side code, as it can be hard to provide call-back endpoints or use long running connections. Even when callbacks are possible, the extra libraries and services that are required can sometimes add too much extra complexity.</p></blockquote><p>HTTP 轮询来解决问题，需要额外添加一个查询接口，用来查询任务是否已经完成，然后再调用资源接口来获取资源。<br>更规范的做法也可以通过一个 HTTP 302 的状态码指向真正的资源 URL。HTTP 202 状态码中也有如 Retry-After<br>来告知客户端请求频率</p><h2 id="Backends-for-Frontends"><a href="#Backends-for-Frontends" class="headerlink" title="Backends for Frontends"></a>Backends for Frontends</h2><blockquote><p>Create one backend per user interface. Fine-tune the behavior and performance of each backend to best match the needs of the frontend environment, without worrying about affecting other frontend experiences.</p></blockquote><p>考虑到兼容浏览器和移动设备，为两边考虑不同的接口去实现功能</p><h2 id="Bulkhead"><a href="#Bulkhead" class="headerlink" title="Bulkhead"></a>Bulkhead</h2><p>类似于船舱的分隔，将问题限制在局部而不是扩散到所有的服务。</p><blockquote><p>Partition service instances into different groups, based on consumer load and availability requirements. This design helps to isolate failures, and allows you to sustain service functionality for some consumers, even during a failure.</p></blockquote><p>可以根据系统的负载来进行分隔，不同类型的服务也可以放到不同的组。实际应用上如 k8s 限制内存和 CPU。</p><blockquote><p>Define partitions around the business and technical requirements of the application.</p></blockquote><h2 id="Cache-Aside"><a href="#Cache-Aside" class="headerlink" title="Cache-Aside"></a>Cache-Aside</h2><blockquote><p>Applications use a cache to improve repeated access to information held in a data store. However, it’s impractical to expect that cached data will always be completely consistent with the data in the data store. Applications should implement a strategy that helps to ensure that the data in the cache is as up-to-date as possible, but can also detect and handle situations that arise when the data in the cache has become stale.</p></blockquote><p>Cache-Aside 的模式是</p><ul><li>直接读缓存，如果缓存没有数据则去数据库查，查出来就更新到缓存中</li><li>涉及到更新则直接更新数据库，然后让缓存失效</li></ul><p>那么，是不是 Cache Aside 这个就不会有并发问题了？不是的，比如，一个是读操作，但是没有命中缓存，然后就到数据库中取数据，此时来了一个写操作，写完数据库后，让缓存失效，然后，之前的那个读操作再把老的数据放进去，所以，会造成脏数据。</p><p>但，这个 case 理论上会出现，不过，实际上出现的概率可能非常低，因为这个条件需要发生在读缓存时缓存失效，而且并发着有一个写操作。而实际上数据库的写操作会比读操作慢得多，而且还要锁表，而读操作必需在写操作前进入数据库操作，而又要晚于写操作更新缓存，所有的这些条件都具备的概率基本并不大。</p><p>Read-Through &amp;&amp; Write-Through</p><ul><li>和 Cache-Aside 的模式不同，Read-Through 和 Write-Through 将缓存隐藏到了自己的服务 &#x2F; 内库中，调用方对缓存无感知</li><li>Read-Through 套路就是在查询操作中更新缓存，当缓存失效的时候（过期或 LRU 换出）自己加载到缓存中</li><li>Write-Through 则是更新数据时发生。当有数据更新的时候，如果没有命中缓存，直接更新数据库，然后返回。如果命中了缓存，则更新缓存，然后再由 Cache 自己更新数据库</li></ul><p>Write-Behind</p><ul><li>在更新数据的时候，只更新缓存，不更新数据库，而我们的缓存会异步地批量更新数据库</li></ul><h2 id="Choreography"><a href="#Choreography" class="headerlink" title="Choreography"></a>Choreography</h2><blockquote><p>The services communicate with each other by using well-defined APIs. Even a single business operation can result in multiple point-to-point calls among all services. A common pattern for communication is to use a centralized service that acts as the orchestrator. It acknowledges all incoming requests and delegates operations to the respective services. In doing so, it also manages the workflow of the entire business transaction. Each service just completes an operation and is not aware of the overall workflow.</p></blockquote><p>如果是通过 HTTP &#x2F; RPC 来请求后面的服务，则会造成服务间的耦合。这里可用队列服务进行解耦。前端服务发送消息到后端，后端处理。后端的服务也可能不仅仅充当消费者的角色，也可能是二次加工的生产者角色。</p><blockquote><p>Each service isn’t only responsible for the resiliency of its operation but also the workflow. This responsibility can be burdensome for the service and hard to implement. Each service must retry transient, nontransient, and time-out failures, so that the request terminates gracefully, if needed. Also, the service must be diligent about communicating the success or failure of the operation so that other services can act accordingly.</p></blockquote><p>但如果数据链路过长，还是容易造成问题，如消费能力不一致，消息的处理难度不一致，会导致整个 workflow 出现消息处理的延迟</p><h2 id="Circuit-Breaker"><a href="#Circuit-Breaker" class="headerlink" title="Circuit Breaker"></a>Circuit Breaker</h2><blockquote><p>However, there can also be situations where faults are due to unanticipated events, and that might take much longer to fix. These faults can range in severity from a partial loss of connectivity to the complete failure of a service. In these situations it might be pointless for an application to continually retry an operation that is unlikely to succeed, and instead the application should quickly accept that the operation has failed and handle this failure accordingly.</p></blockquote><p>错误可能一时半会恢复不过来，一直重试只会导致请求者的资源浪费（发起请求的线程持有的数据库连接，内存等等）</p><blockquote><p>Note that setting a shorter timeout might help to resolve this problem, but the timeout shouldn’t be so short that the operation fails most of the time, even if the request to the service would eventually succeed.</p><p>The Circuit Breaker pattern, popularized by Michael Nygard in his book, Release It!, can prevent an application from repeatedly trying to execute an operation that’s likely to fail. Allowing it to continue without waiting for the fault to be fixed or wasting CPU cycles while it determines that the fault is long lasting. The Circuit Breaker pattern also enables an application to detect whether the fault has been resolved. If the problem appears to have been fixed, the application can try to invoke the operation.</p></blockquote><p>和重试不同，重试更多是针对一个接口的行为，但 Circuit Breaker 是由客户端（或者全局）维护的一个状态，保存着最近几次的请求成功与否的结果，用来预测当前是否处于失败的状态，如果是则直接返回失败而不去请求。Circuit Breaker 则是负责维护这些状态的转换</p><ul><li>Open - 服务正常</li><li>Half-Open - 服务有部分异常，可以限制 Rate Limit</li><li>Closed - 直接拒绝客户端请求</li></ul><h2 id="Claim-Check-Pattern"><a href="#Claim-Check-Pattern" class="headerlink" title="Claim-Check Pattern"></a>Claim-Check Pattern</h2><blockquote><p>Split a large message into a claim check and a payload. Send the claim check to the messaging platform and store the payload to an external service. This pattern allows large messages to be processed, while protecting the message bus and the client from being overwhelmed or slowed down. This pattern also helps to reduce costs, as storage is usually cheaper than resource units used by the messaging platform.</p></blockquote><p>将体积较大的消息体存到如 S3，数据库中。队列中发送的则是该数据的 meta 信息，给消费者去定位实际的消息体</p><h2 id="CQRS"><a href="#CQRS" class="headerlink" title="CQRS"></a>CQRS</h2><blockquote><p>The Command and Query Responsibility Segregation (CQRS) pattern separates read and update operations for a data store.</p></blockquote><p>传统的基于 ORM 的设计并没有区分数据库的读写操作，那么意味着对于复杂的读写操作需要处理的 mapping 会比较多。此外，读写两边的资源消耗是不一致的，扩容的操作也不好弄。</p><p>最基本的就是分离读写的 model，即数据库层的设计是根据具体的业务流程而不是对应某个 table。需要注意的是，如果是太简单的逻辑，硬是要使用 CQRS 模式，那么读写的数据库操作的代码的重复性会偏高，还不如简单的 ORM 操作。</p><blockquote><p>If separate read and write databases are used, they must be kept in sync. Typically this is accomplished by having the write model publish an event whenever it updates the database. Updating the database and publishing the event must occur in a single transaction.</p></blockquote><p>除了分离读写的 model 外，更极致点的做法是分离数据库，甚至对可以关系型数据库和文档型数据库混用。但分离数据库之后，提出了同步写数据库到读数据库这一步。</p><p>考虑到这里的读写数据库的分离，在数据一致性上只能是最终一致性，如果对这点很敏感的需要考虑是否合适</p><h2 id="Compensating-Transaction"><a href="#Compensating-Transaction" class="headerlink" title="Compensating Transaction*"></a>Compensating Transaction*</h2><blockquote><p>Applications running in the cloud frequently modify data. This data might be spread across various data sources held in different geographic locations. To avoid contention and improve performance in a distributed environment, an application shouldn’t try to provide strong transactional consistency. Rather, the application should implement eventual consistency</p></blockquote><p>强一致性的对资源的要求很高，如果可以应该追求最终一致性。一个业务逻辑如果分成多步来执行的话，如果中间出现问题，那么可能需要选择回滚已执行的步骤或者重试后续的步骤。而前者可能跨越多个数据库，服务等等，不一定都具备回滚操作的能力。</p><p>如对于订机票和订酒店的联合请求，如果后续流程有问题，则需要取消之前订的机票或者酒店，或者将选择权交给用户</p><h2 id="Competing-Consumers"><a href="#Competing-Consumers" class="headerlink" title="Competing Consumers"></a>Competing Consumers</h2><blockquote><p>Enable multiple concurrent consumers to process messages received on the same messaging channel. This enables a system to process multiple messages concurrently to optimize throughput, to improve scalability and availability, and to balance the workload.</p></blockquote><p>Producer 和 Consunmer 的模式，通过消息队列和 worker 去处理信息</p><h2 id="Compute-Resource-Consolidation"><a href="#Compute-Resource-Consolidation" class="headerlink" title="Compute Resource Consolidation"></a>Compute Resource Consolidation</h2><blockquote><p>Each computational unit consumes chargeable resources, even when it’s idle or lightly used. Therefore, this isn’t always the most cost-effective solution.</p></blockquote><p>计算单元如果单独管理，容易导致资源浪费（服务闲置等等）。那么改成服务分组，将一些业务相关度很强的放到一起进行 auto scaling。</p><p>服务间相互依赖就有可能出现一个服务负载高的相关服务的调用也会变高的情况，如果将其左右一个单元来进行 scaling 的话更好管理。云服务商会有一些别的解决方案，也有一些成本更低廉的如 AWS Lambda 类似的服务，到了这里可能需要考虑具体任务的运行时长和这些服务的启动速度等的权衡</p><h2 id="Deployment-stamps"><a href="#Deployment-stamps" class="headerlink" title="Deployment stamps"></a>Deployment stamps</h2><blockquote><p>The deployment stamp pattern involves deploying multiple independent copies of application components, including data stores. Each individual copy is called a stamp, or sometimes a service unit or scale unit. This approach can improve the scalability of your solution, allow you to deploy instances across multiple regions, and separate your customer data.</p></blockquote><p>考虑到跨地域 &#x2F; 租户的问题，可能服务需要一整套单独部署，做到数据层面的隔离。或者每个 stamp 的更新频率不一致，功能不一致，所以单独部署会是更好的选择。需要注意的是，单独部署后数据并不互通，这就涉及到一个迁移的过程</p><h2 id="Event-Sourcing"><a href="#Event-Sourcing" class="headerlink" title="Event Sourcing*"></a>Event Sourcing*</h2><blockquote><p>Instead of storing just the current state of the data in a domain, use an append-only store to record the full series of actions taken on that data. The store acts as the system of record and can be used to materialize the domain objects. This can simplify tasks in complex domains, by avoiding the need to synchronize the data model and the business domain, while improving performance, scalability, and responsiveness. It can also provide consistency for transactional data, and maintain full audit trails and history that can enable compensating actions.</p></blockquote><p>传统的 CRUD 在更新时候涉及到数据的，而处理数据的过程中会造成 Lock 等拖慢处理的速度。与 CQRS 一起食用更佳。如果系统对实时性要求高的，这个模式就不太适用了。</p><h2 id="External-Configuration-Store"><a href="#External-Configuration-Store" class="headerlink" title="External Configuration Store"></a>External Configuration Store</h2><blockquote><p>Move configuration information out of the application deployment package to a centralized location. This can provide opportunities for easier management and control of configuration data, and for sharing configuration data across applications and application instances.</p></blockquote><p>配置的统一管理，现在很多框架 &#x2F; 服务可以提供该功能了</p><h2 id="Federated-Identity"><a href="#Federated-Identity" class="headerlink" title="Federated Identity"></a>Federated Identity</h2><blockquote><p>Delegate authentication to an external identity provider. This can simplify development, minimize the requirement for user administration, and improve the user experience of the application.</p></blockquote><p>将权限认证托管到一个统一的认证服务，服务自己就不需要维护权限的信息。关键字 STS（Security Token Services） ，IdP（Identity providers）。不是简单的单点登录，而是包含权限模块的认证服务</p><h2 id="Gatekeeper"><a href="#Gatekeeper" class="headerlink" title="Gatekeeper"></a>Gatekeeper</h2><blockquote><p>Protect applications and services by using a dedicated host instance that acts as a broker between clients and the application or service, validates and sanitizes requests, and passes requests and data between them. This can provide an additional layer of security, and limit the attack surface of the system.   </p></blockquote><p>挡在公网服务和内网服务之间，转发请求，隔离环境，进行安全的通信。这种网关类的服务本身不进行业务的请求，而是仅仅作为一个手递手的作用</p><h2 id="Gateway-Aggregation"><a href="#Gateway-Aggregation" class="headerlink" title="Gateway Aggregation"></a>Gateway Aggregation</h2><blockquote><p>Use a gateway to aggregate multiple individual requests into a single request. This pattern is useful when a client must make multiple calls to different backend systems to perform an operation.</p></blockquote><p>客户端可能需要请求多次某个服务，或者请求多个服务才能完成一次业务，那么可以在 Gateway 层进行聚合（如在 Nginx 处解析 JSON 请求，然后将请求体解析发送到后端具体服务）。需要主义的是，尽量不要和后端服务耦合。</p><h2 id="Gateway-Offloading"><a href="#Gateway-Offloading" class="headerlink" title="Gateway Offloading"></a>Gateway Offloading</h2><blockquote><p>Properly handling security issues (token validation, encryption, SSL certificate management) and other complex tasks can require team members to have highly specialized skills. For example, a certificate needed by an application must be configured and deployed on all application instances. With each new deployment, the certificate must be managed to ensure that it does not expire. Any common certificate that is due to expire must be updated, tested, and verified on every application deployment.</p></blockquote><p>常见的就是 Nginx 或者 AWS 的 Loadbalancer 处理了外部传进来的 HTTPS 请求，然后解析之后转成 HTTP 请求到后端，后端服务就不需要自己维护 SSL 证书相关了</p><h2 id="Gateway-Routing"><a href="#Gateway-Routing" class="headerlink" title="Gateway Routing"></a>Gateway Routing</h2><blockquote><p>Route requests to multiple services using a single endpoint. This pattern is useful when you wish to expose multiple services on a single endpoint and route to the appropriate service based on the request.</p></blockquote><p>Gateway 担任一个 HTTP 负载均衡的角色，根据 path 转发到后端的服务。此外还可以外部的 path 不变，内部服务的 path 变动，或者根据权重测试后端两个版本的接口</p><h2 id="Geodes"><a href="#Geodes" class="headerlink" title="Geodes"></a>Geodes</h2><blockquote><p><strong>ge</strong>ographical n<strong>ode</strong>s</p></blockquote><p>意味在多个区域部署多个节点（集群），和之前提到的 stamp 不同，这里的不同的节点并不进行数据隔离，而是为了减少网络连接的延迟。</p><p>这些节点也可以处理一部分数据然后再推到中心去</p><h2 id="Health-Endpoint-Monitoring"><a href="#Health-Endpoint-Monitoring" class="headerlink" title="Health Endpoint Monitoring"></a>Health Endpoint Monitoring</h2><blockquote><p>Implement functional checks in an application that external tools can access through exposed endpoints at regular intervals. This can help to verify that applications and services are performing correctly.</p></blockquote><p>一个健康检查的 endpoint 可以包含数据库的，相关服务的检查。检查项包括</p><ul><li>状态码是否 200，是否页面错误或者被篡改</li><li>网络延迟如何</li><li>DNS 的返回记录是否正确，SSL 证书的过期时间</li></ul><p>上述的检查是基于公网的，如果是一个非业务端口需要暴露出去的话，需要考虑一些安全性问题</p><h2 id="Index-Table"><a href="#Index-Table" class="headerlink" title="Index Table"></a>Index Table</h2><blockquote><p>Create indexes over the fields in data stores that are frequently referenced by queries. This pattern can improve query performance by allowing applications to more quickly locate the data to retrieve from a data store.</p></blockquote><p>另外维护一个索引表，用于查询某些子集或者某个字段和对应主键的记录。不过这个是在数据库不支持次级索引的时候用的</p><h2 id="Leader-Election"><a href="#Leader-Election" class="headerlink" title="Leader Election*"></a>Leader Election*</h2><blockquote><p>Coordinate the actions performed by a collection of collaborating instances in a distributed application by electing one instance as the leader that assumes responsibility for managing the others. This can help to ensure that instances don’t conflict with each other, cause contention for shared resources, or inadvertently interfere with the work that other instances are performing.</p></blockquote><p>目前接触的比较少，实际情况是框架或者服务都有类似的功能了，很少需要实现一个集群选主的功能。如果需要协调多个实例的任务，才需要考虑该模式。实际使用时，也可以借助外部的分布式锁来防止出现冲突。而集群的 leader 更多应该是协调的作用，如果分配实际的任务给 leader 则可能出现 leader 因为负载挂掉的情况。</p><h2 id="Materialized-View"><a href="#Materialized-View" class="headerlink" title="Materialized View"></a>Materialized View</h2><p>来自维基的解释</p><blockquote><p>In <a href="https://en.wikipedia.org/wiki/Computing">computing</a>, a <strong>materialized view</strong> is a <a href="https://en.wikipedia.org/wiki/Database">database</a> object that contains the results of a <a href="https://en.wikipedia.org/wiki/Query_(databases)">query</a>. For example, it may be a local copy of data located remotely, or may be a subset of the rows and&#x2F;or columns of a table or <a href="https://en.wikipedia.org/wiki/Join_(SQL)">join</a> result, or may be a summary using an <a href="https://en.wikipedia.org/wiki/Aggregate_function">aggregate function</a>.</p></blockquote><blockquote><p>When storing data, the priority for developers and data administrators is often focused on how the data is stored, as opposed to how it’s read. The chosen storage format is usually closely related to the format of the data, requirements for managing data size and data integrity, and the kind of store in use. For example, when using NoSQL document store, the data is often represented as a series of aggregates, each containing all of the information for that entity.</p></blockquote><p>数据库 schema 设计很多时候不是为了方便 query，而是数据存储和方便管理。数据库本身就支持 view 这种用法，现代情况可能更复杂了，可能包含异构数据，或者存储在 Redis 或者 NoSQL 中，这种情况下结合 Event Sourcing 模式来使用更好。实际使用时需要考虑 view 的生成的速度和可能出现的数据不一致</p><h2 id="Pipes-And-Filters"><a href="#Pipes-And-Filters" class="headerlink" title="Pipes And Filters"></a>Pipes And Filters</h2><blockquote><p>Decompose a task that performs complex processing into a series of separate elements that can be reused. This can improve performance, scalability, and reusability by allowing task elements that perform the processing to be deployed and scaled independently.</p></blockquote><p>把一个很庞大的程序拆分成一个流水线，每个任务只负责一个简单的功能，不同的任务根据需要来进行扩容和缩容。但这种模式不适合处理那种有上下文关联的任务</p><h2 id="Priority-Queue"><a href="#Priority-Queue" class="headerlink" title="Priority Queue"></a>Priority Queue</h2><blockquote><p>Prioritize requests sent to services so that requests with a higher priority are received and processed more quickly than those with a lower priority. This pattern is useful in applications that offer different service level guarantees to individual clients.</p></blockquote><p>一般可以通过设置多个队列来实现优先队列，但是需要注意消费者的数量或者消费者选择队列的策略，有可能导致一直消费高优先级的队列导致低优先级的队列没有消费。也可以选择支持优先队列实现的服务，如 RabbitMQ</p><h2 id="Publisher-Subscriber"><a href="#Publisher-Subscriber" class="headerlink" title="Publisher-Subscriber"></a>Publisher-Subscriber</h2><blockquote><p>A <em>message</em> is a packet of data. An <em>event</em> is a message that notifies other components about a change or an action that has taken place.</p></blockquote><p>消息和事件的区别是，前者是传递数据，后者则是一个事件变动的通知。</p><h2 id="Queue-Based-Load-Leveling"><a href="#Queue-Based-Load-Leveling" class="headerlink" title="Queue-Based Load Leveling"></a>Queue-Based Load Leveling</h2><blockquote><p>Use a queue that acts as a buffer between a task and a service it invokes in order to smooth intermittent heavy loads that can cause the service to fail or the task to time out. This can help to minimize the impact of peaks in demand on availability and responsiveness for both the task and the service.</p></blockquote><p>请求的速率是会变化的，队列作为缓冲区。和前面的订阅者模式不同，这里注重的对大量消息处理时导致的问题，前者则是注重事件的状态的变化时的通知。此外，如果需要返回值或者对返回值有时延要求的场景不适合这种模式。</p><h2 id="Retry"><a href="#Retry" class="headerlink" title="Retry"></a>Retry</h2><blockquote><p>Enable an application to handle transient failures when it tries to connect to a service or network resource, by transparently retrying a failed operation. This can improve the stability of the application.</p></blockquote><p>重试是一个很常见的功能，需要注意要区分能重试的请求和不应该重试的请求。如 HTTP 状态码 504 Gateway Timeout 可能由于负载均衡背后的服务正在重启导致的临时错误应该进行重试，但因为请求的资源或者请求体本身的问题引发的 40X 的状态码重试就要考虑下是否有必要了。此外接口的是否幂等也影响重试策略，对一些会出现冲突的请求应该谨慎。</p><p>而重试的时间间隔也最好考虑在里面，如果选择固定的时间或者立即重试，那么会导致重试的请求不断的累计来攻击自己的服务。重拾的间隔可以增量或者按指数变化，这样新来的请求和旧的请求重试的时间就不会叠加在一起，平滑了服务的负载。</p><p>多次重试之后还是不行应该放弃该请求，实际使用时也可以结合之前说的 Circuit Breaker Pattern</p><h2 id="Saga-Distributed-Transactions"><a href="#Saga-Distributed-Transactions" class="headerlink" title="Saga Distributed Transactions*"></a>Saga Distributed Transactions*</h2><blockquote><p>The <em>saga</em> design pattern is a way to manage data consistency across microservices in distributed transaction scenarios. A saga is a sequence of transactions that updates each service and publishes a message or event to trigger the next transaction step. If a step fails, the saga executes compensating transactions that counteract the preceding transactions.</p></blockquote><p>现在的微服务架构下，每个服务可以根据自己的业务管理数据库，数据库的选型也可以多种多样，但这样对需要做一致性要求的业务来讲就出现问题了。可能依赖链前面做完了，但当前的服务出现了问题，或者数据不合法导致前面的服务做的改动需要回滚。</p><p>可以用队列分发消息或者一个中心的调度器去调用服务来进行一个业务中的不同步骤。需要注意的是，由于改动已经提交，那么回滚是不可能的，需要的时候一个相反的操作去撤销这些改动。</p><p>此外，在一个事务处理的过程中，由于数据库是分开管理，前面的服务已经写入数据库了，再去读该服务的数据，从全局的数据来讲，这些就是脏数据。为此，可能需要实现类似于数据库</p><h2 id="Scheduler-Agent-Supervisor"><a href="#Scheduler-Agent-Supervisor" class="headerlink" title="Scheduler Agent Supervisor"></a>Scheduler Agent Supervisor</h2><blockquote><p>The Scheduler maintains information about the progress of the task and the state of each step in a durable data store, called the state store. The Supervisor can use this information to help determine whether a step has failed. </p></blockquote><blockquote><p>When the application is ready to run a task, it submits a request to the Scheduler. The Scheduler records initial state information about the task and its steps (for example, step not yet started) in the state store and then starts performing the operations defined by the workflow. As the Scheduler starts each step, it updates the information about the state of that step in the state store (for example, step running).</p><p>If a step references a remote service or resource, the Scheduler sends a message to the appropriate Agent. The message contains the information that the Agent needs to pass to the service or access the resource, in addition to the complete-by time for the operation. If the Agent completes its operation successfully, it returns a response to the Scheduler. The Scheduler can then update the state information in the state store (for example, step completed) and perform the next step. This process continues until the entire task is complete.</p></blockquote><p>这种模式和 k8s scheduler 的模式一样，提交一个包含多个资源变动的请求，管理者将这些请求发送到相应的 Agent，然后监视 state 是否完成。如果出现失败就是相应的重试的策略的选择。</p><h2 id="Sequential-Convoy"><a href="#Sequential-Convoy" class="headerlink" title="Sequential Convoy"></a>Sequential Convoy</h2><blockquote><p>Process a set of related messages in a defined order, without blocking processing of other groups of messages.</p></blockquote><p>对数据进行分组，组内数据有序处理。分组也可以作为一个 auto scaling 的依据，某些组别的数据量较少，某些组别的数据量较大。Kafka 的分区 key 可以用作类似的需求，如将同一个 user id 的用户的数据映射到某个分区，保证而 Kafka 保证分区内的数据有序，这样就可以保证速度和顺序的要求</p><h2 id="Sharding"><a href="#Sharding" class="headerlink" title="Sharding"></a>Sharding</h2><blockquote><p>Divide a data store into a set of horizontal partitions or shards. This can improve scalability when storing and accessing large volumes of data.</p></blockquote><p>数据分区管理。分区的策略有几种：</p><ul><li>Lookup - 基于一个 shard key 来进行分配，可以直接 key - partition 的转换，也可以添加一个 virtual partition，在后面 physical partition 的分配不平衡时可以进行一个 rebalance 的操作</li><li>Range - shard key 是线性的，例如按照月份进行分区</li><li>Hash - 基于一个 hash function 来进行分区，好处是不用像 Lookup 维护一个状态表，问题就是分区间的负载不平衡，后续也难以 rebalance</li></ul><p>上述的分区是技术上的实现，此外还可以根据数据的重要程度，热度，还有安全隔离等业务上的逻辑来进行分区。</p><h2 id="Sidecar"><a href="#Sidecar" class="headerlink" title="Sidecar"></a>Sidecar</h2><blockquote><p>Applications and services often require related functionality, such as monitoring, logging, configuration, and networking services. These peripheral tasks can be implemented as separate components or services.</p></blockquote><p>将业务无关的东西解耦出来，如日志，配置，网络等等，服务本身只负责业务，而技术架构上的东西交给 sidecar 进行处理。</p><h2 id="Static-Content-Hosting"><a href="#Static-Content-Hosting" class="headerlink" title="Static Content Hosting"></a>Static Content Hosting</h2><blockquote><p>Deploy static content to a cloud-based storage service that can deliver them directly to the client. This can reduce the need for potentially expensive compute instances.</p></blockquote><p>资源静态化，减少计算，利用更多如 CDN，S3 等服务进行加速网站的请求</p><h2 id="Strangler"><a href="#Strangler" class="headerlink" title="Strangler"></a>Strangler</h2><blockquote><p>Incrementally migrate a legacy system by gradually replacing specific pieces of functionality with new applications and services. As features from the legacy system are replaced, the new system eventually replaces all of the old system’s features, strangling the old system and allowing you to decommission it.</p></blockquote><p>旧服务的迁移到新服务，中间的过程不能一次性完成的话，存在新旧服务同时运行的情况，那么需要在前面加一个如代理或者负载均衡来处理新旧的交替。</p><h2 id="Throttling"><a href="#Throttling" class="headerlink" title="Throttling"></a>Throttling</h2><blockquote><p>Control the consumption of resources used by an instance of an application, an individual tenant, or an entire service. This can allow the system to continue to function and meet service level agreements, even when an increase in demand places an extreme load on resources.</p></blockquote><p>限流，和之前的 Circuit Breaker 有点不同，这次是主动保护服务，防止过载。对一些请求过于频繁的用户主动进行丢弃，或者对服务内某些功能进行裁剪，只保留核心功能。</p><p>这里最好还是和客户端进行配合，通过特定的返回值告诉客户端下次请求的时间，或者客户端也屏蔽掉一些非核心功能。</p><h2 id="Valet-Key"><a href="#Valet-Key" class="headerlink" title="Valet Key"></a>Valet Key</h2><blockquote><p>Use a token that provides clients with restricted direct access to a specific resource, in order to offload data transfer from the application. This is particularly useful in applications that use cloud-hosted storage systems or queues, and can minimize cost and maximize scalability and performance.</p></blockquote><p>服务端不直接维护文件，流的资源，想法，通过 token 授予有限的权限给到客户端，客户端直接操作如 S3 等资源。减轻了服务端的负载，带宽等资源的占用，需要注意的就是数据的安全问题</p>]]></content>
    
    
    
    <tags>
      
      <tag>nginx</tag>
      
      <tag>engineering</tag>
      
      <tag>architecture</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>About SSL And TLS</title>
    <link href="/2020/08/21/about-ssl-tls/"/>
    <url>/2020/08/21/about-ssl-tls/</url>
    
    <content type="html"><![CDATA[<p>本文旨在简要介绍关于 SSL &#x2F; TLS 的知识</p><h2 id="Base"><a href="#Base" class="headerlink" title="Base"></a>Base</h2><p>TLS 是 SSL 的迭代版本，SSL 自从 3.0 之后便不再开发，TLS 1.0 为其继任者，目前最新版本为 TLS 1.3，而 TLS 1.0 也在 2020 年被废弃。下文统一使用 TLS 来进行说明，不进行区分 SSL &#x2F; TLS。</p><h3 id="Handshake"><a href="#Handshake" class="headerlink" title="Handshake"></a>Handshake</h3><p>TLS 连接在建立了 TCP 连接之后，首先是 TLS 握手步骤。TLS 安全性是基于非对称加密，而非对称加密对计算资源消耗十分巨大，并不适合在这种非常频繁的连接 &#x2F; 数据传输操作上使用，而 TLS 的做法是先使用非对称加密进行握手，得到一个双方可信的对称加密用的秘钥，然后在此后的数据传输中都使用该秘钥来进行加密。</p><p>握手的步骤大致如下（摘自 <a href="https://zinglix.xyz/2019/05/07/tls-handshake/">TLS 握手究竟做了什么？</a>）</p><ol><li>客户端发起连接，客户端带上自己产生的随机数 A 和支持的加密套件向服务器发出 <code>Client Hello</code> 请求</li><li>服务器收到请求后带上自己的随机数 B 以及选择的 Cypher Suite 返回 <code>Server Hello</code> 信息。在之后服务器发送自己的证书。<strong>此时服务器也可要求客户端出示证书</strong>。发送完成后发送 <code>Server Hello Done</code> 信息</li><li>客户端通过验证服务器证书是否可靠以决定是否继续通信，若不可信则关闭连接</li><li>若认为可信客户端则会生成一个新随机数 C，称为预主密钥（Pre Master Key），用于之后生成会话密钥，通过来自于证书的公钥进行加密提供给服务器</li><li>客户端会再传递一个 <code>Change Cipher Spec</code>表示之后信息会使用新的会话密钥（session keys）加密信息和哈希。然后客户端发送 <code>Client finished</code> 握手结束</li><li>服务器收到数据后解密得到预主密钥，计算得出会话密钥，然后同样向客户端发送 <code>Change Cipher Spec</code>  和 <code>Server finished</code></li></ol><p>这里可以看到，TLS 握手阶段需要 2 个 RTT。这里面还不包括 TCP 建立连接的三次握手的时间。除此以外，步骤 3 还可能进行一次 OCSP（The Online Certificate Status Protocol） 或者 CRL（Certificate revocation list，证书吊销列表） 的请求，这些请求结果会被缓存，我们更关心的是剩下的这 2 个 RTT。</p><p>除此以外，如果断开了 TLS 连接，本身还支持连接复用机制，这样就可以减少 TLS 握手的时间损耗。</p><p>通信双方握手结束后，双方都有了用于进行对称加密的会话密钥，之后通信都使用该密钥来加密 &#x2F; 解密。上述流程是基于 RSA 算法的秘钥交换，此外还有一种 DH 的算法，可参考文后的链接。</p><h3 id="Certificate"><a href="#Certificate" class="headerlink" title="Certificate"></a>Certificate</h3><p>在上文中提到，握手阶段客户端会验证证书是否可信。在服务器发送自己的证书给到客户端时，客户端需要进行校验该证书是否合法。</p><p>一个证书包括</p><ul><li><strong>The domain name that the certificate was issued for</strong></li><li>Which person, organization, or device it was issued to</li><li><strong>Which certificate authority issued it</strong></li><li><strong>The certificate authority’s digital signature</strong></li><li><strong>Associated subdomains</strong></li><li><strong>Issue date of the certificate</strong></li><li>Expiration date of the certificate</li><li><strong>The public key (the private key is kept secret)</strong></li></ul><p>Certificate Authority（CA）是独立的第三方，负责签发和维护 TLS 证书。证书本身带有数字签名，该数字签名使用的是其父级证书的私钥来签发，通过查询其父级证书通过其公钥即可查询出签名是否一致。而证书校验这个过程是一直递归到根证书，根证书是自签名的，这样就可以验证证书是否合法，这个链路称之为证书链（Chain of trust）。</p><p>而被信任的根证书是随着操作系统，浏览器等分发，只要客户端验证一直到根证书都没问题，则认为该证书是合法的。伪造证书的关键在于 CA 签发证书是否严谨，此外如果没有得到根证书的验证也无法得到信任。</p><p>常用的像 Fiddler 这类抓包工具，需要添加一个它自己的根证书这样才能解析 HTTPS 的流量，它自己本身就是类似于中间人攻击的角色。</p><h3 id="Nginx-Examples"><a href="#Nginx-Examples" class="headerlink" title="Nginx-Examples"></a>Nginx-Examples</h3><p>基本的配置为</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span>              <span class="hljs-number">443</span> ssl;<br>    <span class="hljs-attribute">server_name</span>         www.example.com;<br>    <span class="hljs-attribute">ssl_certificate</span>     www.example.com.crt;<br>    <span class="hljs-attribute">ssl_certificate_key</span> www.example.com.key;<br>    <span class="hljs-attribute">ssl_protocols</span>       TLSv1 TLSv1.<span class="hljs-number">1</span> TLSv1.<span class="hljs-number">2</span>;<br>    <span class="hljs-attribute">ssl_ciphers</span>         HIGH:!aNULL:!MD5;<br>    <span class="hljs-attribute">ssl_client_certificate</span> xxx.pem;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中最重要的是，<code>ssl_certificate</code> 为证书地址，<code>ssl_certificate_key</code> 为私钥地址，其余则为相应的 TLS 的配置，如 TLS 的版本，使用的算法等等。除此以外还有更多的配置可用，具体可查阅 Nginx 的 http ssl module。</p><p>之前的握手阶段也提到过，服务端在返回自己的证书的时候，也可以要求客户端提供证书。客户端证书是用来校验是否是可信用户。上面有个 <code>ssl_client_certificate</code> 配置项，需要制定一个 PEM 格式的 CA 证书来验证客户端。配置了客户端证书就必须在请求是明确指定证书来请求服务端，否则就是 403 错误，常见的 HTTP Library 都支持配置证书。</p><h2 id="Advanced"><a href="#Advanced" class="headerlink" title="Advanced"></a>Advanced</h2><h3 id="False-Start"><a href="#False-Start" class="headerlink" title="False-Start"></a>False-Start</h3><p>之前也提到过，一次 TLS 握手至少需要 2 个 RTT。但其实，在客户端算出随机数 C 时，已经可以得出用于非对称加密用的秘钥。启用 False Start 的特性之后，可以随着 <code>Client finished</code> 返回服务端时，把实际的请求信息也带到服务端。这样算下来，TLS 握手的时间可以减少到 1 个 RTT。</p><h3 id="Keyless"><a href="#Keyless" class="headerlink" title="Keyless"></a>Keyless</h3><p>上述的 Nginx 样例，更多是在自己源站服务端使用 TLS，而现在更多是托管于 CDN 后面，这里就需要一些另外的设置。看了下常见的公有云的文档，都是需要将自己相关域名证书私钥上传才能在 CDN 节点启用 TLS。</p><p>这样子在私钥的管理上会有问题。后来就有了 Cloudflare 提供的 Keyless 服务。其原理就是整个 TLS 握手需要解析一次客户端使用公钥加密的数据，那么只需要额外提供一个 Key Server 去帮忙解析这个加密过的数据就行。而后，我们只需要保证 CDN 节点到 Key Server 的链路是安全的，就可以保证 TLS 的安全性。</p><p>Conclusion</p><p>TLS 本身还是挺有意思的</p><ul><li>对称加密的安全性有问题，于是我们使用非对称加密来加密数据</li><li>非对称加密不能加密太多内容，并且速度比不上对称加密，那么我们就通过非对称加密协商一个用于安全沟通的对称加密秘钥</li><li>握手时考虑了双方的随机数不可信的问题</li><li>有第三方 CA 来保证证书的安全性</li><li>现在有了很多硬件可以加速非对称加密 &#x2F; 解密的速度</li></ul><p>未来浏览器会逐步停止支持 HTTP 协议的网站，一点点的损耗换来安全，何乐而不为呢？参考阅读中重点推荐最后一个，比较完整的展示了 TLS 的特性。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://zinglix.xyz/2019/05/07/tls-handshake">https://zinglix.xyz/2019/05/07/tls-handshake</a></li><li><a href="https://razeencheng.com/post/ssl-handshake-detail">https://razeencheng.com/post/ssl-handshake-detail</a></li><li><a href="https://developer.baidu.com/resources/online/doc/security/https-pratice-1.html">https://developer.baidu.com/resources/online/doc/security/https-pratice-1.html</a></li><li><a href="https://www.cloudflare.com/learning/ssl/what-is-an-ssl-certificate/">https://www.cloudflare.com/learning/ssl/what-is-an-ssl-certificate/</a></li><li><a href="https://nginx.org/en/docs/http/ngx_http_ssl_module.html">https://nginx.org/en/docs/http/ngx_http_ssl_module.html</a></li><li><a href="https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/">https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>nginx</tag>
      
      <tag>security</tag>
      
      <tag>ssl</tag>
      
      <tag>tls</tag>
      
      <tag>https</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx stream debug</title>
    <link href="/2020/06/07/nginx-stream-debug/"/>
    <url>/2020/06/07/nginx-stream-debug/</url>
    
    <content type="html"><![CDATA[<p>由于客户需要做 IP 白名单，所以我们在 AWS 建了两个 EC2 然后做了个 Nginx TCP Proxy，对应的 upstream 是 AWS 的 API Gateway。Nginx 最开始的版本类似于</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">user</span>  nginx;<br><span class="hljs-attribute">worker_processes</span>  <span class="hljs-number">1</span>;<br><span class="hljs-attribute">error_log</span>  /var/log/nginx/<span class="hljs-literal">error</span>.log <span class="hljs-literal">warn</span>;<br><span class="hljs-attribute">pid</span>        /var/run/nginx.pid;<br><br><span class="hljs-section">events</span> &#123;<br>    <span class="hljs-attribute">worker_connections</span>  <span class="hljs-number">1024</span>;<br>&#125;<br><br><span class="hljs-section">stream</span> &#123;<br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">proxy_pass</span> www.example.com:<span class="hljs-number">8080</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种白名单的流量的走向大概是</p><p>domain -&gt; CNAME to AWS ELB -&gt; ELB forward to EC2 -&gt; EC2 Nginx upstream to AWS API Gateway</p><p>而没有白名单的流量走向</p><p>domain -&gt; AWS API Gateway</p><p>逻辑上是没有问题的，然后问题就出现了</p><h2 id="SSL-issues"><a href="#SSL-issues" class="headerlink" title="SSL issues"></a>SSL issues</h2><blockquote><p>hostname ‘xxx’ doesn’t match either of ‘*.yyy.net’, ‘yyy.net’</p></blockquote><p>初看之下是证书不匹配的问题，xxx 对应我们自己的做了静态 IP 的域名，而 yyy.net 对应的是一些别的公司的域名。</p><p>这里我的看法是，因为 Nginx 的 upstream 对应的是 AWS API Gateway，如果域名后面的 IP 变了，而你还连着原来的 IP 就会有类似的问题，我自己也测试过，只要你改了域名的指向，Nginx 还是会连着旧的 IP，除非你手动 reload 或者 restart Nginx。</p><h2 id="Resolver"><a href="#Resolver" class="headerlink" title="Resolver"></a>Resolver</h2><p>搜索了一圈，这个 <a href="https://serverfault.com/questions/240476/how-to-force-nginx-to-resolve-dns-of-a-dynamic-hostname-everytime-when-doing-p/593003#593003">回答</a> 比较接近正确答案了。那时候去试了下这个配置，发现 set 是不能用在 stream 的 module 里面的，而有些回答也提出了在 upstream 处设置 resolver，但 stream 的 upstream 是不能设置 resolver 的。</p><p>这时的配置类似于</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">user</span>  nginx;<br><span class="hljs-attribute">worker_processes</span>  <span class="hljs-number">1</span>;<br><span class="hljs-attribute">error_log</span>  /var/log/nginx/<span class="hljs-literal">error</span>.log <span class="hljs-literal">warn</span>;<br><span class="hljs-attribute">pid</span>        /var/run/nginx.pid;<br><br><span class="hljs-section">events</span> &#123;<br>    <span class="hljs-attribute">worker_connections</span>  <span class="hljs-number">1024</span>;<br>&#125;<br><br><span class="hljs-section">stream</span> &#123;<br>    <span class="hljs-attribute">resolver</span> <span class="hljs-number">8.8.8.8</span> valid=<span class="hljs-number">60s</span>;<br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">proxy_pass</span> www.example.com:<span class="hljs-number">8080</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果是运行起来没问题，但是一段时间 DNS 记录变了之后，还是会出现 SSL 证书问题。</p><p><a href="https://medium.com/driven-by-code/dynamic-dns-resolution-in-nginx-22133c22e3ab">这篇文章</a> 也提到类似的方式，还提了一点</p><blockquote><p>Nginx evaluates the value of the variable per-request, instead of just once at startup. By setting the address as a variable and using the variable in the <code>proxy_pass</code> directive, we force Nginx to resolve the correct load balancer address on every request.</p></blockquote><p>这一点在我看来是十分诡异的，通过设置变量而不是直接配置的形式就能让 Nginx 每次请求再单独解析 DNS 记录。</p><h2 id="Traefik"><a href="#Traefik" class="headerlink" title="Traefik"></a>Traefik</h2><p>当时试了几种方法无果，想着要不换个软件试下好了，就试了下 Traefik，配置如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">traefik:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">traefik:v2.2</span><br>    <span class="hljs-attr">ports:</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;8080:80&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">./traefik.toml:/etc/traefik/traefik.toml</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">./tcp-proxy.toml:/etc/traefik/tcp-proxy.toml</span><br></code></pre></td></tr></table></figure><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-comment"># traefik.toml</span><br><span class="hljs-section">[entryPoints]</span><br>  <span class="hljs-section">[entryPoints.api]</span><br>    <span class="hljs-attr">address</span> = <span class="hljs-string">&quot;:80&quot;</span><br><br><span class="hljs-section">[providers.file]</span><br>  <span class="hljs-attr">filename</span> = <span class="hljs-string">&quot;/etc/traefik/tcp-proxy.toml&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-comment"># tcp-proxy.toml</span><br><span class="hljs-section">[tcp.routers]</span><br>  <span class="hljs-section">[tcp.routers.api]</span><br>    <span class="hljs-attr">entryPoints</span> = [<span class="hljs-string">&quot;api&quot;</span>]<br>    <span class="hljs-attr">rule</span> = <span class="hljs-string">&quot;HostSNI(`*`)&quot;</span><br>    <span class="hljs-attr">service</span> = <span class="hljs-string">&quot;api&quot;</span><br><br><span class="hljs-section">[tcp.services]</span><br>  <span class="hljs-section">[tcp.services.api.loadBalancer]</span><br>    <span class="hljs-section">[[tcp.services.api.loadBalancer.servers]]</span><br>      <span class="hljs-attr">address</span> = <span class="hljs-string">&quot;www.example.com:8080&quot;</span><br></code></pre></td></tr></table></figure><p>不幸的是，本地测试能复现 Nginx 上的问题，如 <a href="https://github.com/containous/traefik/issues/5675">issues&#x2F;5675</a>。其实这里也可以看到，与 DNS cache 或者缓存没有什么关系，而是在建立连接时用了这个 IP，后续并没有去更新。</p><blockquote><p>Expected behavior: When the remote end dies or is rebuilt, the proxy gets timed out and a new one gets brought up.</p><p>Actual behavior: all connections to this load balancer fail for eternity (we left it for an hour and it was still broken) until traefik is restarted and a new connection is instantiated with the correct IP.</p></blockquote><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>最后的解决方法来源于 <a href="https://www.dosarrest.com/ddos-blog/nginx-with-stream-module-dynamic-upstream-cname/">这里</a>。因为在 stream 中无法使用 set，那么我们就用 map 来代替吧</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs awk">user  nginx;<br>worker_processes  <span class="hljs-number">1</span>;<br>error_log  <span class="hljs-regexp">/var/</span>log<span class="hljs-regexp">/nginx/</span>error.log warn;<br>pid        <span class="hljs-regexp">/var/</span>run/nginx.pid;<br><br>events &#123;<br>    worker_connections  <span class="hljs-number">1024</span>;<br>&#125;<br><br>stream &#123;<br><br>    map <span class="hljs-variable">$server_port</span> <span class="hljs-variable">$tcp_cname</span> &#123;<br>        <span class="hljs-number">80</span> <span class="hljs-string">&quot;www.example.com:8080&quot;</span>;<br>    &#125;<br><br>    server &#123;<br>        resolver <span class="hljs-number">8.8</span>.<span class="hljs-number">8.8</span> valid=<span class="hljs-number">60</span>s;<br>        listen <span class="hljs-number">80</span>;<br>        proxy_pass <span class="hljs-variable">$tcp_cname</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种解决方法真是一点都高兴不起来。这应该是一种能 work 的方案，好像是解决了问题。但在这一系列的 debug 中，最大的问题是 Nginx 在 stream 和 http 两种 module 中有配置不一致的情况，两种看似等效的方式也能得出不同的结果。</p><p>除此以外，当时想着要换成 traefik 的原因是这篇 <a href="https://tenzer.dk/nginx-with-dynamic-upstreams/">文章</a>，里面有提到</p><blockquote><p>One way to solve this problem is to pay for Nginx Plus which adds the resolve flag to the server directive in an upstream group. That will make Nginx honour the TTL of the DNS record and occasionally re-resolve the record in order to get an updated list of servers to use.</p></blockquote><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="http://nginx.org/en/docs/stream/ngx_stream_core_module.html#resolver">http://nginx.org/en/docs/stream/ngx_stream_core_module.html#resolver</a></li><li><a href="http://nginx.org/en/docs/http/ngx_http_core_module.html">http://nginx.org/en/docs/http/ngx_http_core_module.html</a></li><li><a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/userguide/how-elastic-load-balancing-works.html#request-routing">https://docs.aws.amazon.com/elasticloadbalancing/latest/userguide/how-elastic-load-balancing-works.html#request-routing</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>nginx</tag>
      
      <tag>tcp</tag>
      
      <tag>proxy</tag>
      
      <tag>traefik</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jenkins pipeline thinking</title>
    <link href="/2020/06/03/jenkins-pipeline-thinking/"/>
    <url>/2020/06/03/jenkins-pipeline-thinking/</url>
    
    <content type="html"><![CDATA[<p>在 2019 年中至今花了挺多时间在 Jenkins pipeline 的改造，本文旨在描述这个过程中的一些思考和实践。涉及到 Python，Java，前端的项目。</p><h2 id="Version-0-1"><a href="#Version-0-1" class="headerlink" title="Version 0.1"></a>Version 0.1</h2><p>最开始接手项目时，一个项目只有一个 Jenkinsfile。使用 branch 进判断，像 master 分支对应 production 环境，只要有代码提交，则 Jenkins 进行构建，执行 terraform 代码。程序本身通过 docker 来运行，每个 image 的 tag 对应其发布分支的 commit hash id。</p><p>对于 Python library 类的项目，则会区分 master 分支和非 master 分支，如果最新的一个 commit message 中包含一个 <code>[release]</code> 的信息，则会进行构建，并进行 Github Release，区别就是 master 分支构建的版本是正式版本，非 master 的分支构建出来的版本包含 commit hash id 的信息。</p><p>这种 pipeline 的模式好处就是非常简单，如果需要发布新版本只需要在对应的分支提交代码 &#x2F; PR 即可。但后续我们加入了 dev &#x2F; test 的环境，意味着我们需要维护 4 个分支。</p><p>除此以外，因为我们使用 terraform 来进行部署，最终是通过 AWS 的 <a href="https://aws.amazon.com/ecs/">ECS</a> 来运行，所以包括 staging &#x2F; production 环境的资源限制（基于 cloudwatch 的 autoscaling），数据库和 Kafka 的配置等信息都通过代码来控制。我们需要更新这些配置的话，就需要编辑代码，则会引发 docker image 的更新。如果是简单的更改配置的话，也需要走一遍重新构建镜像的过程。</p><p>最重要的问题是，我们没法回滚。因为部署都是基于 branch 的，没有一个版本的概念。发布了之后只能通过 git commit hash id 去找到我们发布时候的那个点，或者切换到想要回滚的那个点，找回那个点对应的镜像。</p><h2 id="Version-0-2"><a href="#Version-0-2" class="headerlink" title="Version 0.2"></a>Version 0.2</h2><p>对于一个项目来说，功能开发完会提 PR，Github 那里会检测这个 PR 的测试的结果，代码质量检测，只有合格了才进行 merge。那么对于同一个阶段的代码来说，一次发布从代码提交到部署的中间必须会执行两次代码测试，image 构建等等。如果这些耗时很长的话，则会导致一次发布拖延甚久。</p><p>如果不同项目之间出现依赖问题，那么一个项目的发布导致的拖延，线上的检查等等则会造成更多的等待。除此以外，因为 branch 是自动构建的，我们也只能等到发布的时候才进行 PR 的 merge。所以 0.2 的版本的首要解决的问题是，构建（image）和发布分离。</p><p>这里我们去掉了原有 Jenkinsfile 中的部署部分的代码，将其移动到了 Jenkinsfile-release 中。通过 <a href="https://stackoverflow.com/questions/47565933/build-pipeline-using-a-branch-parameter">Jenkins Parameterized Build</a> 的形式选择想要发布的 branch，获取到对应的 docker image 的 tag 然后执行相应的 terraform 代码，完成更新。</p><p>这个模式目前只能解决发布和构建耦合在一起的问题。除此以外，这里一个比较严重的问题是，Jenkins 支持下拉框对应的 tag &#x2F; branch，但实际上并不 checkout 到对应的 ref。后来发现应该是 Jenkins Git Plugin 的 <a href="https://issues.jenkins-ci.org/plugins/servlet/mobile#issue/JENKINS-28447">bug</a>。</p><h2 id="Version-0-3"><a href="#Version-0-3" class="headerlink" title="Version 0.3"></a>Version 0.3</h2><p>与上个版本最大的不同是，使用 git tag 来进行发布。保护分支变成两种，master 分支和 release&#x2F;* 分支。前者对应 production &#x2F; staging 的代码，后者对应 dev &#x2F; test 的代码。对于 master 分支和 release&#x2F;* 分支，都会打出 git tag，不同的是，后者会有个 build 的 suffix，用到了 Jenkins 构建时候的环境变量 <code>env.BUILD_NUMBER</code> ，如当前版本是 v1.0.0 则 release 对应的版本是 <code>v1.0.0b&lt;env.BUILD_NUMBER&gt;</code> 直到测试通过合并到 master 分支，则会打出 v1.0.0 不含后缀的 git tag。</p><p>语义化版本之后，通过 Jenkins 的参数化构建，我们就能通过选择发布的 tag 来进行发布。如果我们 build 出来的 docker image 的 tag 也遵循这个规则，我们就能通过这个 git tag 对应上。那么部署要做的事情就简单多了，checkout 出对应的代码，通过 Makefile 获取对应的 image name 等基础信息，组合成需要发布的 docker image，通过这个点上的 terraform 代码进行部署。</p><p>除此以外，如果通过选择 tag 的形式，如果新旧两个版本的代码没有兼容性问题，我们可以简单的通过选择上次稳定版本的代码来进行发布。</p><h2 id="Version-0-4"><a href="#Version-0-4" class="headerlink" title="Version 0.4"></a>Version 0.4</h2><p>直到现在我们还是使用 terraform 来进行发布，好处还是我们能通过代码控制基础设施，包括内部域名，autoscaling 的参数配置等等。但随之而来的就是每次更新配置都需要修改项目的代码。当前最简单的方法就是将 terraform 代码迁移出来通过别的项目来管理，每次需要更新的时候，提 PR 更新想要发布的项目的 image tag 即可，此外，我们也有了一个统一管理不同服务版本的办法。</p><p>最开始公司内部使用的是 k8s 来作部署工具，当时我写了一个简单的 Python 脚本加一个 template 的来渲染出对应 dev &#x2F; test 环境的 k8s deployment.yml，然后复制到 k8s 对应的集群执行 <code>kubectl apply -f deployment.yml</code> 即可。现在逐步改用 <a href="https://kustomize.io/">kustomize</a> 来部署，算是正规化了许多。而且，在 Jenkins slave 中保存了对应 k8s 集群的认证的配置文件，可以直接从 Jenkins slave 中发起 k8s deployment 的更新。</p><p>基于 kustomize 还有一个比较重要的原因它支持 <a href="https://github.com/kubernetes-sigs/kustomize/blob/master/examples/remoteBuild.md#url-format">remote resource</a>。所以我们目前的做法是，在项目中编写 base &#x2F; dev &#x2F; test layer，而去执行部署的程序引用 base layer，能保证我们 production 环境的端口，环境变量等基本配置一一致，而针对具体环境，又能设置具体的如资源限制，configmap，或者 ingress。</p><h2 id="Version-X"><a href="#Version-X" class="headerlink" title="Version X"></a>Version X</h2><p><del>到了 0.4 的阶段，我觉得基本能满足我们的需求了。基本的目的是，项目本身只负责 image build 这一阶段，而后续的 push image 则是由具体的环境的 Jenkins 来进行，如你在 AWS &#x2F; Aliyun 各有一个 docker registry。</del></p><p>后面重新试了下，觉得这种方式过于繁琐，需要维护各种环境的构建环境，后续的想法是有在国内进行 image 的构建，而某个具体环境需要部署时，则将该版本的 docker image 推到对应的 docker registry。</p><p>AWS 上的基础设置还是通过 terraform 来维护，不同的是，只有基础设置，具体服务就由 Jenkins Pipeline 来负责部署。而不同环境 &#x2F; AWS 帐号的差异则通过 kustomize 的不同 layer 来实现。</p><h2 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h2><h3 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h3><p>目前在各个项目中分布着 Pipeline 的两种语法，Goovy 的写法会更灵活，但 Declarative 的写法会更家规范。我们希望将所有的构建的细节都用 Makefile 封装起来，而 pipeline 则仅仅负责调用。对于不同的环境（国内 &#x2F; 国外或者 AWS &#x2F; Aliyun）的配置（如 docker registry）则通过环境变量来引入。</p><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><p>docker 在不同环境中的主要问题是网速，特别是依赖库的更新。这里可以通过 build args 来定制化这些配置，如 pip</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-keyword">ARG</span> PYPI_MIRROR=https://pypi.python.org/simple/<br><span class="hljs-keyword">RUN</span><span class="language-bash"> pip install -i <span class="hljs-variable">$&#123;PYPI_MIRROR&#125;</span> -r config/requirements.txt</span><br></code></pre></td></tr></table></figure><p>npm</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-keyword">ARG</span> NPM_REGISTRY=https://registry.npm.taobao.org<br><span class="hljs-keyword">RUN</span><span class="language-bash"> npm install -g xxx --registry=<span class="hljs-variable">$&#123;NPM_REGISTRY&#125;</span></span><br></code></pre></td></tr></table></figure><p>还有一个问题，必须要区分 build args 和 runtime env variables。前者是无关环境的，一个判别方法是，如果这个 image 换到别的环境去使用，能否仅仅通过 env variables 去配置？常见的就是前端的代码，因为 Nginx 或者 image 中放置的是通过工具编译过的 JavaScript 文件，无法配置环境变量。这里就需要额外添加 entrypoint.sh 和命令 <code>envsubst</code> 来进行改造。</p><h3 id="kustomize"><a href="#kustomize" class="headerlink" title="kustomize"></a>kustomize</h3><p>这里我们还有讨论到一个点，就是 dev &#x2F; test 环境的 configmap 要不要项目本身来维护。如果由自己来维护的话，方便进行开发调试，但另一方面就可能导致有配置和 staging &#x2F; production 不一致出现问题。除此以外，如果 configmap 同名的话，仅仅是更新配置但 deployment 是不会重启 pod 的。</p><h3 id="terraform"><a href="#terraform" class="headerlink" title="terraform"></a>terraform</h3><p>目前项目有用到 0.11 版本的语法的 terraform 0.12 版本的 terraform。目前发现，对于已经用旧语法进行部署的服务，如果用新的版本的 terraform 进行部署，则会报错。在这个过程中，需要维护旧的服务，并且逐渐迁移到新的版本。</p><p>0.12 的语法更加简洁，并且有新加的如 <code>count</code> 和 <code>for_each</code> 等用法可以方便编写相似的资源。除此以外，新版本 terraform 去读取旧语法生成的 state 的内容也是可以的。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://semver.org/">https://semver.org/</a></li><li><a href="https://www.jenkins.io/doc/book/pipeline/syntax/#compare">https://www.jenkins.io/doc/book/pipeline/syntax/#compare</a></li><li><a href="https://mirror.tuna.tsinghua.edu.cn/help/pypi/">https://mirror.tuna.tsinghua.edu.cn/help/pypi/</a></li><li><a href="https://ledermann.dev/blog/2018/04/27/dockerize-and-configure-javascript-single-page-application/">https://ledermann.dev/blog/2018/04/27/dockerize-and-configure-javascript-single-page-application/</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>jenkins</tag>
      
      <tag>pipeline</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang 2019 重新配置</title>
    <link href="/2019/10/11/golang-in-2019/"/>
    <url>/2019/10/11/golang-in-2019/</url>
    
    <content type="html"><![CDATA[<p>好久没写过 Golang 了，上次写还是 <code>GOPATH</code> 的版本。本文以 <code>1.13.1</code> 为例子，再次整理些 Golang 的开发环境</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim">&gt; <span class="hljs-keyword">go</span> <span class="hljs-keyword">version</span><br><span class="hljs-keyword">go</span> <span class="hljs-keyword">version</span> go1.<span class="hljs-number">13.1</span> linux/amd64<br></code></pre></td></tr></table></figure><p>以 <a href="https://github.com/lycheng/gobjection">https://github.com/lycheng/gobjection</a> 项目为例</p><h2 id="Env"><a href="#Env" class="headerlink" title="Env"></a>Env</h2><p>首先是关于 Golang Modules 的环境变量的设置</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">GO111MODULE</span>=auto<br><span class="hljs-built_in">export</span> <span class="hljs-attribute">GOPROXY</span>=https://goproxy.io<br><span class="hljs-comment"># export GOPROXY=http://mirrors.aliyun.com/goproxy/</span><br></code></pre></td></tr></table></figure><p>初始化项目，Golang Modules 出来之后，不需要像以前那样必须跟着 <code>GOPATH</code> 里面 Github 的项目路径走了，可以自由安排路径</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">go</span> <span class="hljs-keyword">mod</span> init github.<span class="hljs-keyword">com</span>/lycheng/gobjection<br></code></pre></td></tr></table></figure><h2 id="Init"><a href="#Init" class="headerlink" title="Init"></a>Init</h2><p>参考 <a href="https://github.com/golang-standards/project-layout">Golang Project Layout</a> 创建了几个目录</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">mkdir</span> <span class="hljs-built_in">cmd</span><br><span class="hljs-built_in">mkdir</span> pkg<br></code></pre></td></tr></table></figure><p>在项目根目录使用 <code>go get</code> 安装依赖的话会保存版本信息到 <code>go.mod</code> 中</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk">&gt; go get -u github.com<span class="hljs-regexp">/sirupsen/</span>logrus<br>&gt; cat go.mod<br>module github.com<span class="hljs-regexp">/lycheng/g</span>objection<br><br>go <span class="hljs-number">1.13</span><br><br>require (<br>        github.com<span class="hljs-regexp">/konsorten/g</span>o-windows-terminal-sequences v1.<span class="hljs-number">0.2</span> <span class="hljs-regexp">//</span> indirect<br>        github.com<span class="hljs-regexp">/sirupsen/</span>logrus v1.<span class="hljs-number">4.2</span> <span class="hljs-regexp">//</span> indirect<br>        golang.org<span class="hljs-regexp">/x/</span>sys v0.<span class="hljs-number">0.0</span>-<span class="hljs-number">20190927073244</span>-c990c680b611 <span class="hljs-regexp">//</span> indirect<br>)<br></code></pre></td></tr></table></figure><h2 id="In-The-End"><a href="#In-The-End" class="headerlink" title="In-The-End"></a>In-The-End</h2><p>几点感受</p><ul><li><code>GOPROXY</code> 试了下感觉还行，解决了以前下载 Github &#x2F; golang.org 等仓库的依赖的痛点</li><li>项目的路径终于不用像之前一样要按规定路径来</li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><p><a href="https://github.com/golang/go/wiki/Modules#recent-changes">Go Modules 1.13 的几个变化</a></p></li><li><p><a href="https://github.com/golang-standards/project-layout">Golang Project Layout</a></p></li><li><p><a href="https://juejin.im/post/5d8ee2db6fb9a04e0b0d9c8b">干货满满的 Go Modules 和 goproxy.cn</a></p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 内存暴涨的问题排查</title>
    <link href="/2019/01/14/python-memory-leak-debug/"/>
    <url>/2019/01/14/python-memory-leak-debug/</url>
    
    <content type="html"><![CDATA[<p>在工作的时候和同事检查一个 Python 程序的问题的时候没有头绪，日志看了下也基本正常。于是在网上搜了下看下别人的思路，发现了 <a href="https://mg.pov.lt/objgraph/">objgraph</a> 这个库。</p><p>抱着试一下的心态安装了试了下，然后发现发问题所在</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs subunit">BindParameter    181236 <span class="hljs-string">+180366</span><br>_anonymous_label 181322 <span class="hljs-string">+180365</span><br>dict             229511 <span class="hljs-string">+180160</span><br>...<br><br></code></pre></td></tr></table></figure><p>上述输出是 <code>objgraph.show_growth()</code> 的输出，该函数会输出类实例的增量的变化。上述输出可以看到三个类型实例变量的增量是同步的，而前两个类型又是 SQLAlchemy 库的类型，于是怀疑是数据库的问题。</p><p>后来追查下去，发现变化在于传入了一个千万级别的 ID 数组，使用该数组作为子查询来查询。</p><p>除此以外其实还有像 <code>objgraph.get_leaking_objects()</code> 这样打印出没有被引用的对象（按其 <a href="https://mg.pov.lt/objgraph/objgraph.html#objgraph.get_leaking_objects">文档说明</a> 有 bug）以及通过图来表示对象的引用关系，用来 debug 真是再合适不过了。</p><p>由于当时 debug 的环境是 Python 2.6 的，现在 Python 3 有内置的库，如 <a href="https://docs.python.org/3/library/tracemalloc.html">tracemalloc</a>，该库在 Python 3.4 开始引入，初步看了下，tracemalloc 可以提供比 gc 库更底层的功能。</p><h2 id="One-More-Thing"><a href="#One-More-Thing" class="headerlink" title="One-More-Thing"></a>One-More-Thing</h2><p>我刚看这个 <code>objgraph.show_growth()</code> 的例子的时候，以为是用了全局变量去存储上次的结果来做 diff，然后看了代码觉得挺巧妙的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">show_growth</span>(<span class="hljs-params">limit=<span class="hljs-number">10</span>, peak_stats=&#123;&#125;, shortnames=<span class="hljs-literal">True</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Show the increase in peak object counts since last call.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Limits the output to ``limit`` largest deltas.  You may set ``limit`` to</span><br><span class="hljs-string">    None to see all of them.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Uses and updates ``peak_stats``, a dictionary from type names to previously</span><br><span class="hljs-string">    seen peak object counts.  Usually you don&#x27;t need to pay attention to this</span><br><span class="hljs-string">    argument.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    The caveats documented in :func:`typestats` apply.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Example:</span><br><span class="hljs-string"></span><br><span class="hljs-string">        &gt;&gt;&gt; show_growth()</span><br><span class="hljs-string">        wrapper_descriptor       970       +14</span><br><span class="hljs-string">        tuple                  12282       +10</span><br><span class="hljs-string">        dict                    1922        +7</span><br><span class="hljs-string">        ...</span><br><span class="hljs-string"></span><br><span class="hljs-string">    .. versionadded:: 1.5</span><br><span class="hljs-string"></span><br><span class="hljs-string">    .. versionchanged:: 1.8</span><br><span class="hljs-string">       New parameter: ``shortnames``.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    gc.collect()<br>    stats = typestats(shortnames=shortnames)<br>    deltas = &#123;&#125;<br>    <span class="hljs-keyword">for</span> name, count <span class="hljs-keyword">in</span> iteritems(stats):<br>        old_count = peak_stats.get(name, <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">if</span> count &gt; old_count:<br>            deltas[name] = count - old_count<br>            peak_stats[name] = count<br>    deltas = <span class="hljs-built_in">sorted</span>(deltas.items(), key=operator.itemgetter(<span class="hljs-number">1</span>),<br>                    reverse=<span class="hljs-literal">True</span>)<br>    <span class="hljs-keyword">if</span> limit:<br>        deltas = deltas[:limit]<br>    <span class="hljs-keyword">if</span> deltas:<br>        width = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">len</span>(name) <span class="hljs-keyword">for</span> name, count <span class="hljs-keyword">in</span> deltas)<br>        <span class="hljs-keyword">for</span> name, delta <span class="hljs-keyword">in</span> deltas:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%-*s%9d %+9d&#x27;</span> % (width, name, stats[name], delta))<br></code></pre></td></tr></table></figure><p>关键在于 <code>peak_stats</code> 这个变量，其默认值为 <code>&#123;&#125;</code>。函数在 Python 中也是一种对象，而函数参数则是对象的属性，声明之后将一直保存在内存中（传入另一个值则像是屏蔽了该变量，而下次再使用默认值还是会是原来的变量）。</p><p>以前遇到过一个 bug，在函数中加入了一个时间值，其默认值设为 <code>datetime.now()</code> 则不传入值的时候，该值永远是程序启动时的时间。</p><p>在这段代码中则使用该默认值来保存当前的对象的分配情况。在当前调用时，存入该次的状态，下次继续调用时，则可以比较两次调用间的 diff 了。不过这种将状态通过一些语言特性隐藏起来了的写法，感觉还是不应该出现在普通的代码中，这样子特殊用途的代码则可以考虑使用。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://mg.pov.lt/blog/hunting-python-memleaks.html">Hunting memory leaks in Python</a></li><li><a href="https://www.cnblogs.com/xybaby/p/7491656.html">使用gc、objgraph干掉python内存泄露与循环引用！</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>memory-leak</tag>
      
      <tag>debug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 kubeadm 初始化 k8s 集群</title>
    <link href="/2018/12/14/k8s-init-with-kubeadm/"/>
    <url>/2018/12/14/k8s-init-with-kubeadm/</url>
    
    <content type="html"><![CDATA[<p>系统环境：CentOS 7.X</p><p>Kubernetes 相关版本：</p><ul><li>kubeadm - v1.13.0</li><li>kubelet - v1.13.0</li><li>kubectl - v1.13.0</li></ul><h2 id="k8s-master-初始化"><a href="#k8s-master-初始化" class="headerlink" title="k8s master 初始化"></a>k8s master 初始化</h2><p>配置仓库，安装 kube 相关依赖</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">&gt; vim <span class="hljs-regexp">/etc/yum</span>.repos.d/kubernetes.repo<br></code></pre></td></tr></table></figure><p>设置 kubernetes 的 aliyun 仓库，CentOS 本身的源只支持到 1.5.X 的版本</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[kubernetes]</span><br><span class="hljs-attr">name</span>=Kubernetes<br><span class="hljs-attr">baseurl</span>=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x<span class="hljs-number">86_64</span><br><span class="hljs-attr">enabled</span>=<span class="hljs-number">1</span><br><span class="hljs-attr">gpgcheck</span>=<span class="hljs-number">0</span><br><span class="hljs-attr">repo_gpgcheck</span>=<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">setenforce <span class="hljs-number">0</span></span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">yum install -y kubelet kubeadm kubectl</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">vim /etc/fstab # 注释最后一行来去掉 swap</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">swapoff -a</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">systemctl enable kubelet &amp;&amp; systemctl start kubelet</span><br></code></pre></td></tr></table></figure><p>指定版本，指定仓库</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">&gt; kubeadm init <span class="hljs-attr">--pod-network-cidr</span>=<span class="hljs-number">10.244</span>.<span class="hljs-number">0.0</span>/<span class="hljs-number">16</span> <span class="hljs-attr">--image-repository</span> registry<span class="hljs-selector-class">.aliyuncs</span>.com/google_containers <span class="hljs-attr">--kubernetes-version</span> v1.<span class="hljs-number">13.0</span><br></code></pre></td></tr></table></figure><p>配置 kubectl 环境，让非 root 用户都能使用 kubectl</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p <span class="hljs-variable">$HOME</span>/.kube<br>sudo <span class="hljs-built_in">cp</span> -i /etc/kubernetes/admin.conf <span class="hljs-variable">$HOME</span>/.kube/config<br>sudo <span class="hljs-built_in">chown</span> $(<span class="hljs-built_in">id</span> -u):$(<span class="hljs-built_in">id</span> -g) <span class="hljs-variable">$HOME</span>/.kube/config<br></code></pre></td></tr></table></figure><p>安装 flannel 网络</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">&gt; docker pull registry.cn-hangzhou.aliyuncs.com<span class="hljs-regexp">/kubernetes_containers/</span>flannel:v0.<span class="hljs-number">10.0</span>-amd64<br>&gt; docker tag registry.cn-hangzhou.aliyuncs.com<span class="hljs-regexp">/kubernetes_containers/</span>flannel:v0.<span class="hljs-number">10.0</span>-amd64 quay.io<span class="hljs-regexp">/coreos/</span>flannel:v0.<span class="hljs-number">10.0</span>-amd64<br>&gt; kubectl apply -f https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/coreos/</span>flannel<span class="hljs-regexp">/master/</span>Documentation/kube-flannel.yml<br></code></pre></td></tr></table></figure><p>安装完之后如果 coredns 有问题，可以修改 coredns deploy 配置之后再进行部署，</p><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">kubectl -n kube-system get deployment coredns -o yaml &gt; coredns.<span class="hljs-property">yaml</span></span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">vim coredns.<span class="hljs-property">yml</span> # <span class="hljs-attr">allowPrivilegeEscalation</span>: <span class="hljs-literal">true</span></span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">kubectl apply -f coredns.<span class="hljs-property">yml</span></span><br></code></pre></td></tr></table></figure><p>相关 issue: <a href="https://github.com/kubernetes/kubeadm/issues/998">https://github.com/kubernetes/kubeadm/issues/998</a></p><p>之后在 master 节点执行下面的命令，应该是所有的服务都是在运行的</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">&gt; kubectl <span class="hljs-built_in">get</span> pods -n kube-<span class="hljs-keyword">system</span><br></code></pre></td></tr></table></figure><p>至此，master 节点的初始化结束</p><h2 id="k8s-node-节点初始化"><a href="#k8s-node-节点初始化" class="headerlink" title="k8s node 节点初始化"></a>k8s node 节点初始化</h2><p>在 master 节点执行命令，获取用于 join 的命令</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">&gt; kubeadm <span class="hljs-built_in">token</span> <span class="hljs-keyword">create</span> --<span class="hljs-keyword">print</span>-join-command<br></code></pre></td></tr></table></figure><p>在 worker 节点上 执行上述命令</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso">&gt; kubeadm <span class="hljs-keyword">join</span> <span class="hljs-params">...</span><br></code></pre></td></tr></table></figure><p>然后在 master 节点执行可见相关结果</p><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">kubectl get pods -n kube-system</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">kubectl get nodes</span><br></code></pre></td></tr></table></figure><p>如果遇到 NotReady 的情况，可尝试先将该节点删掉</p><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">kubectl drain &lt;node name&gt; --<span class="hljs-keyword">delete</span>-local-data --force --ignore-daemonsets</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">kubectl <span class="hljs-keyword">delete</span> node &lt;node name&gt;</span><br></code></pre></td></tr></table></figure><p>然后在 worker 节点</p><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">kubeadm reset</span><br></code></pre></td></tr></table></figure><p>之后再重新 join。目前遇到最多的问题是 cgroups-driver 不一致，目前尝试将 k8s 和 docker 都改成 systemd 即可。可使用下面的命令查看</p><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">systemctl status kubelet</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">docker info | grep -i driver</span><br></code></pre></td></tr></table></figure><p>给节点设置 role</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">&gt; kubectl label <span class="hljs-keyword">node</span> <span class="hljs-title">&lt;node</span> name&gt; <span class="hljs-keyword">node</span><span class="hljs-title">-role</span>.kubernetes.io/<span class="hljs-keyword">node</span><span class="hljs-title">=</span><br></code></pre></td></tr></table></figure><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>1.13 版本的 k8s 使用 kubeadm 安装的话会比之前的体验好很多，但是自己测试下来还是挺多坑的</p><ul><li>网络的问题，新版的 kubeadm 可以支持修改镜像仓库，使用 aliyun 的话还行，但你安装 flannel 的话还是需要手动处理下</li><li>cgroups.driver 问题，这个的话与 k8s 和 docker 都有关系，两边需要统一才行</li></ul><p>总体而言会比之前的体验好点，目前新版的 kubeadm 也到了 GA 阶段了，未来的话希望体验更好点吧。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.cnblogs.com/RainingNight/p/using-kubeadm-to-create-a-cluster-1-13.html">使用 kubeadm 初始化 1.13 版本的 k8s 集群</a></li><li><a href="https://kubernetes.io/blog/2018/12/03/kubernetes-1-13-release-announcement/">k8s 1.13 的 release 博客</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker 容器时区设置</title>
    <link href="/2018/12/11/docker-alpine-image-timezone/"/>
    <url>/2018/12/11/docker-alpine-image-timezone/</url>
    
    <content type="html"><![CDATA[<p>使用 Docker 部署 Java 程序时发现时区有问题，这里记录下这期间折腾的记录。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>基础镜像为 <code>openjdk:8-jre-alpine</code>，复制打包后生成的 jar 文件进去运行程序。</p><p>这个镜像默认的配置如下</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs applescript">$ docker <span class="hljs-built_in">run</span> -<span class="hljs-keyword">it</span> <span class="hljs-comment">--rm openjdk:8-jre-alpine /bin/sh</span><br>/ <span class="hljs-comment"># date</span><br>Tue Dec <span class="hljs-number">11</span> <span class="hljs-number">01</span>:<span class="hljs-number">41</span>:<span class="hljs-number">09</span> UTC <span class="hljs-number">2018</span><br>/ <span class="hljs-comment"># cat /etc/localtime</span><br>TZif2UTCTZif2UTC<br>UTC0<br></code></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>以下是用来测试的 Dockerfile</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> openjdk:<span class="hljs-number">8</span>-jre-alpine<br><br><span class="hljs-comment"># RUN apk add --no-cache tzdata &amp;&amp; cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; echo &quot;Asia/Shanghai&quot; &gt; /etc/timezone</span><br><br><span class="hljs-comment"># ENV TZ Asia/Shanghai</span><br><br><span class="hljs-keyword">COPY</span><span class="language-bash"> ./target/tz-1.0-SNAPSHOT.jar main.jar</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> /usr/bin/java -jar main.jar</span><br></code></pre></td></tr></table></figure><p>测试用的 Java 程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lycheng.tz;<br><br><span class="hljs-keyword">import</span> java.time.Instant;<br><span class="hljs-keyword">import</span> java.util.Date;<br><span class="hljs-keyword">import</span> java.util.TimeZone;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Instant</span> <span class="hljs-variable">instant</span> <span class="hljs-operator">=</span> Instant.now();<br>        System.out.println(instant);<br><br>        <span class="hljs-type">TimeZone</span> <span class="hljs-variable">tz</span> <span class="hljs-operator">=</span> TimeZone.getDefault();<br>        System.out.println(tz.getDisplayName());<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>        System.out.println(date);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述两行注释都是可用的</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">&gt; docker run --rm -it <span class="hljs-constructor">$(<span class="hljs-params">docker</span> <span class="hljs-params">build</span> -<span class="hljs-params">q</span> .)</span><br><br><span class="hljs-number">2018</span>-<span class="hljs-number">12</span>-<span class="hljs-number">11</span>T03:<span class="hljs-number">39</span>:<span class="hljs-number">17.927</span>Z<br>China Standard Time<br>Tue Dec <span class="hljs-number">11</span> <span class="hljs-number">11</span>:<span class="hljs-number">39</span>:<span class="hljs-number">18</span> CST <span class="hljs-number">2018</span><br></code></pre></td></tr></table></figure><p>以上就是 <a href="https://github.com/gliderlabs/docker-alpine/issues/136">alpine issue</a> 中提及的方法，原因是 alpine 这个基础镜像是很精简的，原镜像不包含时区信息，需要额外安装。</p><p>此外，你也可以在代码中设置时区</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">TimeZone.setDefault(TimeZone.getTimeZone(<span class="hljs-string">&quot;Asia/Shanghai&quot;</span>));<br></code></pre></td></tr></table></figure><p>在搜索的时候也发现另外的好玩的方法，就是使用宿主机本身的 &#x2F;etc&#x2F;localtime</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker run -v <span class="hljs-regexp">/etc/</span>localtime:<span class="hljs-regexp">/etc/</span>localtime:ro -v <span class="hljs-regexp">/etc/</span>timezone:<span class="hljs-regexp">/etc/</span>timezone:ro -it --rm openjdk:<span class="hljs-number">8</span>-jre-alpine <span class="hljs-regexp">/bin/</span>sh<br></code></pre></td></tr></table></figure><p>这样子能减少 image 的大小，又不需要另外设置时区信息。而 ubuntu 的镜像除了设置环境变量 TZ 外还需要别的配置才行，详见 <a href="https://stackoverflow.com/questions/40234847/docker-timezone-in-ubuntu-16-04-image">这里</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/gliderlabs/docker-alpine/issues/136">alpine issue</a></li><li><a href="https://stackoverflow.com/questions/40234847/docker-timezone-in-ubuntu-16-04-image">docker-timezone-in-ubuntu-16-04-image</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>java</tag>
      
      <tag>timezone</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s 简介</title>
    <link href="/2018/12/01/k8s-introduction/"/>
    <url>/2018/12/01/k8s-introduction/</url>
    
    <content type="html"><![CDATA[<p>本文简单介绍下 k8s 的常用组件，知道其能为我们带来什么样的功能。</p><h2 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h2><h3 id="Cluster"><a href="#Cluster" class="headerlink" title="Cluster"></a>Cluster</h3><p>包含 Master 节点和众多的 Node 节点</p><h3 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h3><p>管理集群的节点，其上包含下列服务</p><p>kube-apiserver</p><ul><li>CLI 或者 UI</li></ul><p>kube-scheduler</p><ul><li>决定 Pod 放哪个 Node</li></ul><p>kube-controller-manager</p><ul><li>资源管理</li></ul><p>Node Controller</p><ul><li>Node go down 的时候进行处理</li></ul><p>Replication Controller</p><ul><li>保证 Pod 的数量是正确的</li></ul><p>Endpoints Controller</p><ul><li>连接 Service 和 Pods</li></ul><p>Service Account &amp; Token Controllers</p><ul><li>维护账号和用于 API 的 access token</li></ul><p>cloud-controller-manageretcd</p><ul><li>数据存储</li><li>alpha feature</li><li>与云服务商的服务打交道</li></ul><p>Pod 网络</p><ul><li>IP-per-Pod，每个 Pod 都拥有一个独立 IP 地址，Pod 内所有容器共享一个网络命名空间</li><li>集群内所有 Pod 都在一个直接连通的扁平网络中，可通过 IP 直接访问</li><li>所有容器之间无需 NAT 就可以直接互相访问</li><li>所有 Node 和所有容器之间无需 NAT 就可以直接互相访问</li><li>容器自己看到的 IP 跟其他容器看到的一样</li><li>Master 节点的 etcd 服务存放着各个 Node 的网络信息</li></ul><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>集群中的节点，提供服务的节点，包含一个或多个 Pod</p><p>包含以下服务</p><ul><li>kubelet - 与 Master 通信</li><li>kube-proxy - 转发请求到 Pod</li><li>Pod 网络</li></ul><h3 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h3><ul><li>为物理的 cluster 提供虚拟 cluster 的隔离</li><li>如 test, production</li></ul><h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><ul><li>最小工作单位</li><li>同一个 Pod 中共享网络 namespace，即 localhost 可见各个容器的 port</li><li>一般是一个 image 一个 Pod</li></ul><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><ul><li>用于控制 Pod 部署特性，如副本数量，部署的 Node</li><li>常见的 Controller<ul><li>Deployment</li><li>ReplicaSet - 供 Deployment 使用，管理 Pod 多个副本</li><li>DaemonSet - 每个 Node 最多一个 Pod，如 k8s 本身的管理进程</li><li>StatefulSet - 保持部署的名称不变</li><li>Job - Crontab</li></ul></li></ul><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>为 Pod 提供负载均衡。一般来说，部署一个服务包含多个 Pod，而 Service 则是在其之上，他们间的关系如下</p><p>request -&gt; Service (-&gt; Deployment) -&gt; ReplicaSet -&gt; Pod</p><p>Service 是整合 Pod 的资源，作为其 LoadBalance，简单的例子如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">my-service</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>      <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br>      <span class="hljs-attr">targetPort:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><p>上述 yml 则是将 Service 的 8080 端口映射到 app&#x3D;nginx 的 Pod 中。因为 Pod 启动时是使用随机的 IP 的，这样子我们就可以通过指定 label 来选择相应的 Pod 了。</p><p>默认情况下，Service 的类型是 ClusterIP，即仅提供集群内部的服务，需要对外提供服务，则需要另外配置(spec.type 中定义)，即 NodePort 和 LoadBalancer 两种。</p><p>当配置为 NodePort 之后，集群的所有节点都监听一个 30000 以上的随机端口，将其收到的请求转发到 Service 中。此时，你就可以简单的在对应的机器上通过这个端口访问集群内部的 Service。</p><p>而 LoadBalancer 目前看则是像与云厂商相关的配置，根据具体厂商自己的负载均衡服务来调用我们定义的 Service。</p><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>Pod 定义的服务可以通过 IP 和 Port 进行请求，而请求指定的 Service 则是通过 k8s 本身的 DNS 服务进行域名解析。</p><p>如一个 Service 名为 serv，其在 test 这个 namespace 下，则其在集群内可以通过 serv.test 来进行访问。而同一个 namespace 下则仅需要 serv 来进行请求。</p><h3 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h3><p>需要注意的 Ingress 目前还是 beta 的阶段，谨慎使用。</p><p>之前提及的 NodePort 也可以提供对外的服务，但是它是服务在 TCP 层上的，意味着其不能根据 path 或者 header 进行转发，而 Ingress 是工作在 HTTP 层。</p><p>request(not in cluster) -&gt; Ingress -&gt; Service (-&gt; Deployment) -&gt; ReplicaSet -&gt; Pod</p><p>Ingress 的使用需要两部分，Controller 和 Ingress。后者描述规则，前者实现规则。这里跟之前提及的 spec 和 status 概念有点类似。Controller 则是很多常见的做 proxy 的软件，如</p><ul><li>Nginx</li><li>Kong</li><li>HAProxy</li><li>…</li></ul><p>这里可以看一下简单的定义</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">extensions/v1beta1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Ingress</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">test-ingress</span><br>  <span class="hljs-attr">annotations:</span><br>    <span class="hljs-attr">nginx.ingress.kubernetes.io/rewrite-target:</span> <span class="hljs-string">/</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">http:</span><br>      <span class="hljs-attr">paths:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">/testpath</span><br>        <span class="hljs-attr">backend:</span><br>          <span class="hljs-attr">serviceName:</span> <span class="hljs-string">test</span><br>          <span class="hljs-attr">servicePort:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><p>Ingress 使用 annotation 来配置信息。而 spec 的信息一般包含以下内容</p><ul><li>可选的 host</li><li>一个或多个 path</li><li>host 和 path 所对应的 host</li></ul><p>就目前的信息而言，Controller 这块像一个单独部署的 Nginx Pod，然后监听相关 spec 的更新，然后修改自身的 config 去满足需求。</p><h2 id="In-detail"><a href="#In-detail" class="headerlink" title="In-detail"></a>In-detail</h2><h3 id="kubectl"><a href="#kubectl" class="headerlink" title="kubectl"></a>kubectl</h3><p>kubectl 用于管理 k8s 上的各种资源，常见的就是 kind&#x3D;Deployment 用于部署服务。其一般用法如下</p><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">kubectl apply -f xx.<span class="hljs-property">yml</span></span><br></code></pre></td></tr></table></figure><p>这里使用 yml 进行资源描述，而通过更新相应的 yml 文件，再次执行命令是则更新资源。实际上 k8s 是通过 REST API 对外提供服务，这里的 yml 则是实际上转化成 JSON 的格式发给 k8s Master 节点。</p><p>对于资源包含三部分信息</p><ul><li>ResourceSpec: 用户定义的理想状态</li><li>ResourceStatus: 当前执行的实际状态</li><li>Resource ObjectMeta: meta 信息，name, API Version, label 或者 annotation 等等，用户和 k8s 都能对其进行更新</li></ul><p>而我们定义的是 ResourceSpec 和 Resource ObjectMeta，而 k8s 尽量帮我们满足需求，其实际在系统中表示则是 ResourceStatus。</p><h3 id="Pod-1"><a href="#Pod-1" class="headerlink" title="Pod"></a>Pod</h3><p>容器只能在 Pod 中创建，这中间包含 Controllers: Deployment, Job, StatefulSet</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">rss-site</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">front-end</span><br>      <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>      <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><p>此时新建的 Pod 则会由 k8s 随机分配一个 IP，无法控制，所以一般不会单独使用 Pod。</p><p>上述就是最简单的定义，一个 Pod 中包含一个 Nginx 容器，加一个 label app&#x3D;nginx。Pod 可设置相应的检查，检查服务或者容器的状态。</p><ul><li>livenessProbe: 检查容器是否在运行，失败时会触发相应的 restartPolicy</li><li>readinessProbe: 检查容器能否服务，检查结果为 Success 时才相应地为 Service 服务</li></ul><p>这里对于 WEB&#x2F;HTTP 服务，我们需要每个开发通用的 API，如 HTTP GET ping &#x2F; pong 来表示统一的容器就绪状态。</p><p>这里有一种 initContainers 的配置用于容器启动时的前置条件。可用于执行诸如 Pod 注册的功能，其用法是启动一个新的容器，执行相应的命令。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">myapp-pod</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">myapp</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">myapp-container</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span><br>    <span class="hljs-attr">command:</span> [<span class="hljs-string">&#x27;sh&#x27;</span>, <span class="hljs-string">&#x27;-c&#x27;</span>, <span class="hljs-string">&#x27;echo The app is running! &amp;&amp; sleep 3600&#x27;</span>]<br>  <span class="hljs-attr">initContainers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">init-myservice</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span><br>    <span class="hljs-attr">command:</span> [<span class="hljs-string">&#x27;sh&#x27;</span>, <span class="hljs-string">&#x27;-c&#x27;</span>, <span class="hljs-string">&#x27;until nslookup myservice; do echo waiting for myservice; sleep 2; done;&#x27;</span>]<br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">init-mydb</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span><br>    <span class="hljs-attr">command:</span> [<span class="hljs-string">&#x27;sh&#x27;</span>, <span class="hljs-string">&#x27;-c&#x27;</span>, <span class="hljs-string">&#x27;until nslookup mydb; do echo waiting for mydb; sleep 2; done;&#x27;</span>]<br></code></pre></td></tr></table></figure><p>除此以外，还有一种用于注入依赖的，如 volume，环境变量</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">settings.k8s.io/v1alpha1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">PodPreset</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">allow-database</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">role:</span> <span class="hljs-string">frontend</span><br>  <span class="hljs-attr">env:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">DB_PORT</span><br>      <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;6379&quot;</span><br>  <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/cache</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">cache-volume</span><br>  <span class="hljs-attr">volumes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">cache-volume</span><br>      <span class="hljs-attr">emptyDir:</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>而别的容器使用的时候只需要符合对应的 label role&#x3D;frontend 即可</p><p>需要注意的是，通过 API 去创建 Pod 之后，再去修改配置文件也不会对已有的 Pod 造成影响</p><blockquote><p>Subsequent changes to the template or even switching to a new template has no direct effect on the pods already created. Similarly, pods created by a replication controller may subsequently be updated directly.</p></blockquote><p>所以，也不推荐单独使用 Pod 这种资源，服务的管理应该使用更高层级的 Deployment 或者 StatefulSet 等等。</p><h3 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h3><p>Deployment 包含几种功能</p><ul><li>使用 ReplicaSet 去上线 Pod，并根据预设条件判断是否成功</li><li>更新 template 中 Pod 的状态，新的 ReplicaSet 会创建并转移旧的</li><li>回滚到旧的 Deployment 版本</li><li>通过设置副本数量扩容 &#x2F; 减容</li></ul><p>这里关注几个常见的场景</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 根据配置创建 Deployment</span><br>kubectl create -f app.yaml<br><br><span class="hljs-comment"># 查看 Deployment 信息</span><br>kubectl get deployments.<br><br><span class="hljs-comment"># 查看指定 Deployment 的更新状态</span><br>kubectl rollout status deployment.v1.apps/nginx-deployment<br><br><span class="hljs-comment"># 更新指定 Deployment 的镜像版本</span><br><span class="hljs-comment"># 后面 --record 选项需要添加，这样就可以在错误的升级之后回滚</span><br>kubectl <span class="hljs-built_in">set</span> image deployment.v1.apps/nginx-deployment nginx=nginx:1.9.1 --record<br><br><span class="hljs-comment"># 查看 rollout 信息</span><br>kubectl rollout <span class="hljs-built_in">history</span> deployment.v1.apps/nginx-deployment<br><br><span class="hljs-comment"># 查看指定版本的 rollout 信息，版本信息可以在上面的命令获取</span><br>kubectl rollout <span class="hljs-built_in">history</span> deployment.v1.apps/nginx-deployment --revision=2<br><br><span class="hljs-comment"># 回滚到上一个版本</span><br>kubectl rollout undo deployment.v1.apps/nginx-deployment<br><br><span class="hljs-comment"># 回滚到指定版本</span><br>kubectl rollout undo deployment.v1.apps/nginx-deployment --to-revision=2<br><br><span class="hljs-comment"># 手动扩容</span><br>kubectl scale deployment.v1.apps/nginx-deployment --replicas=10<br><br><span class="hljs-comment"># 根据条件自动扩容</span><br>kubectl autoscale deployment.v1.apps/nginx-deployment --min=10 --max=15 --cpu-percent=80<br><br><span class="hljs-comment"># rolling update，作用于 Pods 和 ReplicationControllers，还是推荐使用 Deployment</span><br>kubectl rolling-update frontend-v1 frontend-v2 --image=image:v2<br></code></pre></td></tr></table></figure><p>需要注意的是，Label selector 并不推荐更新，需要在部署的时候就提前规划好 label 的使用</p><blockquote><p>It is generally discouraged to make label selector updates and it is suggested to plan your selectors up front. In any case, if you need to perform a label selector update, exercise great caution and make sure you have grasped all of the implications.</p></blockquote><h4 id="ReplicaSet"><a href="#ReplicaSet" class="headerlink" title="ReplicaSet"></a>ReplicaSet</h4><p>docs: <a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/">https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/</a></p><p>ReplicaSet 是下一代的 Replication Controller，加多了 selector 的支持。官方更推荐使用 Deployment 来管理多个副本，而不用自己维护一个 ReplicaSet</p><blockquote><p> If you want the rolling update functionality please consider using Deployments instead.</p></blockquote><p>除了 rolling update 这个功能以外，看这个 <a href="https://segmentfault.com/a/1190000016060606">文章</a> 似乎 ReplicaSet &#x2F; Deployment 会影响到单独创建的符合条件的 Pod.</p><h4 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h4><p>除了最简单的 Deployment 以外，还包含其它资源类型：StatefulSet, DaemonSet, Job</p><blockquote><p>Note: StatefulSets are stable (GA) in 1.9.</p></blockquote><p>与 Deployment 不同，StatefulSet 用于部署有状态（磁盘）的应用。有着更为严格的扩容，更新机制，详见 <a href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/">文档</a>。</p><blockquote><p>A DaemonSet ensures that all (or some) Nodes run a copy of a Pod.</p></blockquote><p>DaemonSet 用于部署如日志收集，监控系统等服务。</p><p>Job 为分布式的 Crontab，可以指定 Pod 去执行任务。</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>本文简介了 k8s 一些常用服务及其相关关系，而其底层实现（如其实现转发的 iptables 规则等等）则暂未涉及。</p><p>这里我们可以知道，k8s 本身仅仅做服务或者说 Pod 的管理，如果需要精确到流量（如 X% 的流量走这个版本，Y% 的流量走第二个版本）在 k8s 中则需要配置相应的 replicas 数量来实现。</p><p>而 Istio 或其它 ServiceMesh 插件或框架则提供了这类功能。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.cnblogs.com/CloudMan6/p/8294766.html">5 分钟玩转 Docker 容器系列文章</a></li><li><a href="https://www.cncf.io/wp-content/uploads/2018/03/CNCF-Presentation-Template-K8s-Deployment.pdf">k8s Deployment 生动的介绍</a></li><li><a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.10/#-strong-api-overview-strong-">k8s API 文档</a></li><li><a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/">Pod 配置 Probe</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
      <tag>container</tag>
      
      <tag>microservice</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python mock 的使用</title>
    <link href="/2018/10/31/use-python-mock/"/>
    <url>/2018/10/31/use-python-mock/</url>
    
    <content type="html"><![CDATA[<p>以 ubuntu 18.04 上的 Python 3.6 为测试环境，Python 3.3 以前是需要额外安装 mock 库，现在是内置的标准库。</p><h2 id="Base"><a href="#Base" class="headerlink" title="Base"></a>Base</h2><p>mock 属于 unittest 的一部分，一般用于单元测试时去模拟调用外部系统的函数，类，如网络请求，操作系统的实时数据等等。下面是一个简单的例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():<br>    req = requests.get(<span class="hljs-string">&quot;http://www.baidu.com&quot;</span>)<br>    <span class="hljs-keyword">return</span> req.content<br></code></pre></td></tr></table></figure><p>现在需要对上述代码进行测试，或者对依赖该模块的代码进行测试，需要对其网络请求进行模拟。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> unittest <span class="hljs-keyword">import</span> mock<br><br><span class="hljs-keyword">import</span> requests<br><br><span class="hljs-keyword">from</span> core <span class="hljs-keyword">import</span> func<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mock_requests_get</span>(<span class="hljs-params">s</span>):<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Response</span>:<br>        content = <span class="hljs-string">&quot;mock_requests_get&quot;</span><br><br>    <span class="hljs-keyword">return</span> Response()<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MockResponse</span>:<br>    content = <span class="hljs-string">&quot;mock_response&quot;</span><br><br><br><span class="hljs-meta">@mock.patch(<span class="hljs-params"><span class="hljs-string">&#x27;requests.get&#x27;</span>, mock_requests_get</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mock_requests_with_decorator</span>():<br>    <span class="hljs-built_in">print</span>(func())<br><br><br><span class="hljs-meta">@mock.patch(<span class="hljs-params"><span class="hljs-string">&#x27;requests.get&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mock_requests_with_decorator_and_args</span>(<span class="hljs-params">mock_get</span>):<br>    <span class="hljs-keyword">assert</span> mock_get == requests.get<br>    <span class="hljs-built_in">print</span>(func()) <span class="hljs-comment"># &lt;MagicMock name=&#x27;get().content&#x27; id=&#x27;140081676909704&#x27;&gt;</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br><br>    <span class="hljs-comment"># 1</span><br>    <span class="hljs-keyword">with</span> mock.patch(<span class="hljs-string">&#x27;requests.get&#x27;</span>, mock_requests_get):<br>        <span class="hljs-built_in">print</span>(func())<br><br>    <span class="hljs-comment"># 2</span><br>    mock_requests_with_decorator()<br><br>    <span class="hljs-comment"># 3</span><br>    mock_requests_with_decorator_and_args()<br><br>    <span class="hljs-comment"># 4</span><br>    mock_get = mock.Mock(return_value=MockResponse())<br>    requests.get = mock_get<br>    <span class="hljs-built_in">print</span>(func())<br></code></pre></td></tr></table></figure><p>上述示例中的 1, 2 两种写法个人比较推崇，因为只会在使用到的时候才会去修改对应的代码。</p><p>除此以外还有挺多有意思的用法，如 <code>side_effect</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> unittest <span class="hljs-keyword">import</span> mock<br><br>mock = mock.Mock()<br><br>mock.side_effect = <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">11</span>):<br>    <span class="hljs-built_in">print</span>(mock()) <span class="hljs-comment"># 1, 2, 3, ..., 9</span><br><span class="hljs-comment"># raise exception when i == 10</span><br><br>mock = mock.Mock()<br>mock.side_effect = KeyError(<span class="hljs-string">&#x27;foo&#x27;</span>)<br>mock()<br><span class="hljs-comment"># KeyError: &#x27;foo&#x27;</span><br></code></pre></td></tr></table></figure><p>与固定的 <code>return_value</code> 不同，<code>side_effect</code> 可以是一个可迭代对象，也可以是一个异常，相比于前者能更简单的模拟更多的情况。</p><h2 id="Mock"><a href="#Mock" class="headerlink" title="Mock"></a>Mock</h2><p>在最开始的代码中 <code>mock_requests_with_decorator_and_args</code> 用到了 Mock 类，但实际上没有指定具体的实现，却不妨碍代码继续执行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> unittest <span class="hljs-keyword">import</span> mock<br><br>mock = mock.Mock()<br><br><span class="hljs-built_in">print</span>(mock)<br><span class="hljs-built_in">print</span>(mock.b) <span class="hljs-comment"># &lt;Mock name=&#x27;mock.b&#x27; id=&#x27;140415940033728&#x27;&gt;</span><br><span class="hljs-built_in">print</span>(mock.b.assert_called) <span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure><p>Mock 是一个非常灵活的类，除了一些 magic method 和一些属性（见 <a href="https://docs.python.org/3/library/unittest.mock.html#id3">这里</a> 的解释，解析器会对这些属性和方法的调用有额外的优化，不一定遵循规则）以外，调用一般的方法和属性都会自动生成一个出来。</p><p>查看代码 <code>/usr/lib/python3.6/unittest/mock.py</code> 可以看到，Mock 类是重写了 <code>__getattr__</code>，<code>__setattr__</code> 还有 <code>__call__</code> 一类 magic method 并且记录了调用次数，返回预定义的返回值 <code>return_value</code> 等等，可用于监控是否进行了调用。</p><h2 id="Patch"><a href="#Patch" class="headerlink" title="Patch"></a>Patch</h2><p>Patch 则是使用 Python 的上下文管理（Context Manager）的用法，重写了 <code>__enter__</code> 和 <code>__exit__</code>。同样在 <code>mock.py</code> 同一个代码文件中，可以参考下具体的写法。简单来说就是 <code>__enter__</code> 保存原有的 import，在 <code>__exit__</code> 的时候去掉 mock 的代码，将原有的 import 重新设置。</p><p>这里面涉及到很多的 <code>__getattr__</code>，<code>__setattr__</code> 和 <code>__import__</code> 的用法，有兴趣的话可以详细看下。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol><li><a href="https://docs.python.org/3/library/unittest.mock.html#quick-guide">https://docs.python.org/3/library/unittest.mock.html#quick-guide</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>mock</tag>
      
      <tag>unittest</tag>
      
      <tag>patch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python metaclass 的使用</title>
    <link href="/2018/09/15/use-python-metaclass/"/>
    <url>/2018/09/15/use-python-metaclass/</url>
    
    <content type="html"><![CDATA[<p>之前有个需求，需要去监控某些类的所有的函数调用的耗时，当时团队里面最开始的方案是通过继承某个基类来实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> functools<br><span class="hljs-keyword">import</span> types<br><span class="hljs-keyword">import</span> inspect<br><span class="hljs-keyword">import</span> time<br><br>WRAPPER_ASSIGNMENTS = (<span class="hljs-string">&#x27;__module__&#x27;</span>, <span class="hljs-string">&#x27;__name__&#x27;</span>, <span class="hljs-string">&#x27;__doc__&#x27;</span>, <span class="hljs-string">&#x27;__self__&#x27;</span>)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Timer</span>(<span class="hljs-title class_ inherited__">object</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, key</span>):<br>        self.key = key<br>        self.ts = time.time()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__enter__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__exit__</span>(<span class="hljs-params">self, *args</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;---- &#123;&#125; consumes: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(self.key, time.time() - self.ts))<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MonitorBase</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    base interceptor for performance monitor system.</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattribute__</span>(<span class="hljs-params">self, attrname</span>):<br><br>        <span class="hljs-comment"># 防止死循环</span><br>        <span class="hljs-comment"># https://stackoverflow.com/questions/13538324/python-avoiding-infinite-loops-in-getattribute</span><br>        attrvalue = <span class="hljs-built_in">super</span>(MonitorBase, self).__getattribute__(attrname)<br><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> inspect.ismethod(attrvalue):<br>            <span class="hljs-keyword">return</span> attrvalue<br><br><span class="hljs-meta">        @functools.wraps(<span class="hljs-params">attrvalue, WRAPPER_ASSIGNMENTS</span>)</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">warpFunc</span>(<span class="hljs-params">_self, *args, **kwargs</span>):<br><br>            raise_ex = <span class="hljs-literal">None</span><br>            key = <span class="hljs-string">&quot;&#123;&#125;.&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(self.__class__.__name__, attrname)<br>            <span class="hljs-keyword">with</span> Timer(key):<br>                result = <span class="hljs-literal">None</span><br>                <span class="hljs-keyword">try</span>:<br>                    result = attrvalue(*args, **kwargs)<br>                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> ex:<br>                    raise_ex = ex<br><br>            <span class="hljs-keyword">if</span> raise_ex <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">raise</span> raise_ex<br>            <span class="hljs-keyword">return</span> result<br><br>        <span class="hljs-comment"># https://stackoverflow.com/questions/37455426/advantages-of-using-methodtype-in-python</span><br>        bound_method = types.MethodType(warpFunc, self, <span class="hljs-built_in">type</span>(self))<br>        <span class="hljs-keyword">return</span> bound_method<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-title class_ inherited__">MonitorBase</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">work</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;exec work&quot;</span>)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WorkerChild</span>(<span class="hljs-title class_ inherited__">Worker</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">work</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;exec work&quot;</span>)<br><br><br>w = Worker()<br>w.work()<br><br>wc = WorkerChild()<br>wc.work()<br></code></pre></td></tr></table></figure><p>这是团队里面一个人写的初始版本，十分的清晰易懂，通过改写 <code>___getattribute__</code> 方法，只对方法调用进行监控，对异常和返回值都原样处理。唯一的不同就是调用方法时使用 Timer 进行耗时计算。</p><p>这样子的写法的好处是，只要是基类继承了该监控类，后续的子类也会有相同的效果，但这里也衍生出另外的问题</p><ul><li>因为 <code>__getattribute__</code> 是实例方法，对类中的 staticmethod 和 classmethod 方法没有效果</li><li>每次调用都会重新把方法重新绑定到 self 中</li></ul><p>后续的讨论中主要是担心第二点会带来性能损耗。哪怕你对某些函数设置了标记位从而不去进行监控，因为你重写了这个 <code>__getattribute__</code> 方法，在实际使用上还是得去重新绑定到 self 上去。</p><h2 id="metaclass"><a href="#metaclass" class="headerlink" title="metaclass"></a>metaclass</h2><p>后面有人提出了元类的改进方案，具体代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> functools<br><span class="hljs-keyword">import</span> inspect<br><span class="hljs-keyword">import</span> time<br><br>TIMED_METHOD_FLAG = <span class="hljs-string">&quot;__is_timed_method__&quot;</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Timer</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, key</span>):<br>        self.key = key<br>        self.ts = time.time()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__enter__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__exit__</span>(<span class="hljs-params">self, exc_ty, exc_val, tb</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;---- &#123;&#125; consumes: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(self.key, time.time() - self.ts))<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">timed_wrapper</span>(<span class="hljs-params">f, stats_key</span>):<br><span class="hljs-meta">    @functools.wraps(<span class="hljs-params">f</span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>        <span class="hljs-keyword">with</span> Timer(stats_key):<br>            <span class="hljs-keyword">return</span> f(*args, **kwargs)<br>    <span class="hljs-keyword">return</span> wrapper<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MonitorMeta</span>(<span class="hljs-title class_ inherited__">type</span>):<br><br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">not_timed</span>(<span class="hljs-params">f</span>):<br>        <span class="hljs-built_in">setattr</span>(f, TIMED_METHOD_FLAG, <span class="hljs-literal">False</span>)<br>        <span class="hljs-keyword">return</span> f<br><br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">is_timed_method</span>(<span class="hljs-params">f</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">getattr</span>(f, TIMED_METHOD_FLAG, <span class="hljs-literal">True</span>)<br><br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">need_to_timed</span>(<span class="hljs-params">fname, f</span>):<br>        <span class="hljs-comment"># staticmethod or classmethod returns False</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> inspect.isfunction(f):<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> MonitorMeta.is_timed_method(f):<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>        <span class="hljs-comment"># is magic method</span><br>        <span class="hljs-keyword">if</span> fname.startswith(<span class="hljs-string">&quot;__&quot;</span>) <span class="hljs-keyword">and</span> fname.endswith(<span class="hljs-string">&quot;__&quot;</span>):<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, clsname, bases, attrs</span>):<br>        <span class="hljs-built_in">super</span>(MonitorMeta, self).__init__(clsname, bases, attrs)<br>        <span class="hljs-keyword">for</span> attrname, attrvalue <span class="hljs-keyword">in</span> attrs.items():<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> MonitorMeta.need_to_timed(attrname, attrvalue):<br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-built_in">setattr</span>(self, attrname, timed_wrapper(attrvalue, <span class="hljs-string">&quot;.&quot;</span>.join((clsname, attrname))))<br><br><br><span class="hljs-comment"># class C(metaclass=MonitorMeta): # work at &gt;=python3.5</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>(<span class="hljs-title class_ inherited__">object</span>):<br><br>    __metaclass__ = MonitorMeta<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">haha</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;hah&quot;</span>)<br><br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hehe</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;asdads&quot;</span>)<br><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">heihei</span>(<span class="hljs-params">cls</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;asdads&quot;</span>)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span>(<span class="hljs-title class_ inherited__">C</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, hi</span>):<br>        self.hi = hi<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">show</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello world&quot;</span>)<br><br><span class="hljs-meta">    @MonitorMeta.not_timed</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">work</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;work&quot;</span>)<br><br><br>d = D(<span class="hljs-number">123</span>)<br>d.haha()<br>d.show()<br>d.work()<br></code></pre></td></tr></table></figure><p>这里涉及的改进是</p><ol><li>通过装饰器去设置标记位 <code>TIMED_METHOD_FLAG</code>，标记某些方法不进行收集，默认情况下除去一些 magic method 都进行收集</li><li>可以感知到 staticmethod 和 classmethod，但需要进一步的判断方法</li><li>只有需要收集的方法会有额外的操作，别的方法没有额外的操作</li></ol><p>但使用元类又有一个比较纠结的问题，在上述的例子中，C 使用了元类，D 继承 C，如果通过 D 的实例调用方法 <code>hah</code> 则实际上记录到的是 <code>C.hah</code>。</p><p>这里，我们希望知道的是具体的类对象的调用的时延，使用元类（之前的继承的方法没有这个问题）的话，可能会有一些这样造成困惑的数据。</p><h2 id="conclusion"><a href="#conclusion" class="headerlink" title="conclusion"></a>conclusion</h2><p>这是我第一次涉及到 Python 的元类相关的具体应用，最开始理解起来觉得比较绕，但实际上你记住 Python 里面一切皆对象就很容易理解了，类其实也是一种对象，我们可以通过元类去产生具体的类，由具体的类再产生对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">MyClass = MetaClass()<br>my_object = MyClass()<br></code></pre></td></tr></table></figure><p>后续参考中的答案写得非常清晰，强烈推荐阅读。</p><h2 id="references"><a href="#references" class="headerlink" title="references"></a>references</h2><ol><li><a href="https://stackoverflow.com/questions/100003/what-are-metaclasses-in-python">https://stackoverflow.com/questions/100003/what-are-metaclasses-in-python</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>metaclass</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 学习记录 03</title>
    <link href="/2018/08/27/get-started-in-java-03/"/>
    <url>/2018/08/27/get-started-in-java-03/</url>
    
    <content type="html"><![CDATA[<p>环境：Java8, Idea 社区版，ubuntu 18.04 LTS</p><p>背景：基本没有 Java 实战经验，有 Python 和 Golang 的经验</p><p>前篇</p><ul><li>学习记录 <a href="/2018/07/13/get-started-in-java-01/">01</a></li><li>学习记录 <a href="/2018/07/27/get-started-in-java-02/">02</a></li></ul><h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><h3 id="Thread-Object"><a href="#Thread-Object" class="headerlink" title="Thread-Object"></a>Thread-Object</h3><p>如果需要初始化一个 Thread 对象，则有两种办法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello from a thread!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> &#123;<br>        (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HelloRunnable</span>())).start();<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello from a thread!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> &#123;<br>        (<span class="hljs-keyword">new</span> <span class="hljs-title class_">HelloThread</span>()).start();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>上述两种方法在这里是等价的，run 方法实现具体的线程的功能，通过 start 方法去启动线程。具体的选择看具体的要求，一个是实现接口，一个是继承，推荐使用前者。</p><h3 id="Thread-Management"><a href="#Thread-Management" class="headerlink" title="Thread-Management"></a>Thread-Management</h3><p>你看 Thread 相关实现会发现，一些用于暂停，关闭线程的方法都被废弃了。像 Thread.stop 方法，会直接关掉线程，导致没办法去执行一些资源释放的操作，容易造成不一致的情况。所以最好的情况是通知线程，让线程自己处理。</p><p>相关方法为</p><ul><li>public void Thread.interrupt()</li><li>public boolean isInterrupted()</li><li>public static boolean interrupted()</li></ul><p><code>isInterrupted</code> 方法和 <code>interrupted</code> 方法实际上有些不同</p><ul><li><code>isInterrupted</code> 方法仅仅检查是否处于中断状态</li><li><code>interrupted</code> 方法读取中断状态并清除，即设为 false</li></ul><p><code>interrupted</code> 方法可以理解为，当前的请求中断的需求已经知悉，而是否进行处理则是当前线程的责任了。<code>interrupt</code> 方法做的仅仅是将线程内的标志位设为 true。</p><p>除此以外，如果线程正在处于阻塞状态（Thread.sleep, join …）时，则会抛出 <code>InterruptedException</code> 异常，这个异常需要注意下</p><ul><li>当抛出异常，调用 <code>isInterrupted</code> 方法，此时处于 false 状态</li><li>如果捕获该异常，则应重置该状态，即 <code>Thread.currentThread().interrupt()</code></li></ul><p>可见示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>() &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                System.out.println(Thread.currentThread().isInterrupted()); <span class="hljs-comment">// false</span><br>            &#125;<br>        &#125;<br>    &#125;;<br>    t.start();<br>    t.interrupt();<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Synchronization"><a href="#Synchronization" class="headerlink" title="Synchronization"></a>Synchronization</h2><h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><ul><li>Thread.start 方法调用前的代码 happens-before 线程的创建，相应的修改对新线程可见</li><li>一个线程结束后，则会导致 Thread.join 返回，所有该线程结束前的代码 happens-before join 方法调用，该线程的操作对调用 join 的线程可见</li></ul><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>synchronized methods</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedCounter</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>        c++;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decrement</span><span class="hljs-params">()</span> &#123;<br>        c--;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">int</span> <span class="hljs-title function_">value</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 也可以写成如下方式</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedCounter</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            c++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decrement</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            c--;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">value</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-keyword">return</span> c;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 可以明确指定锁来分离不同的需要加锁的逻辑</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MsLunch</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inc1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span>(lock1) &#123;<br>            c1++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inc2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span>(lock2) &#123;<br>            c2++;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同步方法有下面的特点</p><ul><li>不同的线程对同一个对象的同步方法调用不会交叉，即一个调用时另一个会 block 然后等前一个调用完成</li><li>前一个调用 happens-before 后面别的同步方法的调用，保证改动对所有线程可见</li><li>构造函数不能（也没意义）添加 synchronized 关键字</li></ul><p>这样就保证了不同线程调用同一个对象时，读、写数据不会造成不一致的情况。</p><h3 id="locks"><a href="#locks" class="headerlink" title="locks"></a>locks</h3><p>内在锁（intrinsic lock）或称为监视器锁（monitor lock），用于建立不同线程间调用时 happens-before 的关系。</p><p>具体的定义为</p><blockquote><p>Every object has an intrinsic lock associated with it. By convention, a thread that needs exclusive and consistent access to an object’s fields has to acquire the object’s intrinsic lock before accessing them, and then release the intrinsic lock when it’s done with them. A thread is said to own the intrinsic lock between the time it has acquired the lock and released the lock. As long as a thread owns an intrinsic lock, no other thread can acquire the same lock. The other thread will block when it attempts to acquire the lock.</p></blockquote><blockquote><p>When a thread releases an intrinsic lock, a happens-before relationship is established between that action and any subsequent acquisition of the same lock.</p></blockquote><p>当一个线程执行 synchronized 相关方法时，则申请一个内在锁，等到退出（哪怕是未捕捉的异常退出）时释放锁，别的线程才可继续调用该对象的 synchronized 方法。synchronized 为可重入锁，即同一个线程内的可以直接调用其它 synchronized 修饰的方法。</p><h3 id="atomic-access"><a href="#atomic-access" class="headerlink" title="atomic-access"></a>atomic-access</h3><ul><li>Reads and writes are atomic for reference variables and for most primitive variables (all types except long and double).</li><li>Reads and writes are atomic for all variables declared volatile (including long and double variables).</li></ul><p>关于 long 和 double 类型的读写不是原子性，可见后面的参考文章。即对 long 和 double 类型的读写最好放在 synchronized 中进行。</p><h3 id="guarded-block"><a href="#guarded-block" class="headerlink" title="guarded-block"></a>guarded-block</h3><p>即在线程中循环检查某个条件，条件满足之后才进行后续的行为。比较推荐的做法是，检查该条件，并且调用 wait 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">guardedJoy</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// This guard only loops once for each special event, which may not</span><br>    <span class="hljs-comment">// be the event we&#x27;re waiting for.</span><br>    <span class="hljs-keyword">while</span>(!joy) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            wait();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;&#125;<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;Joy and efficiency have been achieved!&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 另一个方法调用 notifyAll() 方法去通知等待锁释放的线程</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-title function_">notifyJoy</span><span class="hljs-params">()</span> &#123;<br>    joy = <span class="hljs-literal">true</span>;<br>    notifyAll();<br>&#125;<br></code></pre></td></tr></table></figure><p>这里需要注意的是，该处的 wait 方法属于 Object 的方法，只能在 synchronized 修饰的方法中使用。除了 notifyAll 以外，还有个 notify 方法，该方法则是随机唤醒一个在等待锁释放的线程，平时更倾向于使用 notifyAll。</p><h2 id="Immutable-Objects"><a href="#Immutable-Objects" class="headerlink" title="Immutable Objects"></a>Immutable Objects</h2><p>不可变对象，即对象本身的状态（字段）不会更新（不能更新），具体的策略如下</p><ul><li>如果需要修改对象属性，可通过方法新建一个对象，原有的对象不变</li><li>所有的字段都已经是私有的，加上 final</li><li>将类声明为 final 的，子类服务重写其方法，也可以通过将构造函数声明为 private，通过工厂方法创建对象</li><li>只有一个字段是对象引用，并且被引用的对象也是不可变对象</li></ul><h2 id="High-Level-Concurrency-Objects"><a href="#High-Level-Concurrency-Objects" class="headerlink" title="High Level Concurrency Objects"></a>High Level Concurrency Objects</h2><h3 id="Lock-Objects"><a href="#Lock-Objects" class="headerlink" title="Lock-Objects"></a>Lock-Objects</h3><p>Lock 类比之前的 synchronized 提供更加细致的方法，如支持 wait &#x2F; notify 方法，支持 tryLock 可以用于获取锁的超时控制。</p><h3 id="Concurrent-Collections"><a href="#Concurrent-Collections" class="headerlink" title="Concurrent-Collections"></a>Concurrent-Collections</h3><ul><li>BlockingQueue - FIFO 如果队列满了 &#x2F; 空了阻塞相应的请求</li><li>ConcurrentMap - 对 KV 的操作加锁</li></ul><h3 id="Atomic-Variables"><a href="#Atomic-Variables" class="headerlink" title="Atomic-Variables"></a>Atomic-Variables</h3><p>如 <code>java.util.concurrent.atomic.AtomicInteger</code> 对其进行增减操作不需要进行额外的加锁，其内部进行锁的相关操作。</p><p>相比 synchronized 修饰的代码，这边能更精确的控制临界区，减少不必要的同步操作。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol><li><a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/index.html">官方教程</a></li><li><a href="https://docs.oracle.com/javase/7/docs/technotes/guides/concurrency/threadPrimitiveDeprecation.html">Why are Thread.stop, Thread.suspend and Thread.resume Deprecated?</a></li><li><a href="https://dzone.com/articles/longdouble-are-not-atomic-in-java">Long and Double Values Are Not Atomic in Java</a></li><li><a href="https://stackoverflow.com/questions/6155951/whats-the-difference-between-deadlock-and-livelock">死锁和活锁的区别</a></li><li><a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/newlocks.html">Lock Objects</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>thread</tag>
      
      <tag>concurrency</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 学习记录 02</title>
    <link href="/2018/07/27/get-started-in-java-02/"/>
    <url>/2018/07/27/get-started-in-java-02/</url>
    
    <content type="html"><![CDATA[<p>环境：Java8, Idea 社区版，ubuntu 18.04 LTS</p><p>背景：基本没有 Java 实战经验，有 Python 和 Golang 的经验</p><p>前篇</p><ul><li>学习记录 <a href="/2018/07/13/get-started-in-java-01/">01</a></li></ul><h2 id="Basic-Data-Type"><a href="#Basic-Data-Type" class="headerlink" title="Basic-Data-Type"></a>Basic-Data-Type</h2><p>常见类型有</p><ul><li>byte (8)</li><li>short (16)</li><li>int (32)</li><li>long (64)</li><li>float (32)</li><li>double (64)</li><li>boolean</li><li>char (16)</li></ul><p>需要注意的是，局部变量声明后需要进行初始化，否则将报错。但作为类的成员则有默认值，如 int 不初始化则默认为 0。</p><h3 id="Encoding"><a href="#Encoding" class="headerlink" title="Encoding"></a>Encoding</h3><p>我在本机环境下进行测试时，JVM 默认的编码为 UTF-8。如果对编码比较敏感，可以通过设置环境变量修改编码，这里有个有趣的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">SecureRandom</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecureRandom</span>();<br>    <span class="hljs-type">byte</span>[] src = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">16</span>];<br>    random.nextBytes(src);<br><br>    System.out.println(src.length);<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">dst</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(src);<br>    System.out.println(dst.length());<br>    System.out.println(dst.getBytes().length);<br>    System.out.println(dst.getBytes(StandardCharsets.UTF_16).length);<br>&#125;<br></code></pre></td></tr></table></figure><p>上述的结果除了第一个是明确的 16 以外其它都是不明确的，对于一个 byte，UTF-8 可能会以 2 个 byte 编码，所以上述代码的 dst 则是不确定长度的。但一般来说这种场景比较少见，在实际写代码的过程中，我们使用的是编码过后的文件或者输入，而不是直接处理 unicode。</p><h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><p>Array 为定长的固定类型的数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 声明但不初始化使用则会报错，variable X might not have been initialized</span><br><span class="hljs-type">int</span>[] array;<br><br>array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">1</span>];<br><br><span class="hljs-comment">// 如果不赋值，array[0] 为对应类型的默认值，这里为 0</span><br>array[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>System.out.println(array);<br><br><span class="hljs-comment">// array = &#123;1&#125;;</span><br><span class="hljs-comment">// 不能重新初始化</span><br><br><span class="hljs-type">int</span>[] list = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>System.out.println(list);<br><br><span class="hljs-comment">// 二维数组</span><br>String[][] names = &#123;<br>    &#123;<span class="hljs-string">&quot;Mr. &quot;</span>, <span class="hljs-string">&quot;Mrs. &quot;</span>, <span class="hljs-string">&quot;Ms. &quot;</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;Smith&quot;</span>, <span class="hljs-string">&quot;Jones&quot;</span>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在 <code>java.util.Arrays</code> 中包含众多 array 的有用的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] src = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;;<br><span class="hljs-type">int</span>[] dst = Arrays.copyOfRange(src, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">// copy</span><br>Arrays.sort(dst); <span class="hljs-comment">// sort</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> item: dst) &#123;<br>    System.out.println(item);<br>&#125;<br><br>System.out.println(Arrays.binarySearch(src, <span class="hljs-number">8</span>)); <span class="hljs-comment">// binarySearch</span><br></code></pre></td></tr></table></figure><h2 id="Nested-Classes"><a href="#Nested-Classes" class="headerlink" title="Nested-Classes"></a>Nested-Classes</h2><p>嵌套类分两种，static 的和 non-static 的。前者为静态嵌套类，后者为内部类。</p><h3 id="Static-Nested-Classes"><a href="#Static-Nested-Classes" class="headerlink" title="Static-Nested-Classes"></a>Static-Nested-Classes</h3><p>静态嵌套类（下称嵌套类）为包含其的类（这里称为外部类）的一个成员。</p><p>嵌套类能访问外部类的 static 属性（包括 private）和方法，即与该类关联，而不是与该类的实例管理。常用来实现外部类相关的一些 helper 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OuterClass</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">objCnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticNestedClass</span> &#123;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getObjCnt</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> objCnt;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">OuterClass</span><span class="hljs-params">()</span> &#123;<br>        objCnt +=<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// OuterClass.StaticNestedClass snc = new OuterClass.StaticNestedClass();</span><br><span class="hljs-comment">// System.out.println(snc.getObjCnt());</span><br></code></pre></td></tr></table></figure><h3 id="Inner-Classes"><a href="#Inner-Classes" class="headerlink" title="Inner-Classes"></a>Inner-Classes</h3><p>内部类的实例与外部类的实例绑定，与嵌套类不同的是，内部类不允许有 static 的成员。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OuterClass</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InnerClass</span> &#123;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testPrint</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;this.v = &quot;</span> + v);<br>            System.out.println(<span class="hljs-string">&quot;this.v = &quot;</span> + <span class="hljs-built_in">this</span>.v);<br>            System.out.println(<span class="hljs-string">&quot;OuterClass.this.x = &quot;</span> + x);<br>            System.out.println(<span class="hljs-string">&quot;OuterClass.this.v = &quot;</span> + OuterClass.<span class="hljs-built_in">this</span>.v);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// OuterClass.InnerClass ic = oc.new InnerClass();</span><br><span class="hljs-comment">// ic.testPrint();</span><br><span class="hljs-comment">// -&gt; this.v = 1</span><br><span class="hljs-comment">// -&gt; this.v = 1</span><br><span class="hljs-comment">// -&gt; OuterClass.this.x = 0</span><br><span class="hljs-comment">// -&gt; OuterClass.this.v = 0</span><br></code></pre></td></tr></table></figure><p>上述 this 的用法与之前说过的类似，用于指明访问的是哪一个变量。如果内部类定义了与外部类同名的成员，则直接使用会屏蔽外部类对应的成员。</p><h3 id="Local-Classes"><a href="#Local-Classes" class="headerlink" title="Local-Classes"></a>Local-Classes</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">word</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;word&quot;</span>;<br>        <span class="hljs-comment">// word = &quot;helloworld&quot;;</span><br>        <span class="hljs-comment">// 去掉注释则会报错</span><br><br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(word);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">Test</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();<br>        t.print();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>本地类用于用完即弃的场景。</p><p>需要注意的是，在本地类中可以访问外部的局部变量，前提是这些变量是 final 的或者是 effectively final。effectively final 为 Java8 新增的特性，即变量初始化时编译器都当作 final，但在更新时变成了 non-final。</p><p>同样的，如果本地类中定义了同名的成员，则会屏蔽外部的变量。</p><h3 id="Anonymous-Classes"><a href="#Anonymous-Classes" class="headerlink" title="Anonymous-Classes"></a>Anonymous-Classes</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>    <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Greeter</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHi</span><span class="hljs-params">()</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">Greeter</span> <span class="hljs-variable">helloWorld</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Greeter</span>() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHi</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;hello-world&quot;</span>);<br>            &#125;<br>        &#125;;<br><br>        helloWorld.sayHi();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同内部类和本地类，匿名类都不能有 static 属性 &#x2F; 方法，但是可以有 <code>final static</code> 的属性。匿名类的常见例子如实现自定义排序的规则。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer[] ls = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>&#125;;<br><br>Arrays.sort(ls, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() &#123;<br>    <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer x, Integer y)</span> &#123;<br>        <span class="hljs-keyword">return</span> x - y; <span class="hljs-comment">// 升序排列</span><br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h2><p>上述的排序可以以 Lambda 表达式改写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.sort(ls, (x, y) -&gt; x - y);<br></code></pre></td></tr></table></figure><p>Lambda 表达式基本语法如下</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-function"><span class="hljs-params">(arg1, arg2...)</span> -&gt;</span> &#123; body &#125;<br><br><span class="hljs-function"><span class="hljs-params">(type1 arg1, type2 arg2...)</span> -&gt;</span> &#123; body &#125;<br><br><span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span> &#123; body &#125;<br></code></pre></td></tr></table></figure><p>这里还有另一个常见的例子，用于过滤数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Predicate</span>&lt;T&gt; &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">test</span><span class="hljs-params">(T t)</span>;<br>    <span class="hljs-comment">// 用于 Lambda 的 interface 只能有一个方法</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>);<br><br>        evaluate(list, x -&gt; x &gt; <span class="hljs-number">1</span>);<br>        evaluate(list, x -&gt; <span class="hljs-literal">true</span>);<br><br>        <span class="hljs-comment">// 将标准库原有的函数转化为 Lambda 表达式</span><br>        list.forEach(System.out::println);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">evaluate</span><span class="hljs-params">(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate)</span> &#123;<br>        <span class="hljs-keyword">for</span> (Integer n : list) &#123;<br>            <span class="hljs-keyword">if</span> (predicate.test(n)) &#123;<br>                System.out.print(n + <span class="hljs-string">&quot; &quot;</span>);<br>            &#125;<br>        &#125;<br>        System.out.println();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>基本的规则如下</p><ul><li>可带参数，也可不带参数</li><li>可带类型，也可不带类型，根据上下文来推导类型</li></ul><p>Lambda 更多与 Interface 细节相关，这里先只介绍相关语法。</p><h2 id="Annotation"><a href="#Annotation" class="headerlink" title="Annotation"></a>Annotation</h2><p>注解，对被注解代码的逻辑没有直接的影响，而是在逻辑以外提供额外的数据信息。</p><ul><li>可提供信息给编译器使用</li><li>IDE 可根据注解生成对应的配置文件</li><li>其信息可被编译进 class 文件中，或者说保留在 Java 虚拟机中，供运行时判断</li></ul><p>对于 Java 代码从编写到运行有三个时期</p><ol><li>代码编辑</li><li>编译成 .class 文件</li><li>读取到 JVM 运行</li></ol><p>针对这三个时期有三种 Annotation 对应</p><ol><li>RetentionPolicy.SOURCE  &#x2F;&#x2F; 只在代码编辑期生效</li><li>RetentionPolicy.CLASS   &#x2F;&#x2F; 在编译期生效，默认值</li><li>RetentionPolicy.RUNTIME &#x2F;&#x2F; 在代码运行时生效</li></ol><p>除此之外，Java 提供了 @Target 这个 元注解 来指定某个 Annotation 修饰的目标对象，如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SuppressWarnings &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The set of warnings that are to be suppressed by the compiler in the</span><br><span class="hljs-comment">     * annotated element.  Duplicate names are permitted.  The second and</span><br><span class="hljs-comment">     * successive occurrences of a name are ignored.  The presence of</span><br><span class="hljs-comment">     * unrecognized warning names is &lt;i&gt;not&lt;/i&gt; an error: Compilers must</span><br><span class="hljs-comment">     * ignore any warning names they do not recognize.  They are, however,</span><br><span class="hljs-comment">     * free to emit a warning if an annotation contains an unrecognized</span><br><span class="hljs-comment">     * warning name.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt; The string &#123;<span class="hljs-doctag">@code</span> &quot;unchecked&quot;&#125; is used to suppress</span><br><span class="hljs-comment">     * unchecked warnings. Compiler vendors should document the</span><br><span class="hljs-comment">     * additional warning names they support in conjunction with this</span><br><span class="hljs-comment">     * annotation type. They are encouraged to cooperate to ensure</span><br><span class="hljs-comment">     * that the same names work across multiple compilers.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the set of warnings to be suppressed</span><br><span class="hljs-comment">     */</span><br>    String[] value();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>SuppressWarnings</code> 这个注解作用于类型函数等等，并且在代码编辑期间生效。代码编辑期间的注解更多是用于代码检查，如更常见的 <code>Override</code>。</p><h3 id="Runtime-Annotation"><a href="#Runtime-Annotation" class="headerlink" title="Runtime-Annotation"></a>Runtime-Annotation</h3><p>runtime annotation 是基于 Java 本身的反射机制来实现，反射指的是在运行期间动态操作类 &#x2F; 对象，这里先不展开来讲。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.FIELD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@interface</span> JsonKeyField &#123;<br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><br>    <span class="hljs-meta">@JsonKeyField(&quot;first_name&quot;)</span><br>    <span class="hljs-keyword">public</span> String firstName;<br><br>    <span class="hljs-meta">@JsonKeyField(&quot;last_name&quot;)</span><br>    <span class="hljs-keyword">public</span> String lastName;<br><br>    <span class="hljs-meta">@JsonKeyField()</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String firstName, String lastName, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.firstName = firstName;<br>        <span class="hljs-built_in">this</span>.lastName = lastName;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toJsonStr</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> JsonProcessingException, IllegalAccessException &#123;<br>        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, Object&gt;();<br>        <span class="hljs-keyword">for</span> (Field field : <span class="hljs-built_in">this</span>.getClass().getDeclaredFields()) &#123;<br>            <span class="hljs-keyword">if</span> (field.isAnnotationPresent(JsonKeyField.class)) &#123;<br>                <span class="hljs-type">JsonKeyField</span> <span class="hljs-variable">jkf</span> <span class="hljs-operator">=</span> field.getAnnotation(JsonKeyField.class);<br>                <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> jkf.value().isEmpty()? field.getName(): jkf.value();<br>                map.put(key, field.get(<span class="hljs-built_in">this</span>));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>().writeValueAsString(map);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码使用注解 <code>JsonKeyField</code> 来规范导出成 JSON 时候的字段，如果没有指定，则沿用原有的成员名字。这里的写法有点类似 Golang 中的 struct tag 的功能，如果有多种格式（如 Msgpack）的需求可以写多个注解。</p><p>其实可以看到，注解本身其实只起到一个标记或者说文档的作用，而真正的用处是供外部调用在运行时提供信息给外部进行判断来执行相应的操作。</p><p>需要注意的是，注解中只有一个属性，使用 <code>value()</code> 来定义，则使用注解时可以不用指定参数名。常见的用于代码检查的注解和用于运行时检查的注解，还有编译时使用的注解，后者这边就不进行讨论了。</p><h2 id="Generics"><a href="#Generics" class="headerlink" title="Generics"></a>Generics</h2><p>泛型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericBox</span>&lt;T&gt;  &#123;<br><br>    <span class="hljs-keyword">private</span> T item;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getItem</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> item;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setItem</span><span class="hljs-params">(T item)</span> &#123;<br>        <span class="hljs-built_in">this</span>.item = item;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Box&lt;String&gt; box = new Box&lt;&gt;();</span><br></code></pre></td></tr></table></figure><p>这里需要注意的是，泛型中的类型不能是基础类型（如 int，char），你可以是任何的类，接口。</p><p>这里有个约定的类型命名</p><ul><li>E - Element (used extensively by the Java Collections Framework)</li><li>K - Key</li><li>N - Number</li><li>T - Type</li><li>V - Value</li><li>S,U,V etc. - 2nd, 3rd, 4th types</li></ul><h3 id="Generic-Method"><a href="#Generic-Method" class="headerlink" title="Generic-Method"></a>Generic-Method</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Pair</span>&lt;K, V&gt; &#123;<br>    <span class="hljs-keyword">public</span> K <span class="hljs-title function_">getKey</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderedPair</span>&lt;K, V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Pair</span>&lt;K, V&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> K key;<br>    <span class="hljs-keyword">private</span> V value;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">OrderedPair</span><span class="hljs-params">(K key, V value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.key = key;<br>        <span class="hljs-built_in">this</span>.value = value;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> K <span class="hljs-title function_">getKey</span><span class="hljs-params">()</span>&#123; <span class="hljs-keyword">return</span> key; &#125;<br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> value; &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;K, V&gt; <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Pair&lt;K, V&gt; p1, Pair&lt;K, V&gt; p2)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Pair&lt;Integer, String&gt; p1 = new OrderedPair&lt;&gt;(1, &quot;apple&quot;);</span><br><span class="hljs-comment">// Pair&lt;Integer, String&gt; p2 = new OrderedPair&lt;&gt;(2, &quot;pear&quot;);</span><br><span class="hljs-comment">// boolean same = OrderedPair.&lt;Integer, String&gt;equals(p1, p2);</span><br><span class="hljs-comment">// same = OrderedPair.equals(p1, p2); // 1.7+</span><br></code></pre></td></tr></table></figure><p>与普通的函数不同的是，上述的泛型方法声明时前面需要添加 <code>&lt;T...&gt;</code></p><h3 id="Bounded-Type-Parameter"><a href="#Bounded-Type-Parameter" class="headerlink" title="Bounded-Type-Parameter"></a>Bounded-Type-Parameter</h3><p>当使用泛型时，如尝试在函数内进行比较操作，如果一些自定义类没有实现 compare 相关的方法，则会在运行时报错。这里可以引入泛型边界的用法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Box</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Number</span>&gt; &#123;<br>    <span class="hljs-keyword">private</span> T item;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getItem</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> item;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setItem</span><span class="hljs-params">(T item)</span> &#123;<br>        <span class="hljs-built_in">this</span>.item = item;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Box&lt;Number&gt; box = new Box&lt;&gt;();</span><br></code></pre></td></tr></table></figure><p>如果使用类不是 Number 或者不是继承了 Number 的类则会在编译时报错。此外也可以添加多个约束，语法为 <code>&lt;T extends B1 &amp; B2 &amp; B3&gt;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Data</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;Data&gt; &#123;<br>    <span class="hljs-type">int</span> data;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Data d)</span> &#123;<br>        <span class="hljs-keyword">return</span> data - d.data;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">function</span><span class="hljs-params">(Box&lt;Double&gt; bi)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Box</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;T&gt;&gt; &#123;<br>    <span class="hljs-keyword">private</span> T item;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getItem</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> item;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setItem</span><span class="hljs-params">(T item)</span> &#123;<br>        <span class="hljs-built_in">this</span>.item = item;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">(List&lt;Number&gt; l)</span> &#123;<br>        ;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Data data = new Data();</span><br><span class="hljs-comment">// Box&lt;Data&gt; box = new Box&lt;&gt;();</span><br><br><span class="hljs-comment">// Box.f(Arrays.asList(1, 2, 3, 4)); // Error</span><br></code></pre></td></tr></table></figure><p>也可以使用接口去限制，这里则是要求必须实现 <code>Comparable</code> 接口。这里需要注意的是，像上述代码 <code>Box</code> 中像方法 <code>f</code> 如果试图传入 <code>List&lt;Integer&gt;</code> 则会报错。</p><p><code>Integer</code> 的确是 <code>Number</code> 子类，但 <code>Box&lt;Integer&gt;</code> 不是 <code>Box&lt;Number&gt;</code> 的子类，准确来说两者没有任何关系，他们的父类均是 <code>Object</code>。另一方面 <code>ArrayList&lt;String&gt;</code> 的父类是 <code>List&lt;String&gt;</code> 并以此类推。</p><h3 id="Type-Inference"><a href="#Type-Inference" class="headerlink" title="Type-Inference"></a>Type-Inference</h3><p>类型推断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String, List&lt;String&gt;&gt; myMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, List&lt;String&gt;&gt;();<br>Map&lt;String, List&lt;String&gt;&gt; myMap1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><p>上述两种调用都是合法的，需要注意的是 <code>HashMap</code> 后面的 <code>&lt;&gt;</code> 不能忽略。这里涉及更多是编译器的优化，如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">processStringList</span><span class="hljs-params">(List&lt;String&gt; stringList)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// processStringList(Collections.emptyList());</span><br><span class="hljs-comment">// 上述调用在 Java7 会报错，Java8 则不会</span><br></code></pre></td></tr></table></figure><p>Java10 更是引进了 var 的类型判断机制，在我看来，写代码的时候借助 IDE 工具一般就能解决这些问题。</p><h3 id="Wildcard"><a href="#Wildcard" class="headerlink" title="Wildcard"></a>Wildcard</h3><p>通配符，这里有三种通配符</p><ul><li>Upper Bounded Wildcard</li><li>Unbounded Wildcard</li><li>Lower Bounded Wildcard</li></ul><p>其对应的语法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Upper Bounded Wildcard</span><br><span class="hljs-comment">// 表示 Number 或者 Number 的子类都可以</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">sumOfList</span><span class="hljs-params">(List&lt;? extends Number&gt; list)</span> &#123;<br>    <span class="hljs-type">double</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.0</span>;<br>    <span class="hljs-keyword">for</span> (Number n : list)<br>        s += n.doubleValue();<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br><br><span class="hljs-comment">// Unbounded Wildcard</span><br><span class="hljs-comment">// 没有任何限制</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printList</span><span class="hljs-params">(List&lt;?&gt; list)</span> &#123;<br>    <span class="hljs-keyword">for</span> (Object elem: list)<br>        System.out.print(elem + <span class="hljs-string">&quot; &quot;</span>);<br>    System.out.println();<br>&#125;<br><br><span class="hljs-comment">// Lower Bounded Wildcard</span><br><span class="hljs-comment">// Integer 或者 Integer 的父类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addNumbers</span><span class="hljs-params">(List&lt;? <span class="hljs-built_in">super</span> Integer&gt; list)</span> &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++) &#123;<br>list.add(i);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通配符的使用主要是为了解决诸如 <code>Box&lt;Integer&gt;</code> 不是 <code>Box&lt;Number&gt;</code> 的子类的问题。</p><p>对于选择 Upper 还是 Lower，可以以严于律己宽于待人来设计，即</p><ul><li>对于外部输入，用户调用的参数，选择 Upper Bounded Wildcard，它最终也可以是 null 或者 Object 的子类</li><li>对于函数的输出，则应该使用 Lower Bounded Wildcard</li></ul><h3 id="Type-Erasure"><a href="#Type-Erasure" class="headerlink" title="Type-Erasure"></a>Type-Erasure</h3><p>类型擦除是 Java 泛型的实现方法。编译器在编译的时候去掉了泛型的信息（在 <a href="https://stackoverflow.com/questions/313584/what-is-the-concept-of-erasure-in-generics-in-java">这里</a> 可以看到编译和反编译代码的区别）。</p><p>和 C++ 不同，C++ 会为每一种类型生成对应的函数，而 Java 则只生成一份代码（以 Object 替代自定义类型 T，以及在某些地方添加类型转换）。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol><li><a href="https://stackoverflow.com/questions/20938095/difference-between-final-and-effectively-final">Difference Between Final And Effectively Final</a></li><li><a href="http://blog.oneapm.com/apm-tech/226.html">深入浅出 Java 8 Lambda</a></li><li><a href="https://segmentfault.com/a/1190000009186509">Java 8 Lambda 表达式详解</a></li><li><a href="http://wingjay.com/2017/05/03/Java-%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%B3%A8%E8%A7%A3-Annotation/">Annotation 详解</a></li><li><a href="http://www.importnew.com/13907.html">Java 泛型和类型擦除</a></li><li><a href="http://www.angelikalanger.com/GenericsFAQ/FAQSections/TechnicalDetails.html#FAQ101">Java 类型擦除</a></li><li><a href="https://javarevisited.blogspot.com/2012/01/get-set-default-character-encoding.html">Java Encoding 解析</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>lambda</tag>
      
      <tag>generic</tag>
      
      <tag>annotation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 学习记录 01</title>
    <link href="/2018/07/13/get-started-in-java-01/"/>
    <url>/2018/07/13/get-started-in-java-01/</url>
    
    <content type="html"><![CDATA[<p>环境：Java8, Idea 社区版，ubuntu 18.04 LTS</p><p>背景：基本没有 Java 实战经验，有 Python 和 Golang 的经验</p><h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><ul><li>JVM（Java Virtual Machine，Java 虚拟机）的缩写</li><li>JRE（Java Runtime Environment，Java 运行环境），运行 Java 程序所必须的环境的集合，包括 JVM 和 Java 程序所需的核心类库等</li><li>JDK（Java Development Kit ，Java 开发工具包）是 Java 语言的软件开发工具包(SDK)。JDK 是提供给 Java 开发人员使用的，其中包含了 Java 的开发工具，也包括了JRE。</li></ul><p>所以安装了JDK，就不用在单独安装 JRE 了。他们的关系为 JVM &lt;&#x3D; JRE &lt;&#x3D; JDK，包含关系</p><h2 id="Init"><a href="#Init" class="headerlink" title="Init"></a>Init</h2><p>首先下载 JDK，然后设置相关环境变量</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">export</span> JAVA_HOME=/home/lycheng/bin/jdk<br><span class="hljs-built_in">export</span> JRE_HOME=/home/lycheng/bin/jdk/jre<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-string">&quot;<span class="hljs-variable">$JAVA_HOME</span>/bin:<span class="hljs-variable">$PATH</span>&quot;</span><br></code></pre></td></tr></table></figure><p><code>which java</code> 看下是否有问题，然后就是 HelloWorld 程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorldApp</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译，执行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">javac main.java<br><span class="hljs-comment"># 生成 HelloWorldApp.class</span><br>java HelloWorldApp<br></code></pre></td></tr></table></figure><h3 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h3><p>同样也是下载二进制包，可参考 <a href="https://maven.apache.org/install.html">Maven 安装指南</a></p><p>设置相关环境变量</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">export</span> MAVEN_HOME=<span class="hljs-variable">$LOCALBIN</span>/maven<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-string">&quot;<span class="hljs-variable">$MAVEN_HOME</span>/bin:<span class="hljs-variable">$PATH</span>&quot;</span><br></code></pre></td></tr></table></figure><p>Maven 的全局设置在 <code>path/to/maven/conf/settings.yml</code> 可修改其 <code>localRepository</code> 设置本地仓库的地址</p><h2 id="Basic-Syntax"><a href="#Basic-Syntax" class="headerlink" title="Basic-Syntax"></a>Basic-Syntax</h2><h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><p>规则</p><ol><li>一个源文件中只能有一个 public 类</li><li>一个源文件可以有多个非 public 类</li><li>源文件的名称应该和 public 类的类名保持一致。例如：源文件中 public 类的类名是 Employee，那么源文件应该命名为 Employee.java</li><li>如果一个类定义在某个 package 中，那么 package 语句应该在源文件的首行</li><li>如果源文件包含 import 语句，那么应该放在 package 语句和类定义之间。如果没有 package 语句，那么 import 语句应该在源文件中最前面</li><li>import 语句和 package 语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明</li></ol><p>class 定义的基本语法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br><br>    <span class="hljs-comment">// 成员变量</span><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-comment">// 类变量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">animalType</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;cat&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Animal</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 调用其它构造函数</span><br>        <span class="hljs-built_in">this</span>(<span class="hljs-string">&quot;default-name&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Animal</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-comment">// 可以在实例方法中修改类静态变量，会提示 warning</span><br>        <span class="hljs-comment">// this.animalType = &quot;dog&quot;;</span><br><br>        <span class="hljs-comment">// 也可以简单的，不提示 warning</span><br>        <span class="hljs-comment">// animalType = &quot;dog&quot;;</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// Override 会去检查父类有没该方法，签名是否对的上</span><br>        <span class="hljs-comment">// 不加的话如果对不上，则会认为是新的方法</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Animal&#x27;s name is &quot;</span> + name + <span class="hljs-string">&quot;, type is &quot;</span> + animalType;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getAnimalType</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> animalType;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAnimalType</span><span class="hljs-params">(String animalType)</span> &#123;<br>        Animal.animalType = animalType;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 this 的用法</p><ul><li>当你局部变量有和类实例变量同名时，用来明确表示使用的是类实例变量</li><li>当前的对象的引用</li><li>调用别的构造函数</li></ul><h3 id="Inheritance"><a href="#Inheritance" class="headerlink" title="Inheritance"></a>Inheritance</h3><p>Java 中只允许单继承</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Cat</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">str</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述的 super(name) 是调用父类的构造函数，第二个 super 则是父类引用，用于调用父类的成员函数。</p><p>关于 static 有以下特性</p><ul><li>在子类调用父类的 static 方法，也会影响到父类</li><li>static 的属性不依赖于任何的对象和子类，在内存中只会存在一份副本</li><li>static 语句在类加载的时候执行，按顺序执行，并只执行一次</li></ul><p>需要注意 Java 的类方法和属性在定义的时候可以设定访问权限，对应的关系如下</p><table><thead><tr><th>Access Level</th><th>Class</th><th>Package</th><th>Subclass</th><th>World</th></tr></thead><tbody><tr><td>public</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>protected</td><td>Y</td><td>Y</td><td>Y</td><td>N</td></tr><tr><td>no</td><td>Y</td><td>Y</td><td>N</td><td>N</td></tr><tr><td>private</td><td>Y</td><td>N</td><td>N</td><td>N</td></tr></tbody></table><p>可以看到，private 的最严格，public 最松散。</p><h3 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h3><p>interface 简单来说就是规定了类的函数签名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Bicycle</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">speedUp</span><span class="hljs-params">(<span class="hljs-type">int</span> incrment)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">applyBreaks</span><span class="hljs-params">(<span class="hljs-type">int</span> decrement)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TheBicycle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Bicycle</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String brand;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> speed;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TheBicycle</span><span class="hljs-params">(String brand)</span> &#123;<br>        <span class="hljs-built_in">this</span>.brand = brand;<br>        <span class="hljs-built_in">this</span>.speed = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">speedUp</span><span class="hljs-params">(<span class="hljs-type">int</span> incrment)</span> &#123;<br>        <span class="hljs-built_in">this</span>.speed += incrment;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">applyBreaks</span><span class="hljs-params">(<span class="hljs-type">int</span> decrement)</span> &#123;<br>        <span class="hljs-keyword">if</span> (decrement &gt; <span class="hljs-built_in">this</span>.speed) &#123;<br>            <span class="hljs-built_in">this</span>.speed -= decrement;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">this</span>.speed = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>与类继承的异同如下</p><ul><li>类继承仅允许单继承，而接口允许继承（extends）多个接口</li><li>类能实例化对象，但接口不能，所以也没有构造函数<ul><li>抽象类同样不能实例化，继承其的子类也必须实现父类的抽象方法，其余的非抽象方法则可当做为子类提供的默认实现</li></ul></li><li>接口中可以含有变量，但是接口中的变量会被隐式的指定为 <code>public static final</code> 变量（并且只能是 public，用 private 修饰会报编译错误）</li><li>接口被类实现其函数签名</li></ul><p>有了接口，实际调用的时候，可以通过声明接口的参数，至于其底层实现则不关心</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(Transportation t)</span> &#123;<br>        System.out.println(t);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br><br>        <span class="hljs-comment">// Bicycle 和 Car 都实现了 Transportation 这个接口</span><br>        <span class="hljs-type">Bicycle</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TheBicycle</span>(<span class="hljs-string">&quot;Giant&quot;</span>);<br>        <span class="hljs-type">Car</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>();<br><br>        test(b);<br>        test(c);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>与继承不同，接口实现这种方式不同的对象可以是完全不相干的，保证其接口是相同的就可以。</p><h2 id="Project-Structure"><a href="#Project-Structure" class="headerlink" title="Project-Structure"></a>Project-Structure</h2><h3 id="Package"><a href="#Package" class="headerlink" title="Package"></a>Package</h3><p>首先，一个 java 文件中只能有一个类是 public 的，所以定义多个类的时候必须有多个文件。而多个文件的管理则必须通过 package 来管理。</p><p>package 在文件层面看就是同一个文件夹下的不同 java 文件，代码层面就是 . 分隔的模块。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">├── core<br>│   ├── <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Bicycle</span>.</span></span>java<br>│   ├── <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Car</span>.</span></span>java<br>│   └── <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Transportation</span>.</span></span>java<br>└── <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Main</span>.</span></span>java<br></code></pre></td></tr></table></figure><p>每一个 Java 文件必须写明来自哪个 package</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> core;<br><br><span class="hljs-comment">// package name 全小写</span><br></code></pre></td></tr></table></figure><p>在实际使用的时候可以通过 <code>import</code> 语句来引入系统 &#x2F; 自定义的 package。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(core.Transportation t)</span> &#123;<br>        System.out.println(t);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br><br>        core.<span class="hljs-type">Bicycle</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">core</span>.Bicycle(<span class="hljs-string">&quot;Giant&quot;</span>);<br>        core.<span class="hljs-type">Car</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">core</span>.Car();<br><br>        test(b);<br>        test(c);<br><br>        <span class="hljs-comment">// 如果去掉 Date 的 import</span><br>        <span class="hljs-comment">// java.util.Date d = new java.util.Date();</span><br>        <span class="hljs-comment">// 也可以 import java.util.*; 这样也可以不用写完整的类名，但是不推荐</span><br>        <span class="hljs-type">Date</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>        System.out.println(d);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述的代码也可以添加 <code>import</code> 语句来简化代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> core.Transportation;<br><span class="hljs-keyword">import</span> core.Bicycle;<br><span class="hljs-keyword">import</span> core.Car;<br><br><span class="hljs-comment">// Car c = new Car();</span><br></code></pre></td></tr></table></figure><p>需要注意的是，package 里面定义的类只有 public 外部（别的 package）才可见。</p><p>如果使用通配符 * 来 import 还需要注意的是, * 只会 import 那一层级的类，不会递归查找去 import</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.awt.*;<br><span class="hljs-keyword">import</span> java.awt.color.*; <span class="hljs-comment">// 如果想要使用 color 的类，则必须多加一个 import</span><br></code></pre></td></tr></table></figure><h4 id="Static-Import"><a href="#Static-Import" class="headerlink" title="Static-Import"></a>Static-Import</h4><p>在类中定义了 static 成员时，如果外部需要使用，则 import 之后需要带上类名 prefix 才能访问。此时就可以使用 static import 就可以减少代码量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// before</span><br><span class="hljs-comment">// System.out.println(Math.PI);</span><br><br><span class="hljs-comment">// after</span><br><span class="hljs-comment">// import static java.lang.Math.PI;</span><br><br>System.out.println(PI);<br></code></pre></td></tr></table></figure><p>方便使用的同时也带来了问题，丢失了这些 static 成员的出处，查看代码是容易混乱，谨慎使用。</p><h3 id="Naming"><a href="#Naming" class="headerlink" title="Naming"></a>Naming</h3><ol><li>驼峰命名</li><li>函数，方法，变量以首字母小写的驼峰命名</li><li>类，接口以首字母大写的驼峰命名</li><li>常量用全大写，下划线分隔的写法</li></ol><p>企业开发的 package 以域名作为项目的 package 命名，如 <code>com/baidu/www/...</code></p><ul><li>package 命名为全小写，原则上不加分隔符</li><li>Java 的关键字 &#x2F; 数字开头 不推荐使用</li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol><li><a href="https://www.jetbrains.com/idea/features/editions_comparison_matrix.html">Idea 社区版和商业版的区别</a></li><li><a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">JDK 下载</a></li><li><a href="https://docs.oracle.com/javase/tutorial/">Java Tutorial</a></li><li><a href="https://google.github.io/styleguide/javaguide.html">Google Java Style Guide</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>InfluxDB 简介</title>
    <link href="/2018/07/01/influxdb-intro/"/>
    <url>/2018/07/01/influxdb-intro/</url>
    
    <content type="html"><![CDATA[<p>基于 InfluxDB v1.5</p><p>本文更新时间</p><ul><li>2018-07-01: 初版</li></ul><h2 id="What"><a href="#What" class="headerlink" title="What"></a>What</h2><p>InfluxDB 是时间序列数据库的一种，TSDB 来自维基的定义</p><blockquote><p>A time series database (TSDB) is a software system that is optimized for handling time series data, arrays of numbers indexed by time (a datetime or a datetime range).</p></blockquote><p>它适合用于保存大量的与时间相关的数据，例如温度变化，股票指数，如</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">temperature,<span class="hljs-attribute">sensor</span>=a,zone=city <span class="hljs-attribute">val</span>=39.0 1422568543702900257<br>temperature,<span class="hljs-attribute">sensor</span>=b,zone=city <span class="hljs-attribute">val</span>=39.1 1422568543702900258<br>temperature,<span class="hljs-attribute">sensor</span>=a,zone=city <span class="hljs-attribute">val</span>=39.0 1422568543702900259<br>temperature,<span class="hljs-attribute">sensor</span>=b,zone=city <span class="hljs-attribute">val</span>=38.9 1422568543702900260<br>temperature,<span class="hljs-attribute">sensor</span>=a,zone=city <span class="hljs-attribute">val</span>=39.0 1422568543702900261<br>temperature,<span class="hljs-attribute">sensor</span>=b,zone=city <span class="hljs-attribute">val</span>=39.0 1422568543702900262<br></code></pre></td></tr></table></figure><p>目前常用于作为监控系统的数据源，与之类似的还有 <a href="https://prometheus.io/">Prometheus</a>。</p><h3 id="Concepts"><a href="#Concepts" class="headerlink" title="Concepts"></a>Concepts</h3><p>下面是 InfluxDB 的相关概念</p><p>Fields</p><ul><li>数据域，每一行数据至少需要带一个 Field，数值，布尔或者字符串类型</li><li>对数据域的过滤（大于，小于或者在某个范围内）是不经过索引，所有的操作都是全表扫描</li></ul><p>Tags</p><ul><li>可选项，存储时都是字符串类型</li><li>索引项，用于数据的分类</li></ul><p>Measurements</p><ul><li>包含 fields, tags 和其对应的 timestamp</li><li>含有相同的 tag 的在同一个 measurement 的数据称为 serie</li></ul><p>Point</p><ul><li>一条记录，即包含 measurement, tags, fields</li><li>使用 API 使用 Line Protocol 格式提交数据，可以包含 5000 到 10000 的 points</li></ul><p>与 RDBS 相比，database 概念是类似的，InfluxDB 下的 Measurement 则是对应 table, Tags 则是类似于 multiple-column indexes，Field 则是普通的 Column。</p><h3 id="Line-Protocol"><a href="#Line-Protocol" class="headerlink" title="Line Protocol"></a>Line Protocol</h3><p>外部与 InfluxDB 交互的格式，其语法如下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim"># <span class="hljs-symbol">&lt;measurement&gt;</span>[,<span class="hljs-symbol">&lt;tag_key&gt;</span>=<span class="hljs-symbol">&lt;tag_value&gt;</span>[,<span class="hljs-symbol">&lt;tag_key&gt;</span>=<span class="hljs-symbol">&lt;tag_value&gt;</span>]] <span class="hljs-symbol">&lt;field_key&gt;</span>=<span class="hljs-symbol">&lt;field_value&gt;</span>[,<span class="hljs-symbol">&lt;field_key&gt;</span>=<span class="hljs-symbol">&lt;field_value&gt;</span>] [<span class="hljs-symbol">&lt;timestamp&gt;</span>]<br>http,ver=<span class="hljs-number">2.6</span>,modules=content,action=<span class="hljs-keyword">sync</span>,<span class="hljs-built_in">type</span>=consume val=<span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><h2 id="How"><a href="#How" class="headerlink" title="How"></a>How</h2><h3 id="Schema-Design"><a href="#Schema-Design" class="headerlink" title="Schema Design"></a>Schema Design</h3><p>最主要需要记住</p><blockquote><p>tags are indexed, and field are not indexed</p></blockquote><p><em>For Tag</em></p><ul><li>tag 应该是有限的数据集（http status code, region, or version）</li><li>tag 的数据应该是只包含一种信息，而不是复合的信息</li></ul><p>复合的信息如 <code>name=us.android.4-0-4</code>，使用这类数据在后期的查询中只能通过正则进行区分，这里应该使用 <code>country=us,os=android,ver=4-0-4</code>。</p><p>在前文提过，不同的 tag 的值 field 以一个 serie 来存储，假如你有 2 个 tag，每个 tag 有 N 种不同的值，则最终会有 N ^ 2 个 serie。</p><p>因为 InfluxDB 是基于 serie 来做索引，如果在 tag 中插入 UUID 或者随机数一类不确定范围的数据，则会导致 series 数量膨胀导致内存中维护的索引增多，造成系统负载升高。</p><p>所以在设计 Schema 的时候需要认真考虑 Tag 的数量和总体的数量。</p><p><em>For Measurement</em></p><ul><li>同 Tag 一样，不应该包含复合的信息</li></ul><p><em>For Field</em></p><ul><li>field 的数据没有 index，并且可以在其之上用 function（sum, avg or max），则 field 更应存能表示变化的数据</li></ul><h3 id="Hardware"><a href="#Hardware" class="headerlink" title="Hardware"></a>Hardware</h3><p>在单个实例和集群的选择上，官网的 <a href="https://docs.influxdata.com/influxdb/v1.5/guides/hardware_sizing/#general-hardware-guidelines-for-a-single-node">文档</a> 说明了集群和单实例的硬件要求。</p><p>单个实例的处理上限为</p><ul><li>每秒最多 250K 个 Field 的写入</li><li>每秒查询小于 25 次</li><li>series 数量不超过 100W</li></ul><p>上述的硬件推荐配置 4-6 核 CPU，8-32 GB 内存，磁盘性能在 500-1000 IOPS（作为参考，7200 转的机械硬盘的 IOPS 在 200 左右）。根据文档所说，InfluxDB 是设计在 SSD 上使用，他们 <em>没有</em> 在机械硬盘上进行过测试。</p><p>开源版的集群方案停留在 <code>0.11</code>，之后 InfluxDB 将集群作为企业版的特性，为其加入高可用的支持。</p><h3 id="Downsampling-and-data-retention"><a href="#Downsampling-and-data-retention" class="headerlink" title="Downsampling and data-retention"></a>Downsampling and data-retention</h3><p>data-retention （RP）是数据保存的策略。</p><p>默认情况下，数据保存是不过期。可以通过自己设置相应的 RP 去覆盖默认的数据来达到定期删除的功能。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&gt; <span class="hljs-keyword">CREATE</span> RETENTION <span class="hljs-keyword">POLICY</span> &quot;two_hours&quot; <span class="hljs-keyword">ON</span> &quot;db&quot; DURATION <span class="hljs-number">2</span>h <span class="hljs-keyword">REPLICATION</span> <span class="hljs-number">1</span> <span class="hljs-keyword">DEFAULT</span><br></code></pre></td></tr></table></figure><p>Continuous Query (CQ) 则是定期跑的 SQL-like 的命令，用于 downsample 数据（如实时采集，30 分钟做一次求平均到另一个表）。</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sas">&gt; <span class="hljs-keyword">CREATE</span> CONTINUOUS QUERY <span class="hljs-string">&quot;cq_30m&quot;</span> <span class="hljs-keyword">ON</span> <span class="hljs-string">&quot;db&quot;</span> BEGIN<br>  <span class="hljs-keyword">SELECT</span> <span class="hljs-meta">mean</span>(<span class="hljs-string">&quot;website&quot;</span>) <span class="hljs-keyword">AS</span> <span class="hljs-string">&quot;mean_website&quot;</span>,<span class="hljs-meta">mean</span>(<span class="hljs-string">&quot;phone&quot;</span>) <span class="hljs-keyword">AS</span> <span class="hljs-string">&quot;mean_phone&quot;</span><br>  <span class="hljs-keyword">INTO</span> <span class="hljs-string">&quot;a_year&quot;</span>.<span class="hljs-string">&quot;downsampled_orders&quot;</span><br>  <span class="hljs-keyword">FROM</span> <span class="hljs-string">&quot;orders&quot;</span><br>  <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-meta">time</span>(30m)<br><span class="hljs-keyword">END</span><br></code></pre></td></tr></table></figure><p>通过设置 RP 来设置原始数据的过期时间，再通过 CQ 设置按不同维度定时聚合到</p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">curl</span> -i -XPOST &#x27;http://localhost:<span class="hljs-number">8086</span>/write?db=mydb&#x27; --data-binary &#x27;m,a=<span class="hljs-number">1</span>,b=<span class="hljs-number">2</span> c=<span class="hljs-number">3</span>,d=<span class="hljs-number">4</span>&#x27;<br></code></pre></td></tr></table></figure><p>InfluxDB 提供 HTTP 的 API，可以通过 POST 进行数据的更新，需要指定 database，schema 是没有限制的。你需要的是先创建相应的 database。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">curl -i -XPOST http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">8086</span>/query --data-urlencode <span class="hljs-string">&quot;q=CREATE DATABASE mydb&quot;</span><br></code></pre></td></tr></table></figure><p>多行的数据以换行进行分隔，最好是每个数据加上 timestamp，否则 InfluxDB 收到数据时会以服务器上的时间来记录。</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>适合于</p><ul><li>数据与时间相关，并且数据按时间顺序添加，对数据批量添加也很友好</li><li>更新 &#x2F; 删除操作少，着重于最近一段时间的读取</li><li>数据的重点在于趋势，而不是某个具体的点的数值</li></ul><p>不擅长</p><ul><li>UUID 或者随机数标记某一个操作的存储</li><li>联合其它的 database 或者 measurement 进行查询</li></ul><h3 id="Grafana"><a href="#Grafana" class="headerlink" title="Grafana"></a>Grafana</h3><p>InfluxDB 本身作为数据源，配合 <a href="https://grafana.com/">Grafana</a> 就可以做出一个可配置的监控平台，也可以根据某些值进行报警（基于 Webhook）。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol><li><a href="http://liubin.org/blog/2016/02/18/tsdb-intro/">http://liubin.org/blog/2016/02/18/tsdb-intro/</a></li><li><a href="https://db-engines.com/en/ranking/time+series+dbms">https://db-engines.com/en/ranking/time+series+dbms</a></li><li><a href="https://grafana.com/blog/2016/01/05/logs-and-metrics-and-graphs-oh-my/">https://grafana.com/blog/2016/01/05/logs-and-metrics-and-graphs-oh-my/</a></li><li><a href="https://docs.influxdata.com/influxdb/v1.5/concepts/storage_engine/#storage-engine">https://docs.influxdata.com/influxdb/v1.5/concepts/storage_engine/#storage-engine</a></li><li><a href="https://github.com/influxdata/influxdb/blob/master/tsdb/engine/tsm1/DESIGN.md">实现细节</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>influxdb</tag>
      
      <tag>metrics</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python yield 用法示例</title>
    <link href="/2017/10/04/python-yield/"/>
    <url>/2017/10/04/python-yield/</url>
    
    <content type="html"><![CDATA[<p>本文主要关注 Python 中 yield 的相关用法，包括 Python3 中新增的特性。</p><h2 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> inspect<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">looper</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;started&quot;</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>        <span class="hljs-keyword">yield</span> i<br><br><span class="hljs-comment"># 此时还没开始执行</span><br><span class="hljs-comment"># 后面也可以看到他的状态为 GEN_CREATED 即等待开始执行</span><br>loop = looper()<br><span class="hljs-built_in">print</span>(inspect.getgeneratorstate(loop)) <span class="hljs-comment"># GEN_CREATED</span><br><br><span class="hljs-comment"># 调用 next 方法，则往前执行到第一个 yield 后暂停</span><br><span class="hljs-comment"># 等待下一次调用 next</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(loop))<br><span class="hljs-comment"># started</span><br><span class="hljs-comment"># 0</span><br><br><span class="hljs-built_in">print</span>(inspect.getgeneratorstate(loop)) <span class="hljs-comment"># GEN_SUSPENDED</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(loop)) <span class="hljs-comment"># 1</span><br><br>loop = looper()<br><span class="hljs-comment"># for 语法中它会自动帮你处理 next 调用</span><br><span class="hljs-comment"># 还会自动处理 StopIteration 的异常并安全退出</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> loop:<br>    <span class="hljs-built_in">print</span>(i)<br></code></pre></td></tr></table></figure><p>上述代码演示的是 yield 最常见的用法，与普通的函数调用不同，函数体内有 yield 关键字的，并不是像普通的函数一样执行，而且需要手动触发其第一次执行，这里就是通过 next 方法。</p><p>这里还有另一种更简单的写法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 生成器表达式，与 [] 的不同，这里是惰性求值的</span><br>loop = (x*x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>))<br><span class="hljs-built_in">print</span>(inspect.getgeneratorstate(loop)) <span class="hljs-comment"># GEN_CREATED</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(loop)) <span class="hljs-comment"># 0</span><br><span class="hljs-built_in">print</span>(inspect.getgeneratorstate(loop)) <span class="hljs-comment"># GEN_SUSPENDED</span><br></code></pre></td></tr></table></figure><p>简单来说就是 <strong>保留现场，惰性求值</strong>。</p><h2 id="send-close-throw"><a href="#send-close-throw" class="headerlink" title="send, close, throw"></a>send, close, throw</h2><p>yield 生成器除了可以返回值以外，外部还可以通过 send 方法与其通信。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">adder</span>():<br>    ret = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        i = <span class="hljs-keyword">yield</span> ret<br>        ret += i<br><br>looper = adder()<br><span class="hljs-comment"># looper.send(1)</span><br><span class="hljs-comment"># TypeError: can&#x27;t send non-None value to a just-started generator</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(looper))  <span class="hljs-comment"># 0</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(looper)) <br><span class="hljs-comment"># TypeError: unsupported operand type(s) for +=: &#x27;int&#x27; and &#x27;NoneType&#x27;</span><br><span class="hljs-comment"># 继续调用 next 传进去的是一个 None，+= 计算时便出现了问题</span><br><br><span class="hljs-comment"># 第一次调用 next 去到 yield 处返回 ret，此时值为 0，并暂停</span><br><span class="hljs-comment"># 后面的代码调用 send 的时候从暂停处恢复，ret += 1 并 yield 返回结果，继续暂停</span><br><span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>):<br>    i = looper.send(n)<br>    <span class="hljs-built_in">print</span>(i) <span class="hljs-comment"># 1, 3, 6 ...</span><br></code></pre></td></tr></table></figure><p>这里需要注意的激活生成器可以调用 <code>gen.send(None)</code> 来处理，但上述的代码中并没进行对接收到的数据的类型检查，加法会出现问题。</p><p>send 是用在和生成器正常交互的，close 和 throw 则是用在关闭或者说处理相应异常逻辑的。相关文档 <a href="https://docs.python.org/3/reference/expressions.html#generator-iterator-methods">点这里</a>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">looper.close()<br><span class="hljs-built_in">print</span>(inspect.getgeneratorstate(looper))  <span class="hljs-comment"># GEN_CLOSED</span><br></code></pre></td></tr></table></figure><p>close 在 yield 暂停处 raise 一个 GenerationExit 的异常（需要注意的是，这类异常不能用通用的 Exception 去捕捉）。如果不处理这异常，则在调用方不会报错，如果忽略该异常，则会报 RuntimeError。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">echo</span>(<span class="hljs-params">v=<span class="hljs-literal">None</span></span>):<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">try</span>:<br>            v = (<span class="hljs-keyword">yield</span> v)<br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> ex:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;common exception&quot;</span>)<br>        <span class="hljs-keyword">except</span> GeneratorExit <span class="hljs-keyword">as</span> ex:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;gen exit&quot;</span>)<br>            <span class="hljs-keyword">return</span><br><br>g = echo()<br><span class="hljs-built_in">next</span>(g)<br>g.close()<br><span class="hljs-comment"># RuntimeError: generator ignored GeneratorExit</span><br></code></pre></td></tr></table></figure><p>throw 则是外部传入一个异常，需要生成器自身去处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">echo</span>():<br>    i = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        i += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">yield</span> i<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;aha&#x27;</span>)<br>        <span class="hljs-keyword">except</span> TypeError <span class="hljs-keyword">as</span> ex: <span class="hljs-comment"># 如果异常不处理，则会往上冒泡，传给调用方</span><br>            <span class="hljs-built_in">print</span>(ex, i)<br>        <span class="hljs-keyword">except</span> GeneratorExit:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;gen exit&quot;</span>, i) <span class="hljs-comment"># 这个会在程序结束的时候自动调用</span><br>            <span class="hljs-keyword">return</span><br><br><br>g = echo()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;from generator:&quot;</span>, <span class="hljs-built_in">next</span>(g))<br><span class="hljs-built_in">print</span>(g.throw(TypeError, <span class="hljs-string">&quot;TypeError: from caller&quot;</span>)) <span class="hljs-comment"># 2</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;END&quot;</span>)<br></code></pre></td></tr></table></figure><p>如果处理了 throw 传入的异常，则会往前执行到下一个 yield 处，并且将那个 yield 的返回值作为 throw 的返回值。上述代码一个有意思的地方是，GeneratorExit 会在程序结束时自动调用，一般还是来说不用主动处理该异常。</p><h2 id="yield-from"><a href="#yield-from" class="headerlink" title="yield from"></a>yield from</h2><p>yield from 是一个 Python3.3 之后新增的 <a href="https://docs.python.org/3/whatsnew/3.3.html#pep-380">语法</a>，对于简单的生成器，<code>yield from iterable</code> 是这个 <code>for item in iterable: yield item</code> 的缩写。下面举一个简单的例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> inspect<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">adder</span>():<br>    <span class="hljs-string">&#x27;&#x27;&#x27; 子生成器</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    ret = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        n = <span class="hljs-keyword">yield</span><br>        <span class="hljs-keyword">if</span> n <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">break</span><br>        ret += n<br>    <span class="hljs-comment"># 作为 yield from 的返回值</span><br>    <span class="hljs-comment"># 一般的生成器 send(None) 之后将抛出 StopIteration 的异常</span><br>    <span class="hljs-keyword">return</span> ret  <span class="hljs-comment"># 作为 yield from 的返回值</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">worker</span>(<span class="hljs-params">result, key</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27; 委派生成器</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        rv = <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> adder()<br>        result[key] = rv<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-string">&#x27;&#x27;&#x27; 调用方</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    result = &#123;&#125;<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>):<br>        w = worker(result, i)<br>        <span class="hljs-comment"># 这里每次都会新建一个委派生成器，原因是为了传入 i 作为 reuslt 的 key 值</span><br>        <span class="hljs-comment"># 实际上也可以放到循环外，result 改成 list 就好</span><br>        <span class="hljs-built_in">next</span>(w)<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i, i+<span class="hljs-number">3</span>):<br>            w.send(j)<br>        w.send(<span class="hljs-literal">None</span>)<br>        <span class="hljs-comment"># 这里 send None 之后委派生成器会更新 reuslt 的值，再起另一个生成器继续等待</span><br>        <span class="hljs-built_in">print</span>(inspect.getgeneratorstate(w))  <span class="hljs-comment"># GEN_SUSPENDED</span><br>    <span class="hljs-built_in">print</span>(result)<br><br>main()<br></code></pre></td></tr></table></figure><p>上述代码就简单的演示了下 yield from 是怎么工作的。yield from 的实际功能相当复杂，这里篇幅有限就不展开来讲。</p><p>这里面比较关键的是，委派生成器（即介于调用者和子生成器中间的函数）对于 send 的处理。通过委派生成器调用 send 都会直接传给子生成器，send(None) 时，会调用子生成器的 __next__ 方法，send 的参数不为 None 则调用子生成器的 send 方法。</p><p>如果子生成器抛出的异常为 StopIteration，那么委派生成器恢复执行，其它异常则照常抛出，需要委派生成器自己去处理。子生成器退出时，return expr 语句将会触发 StopIteration(expr) 的异常。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>以前写代码的时候比较少用 yield 这个语法，单纯的 yield 还好，如果是加上类似协程的相关代码后，就感觉难以理解了。相比 return 处理起来就习惯多了，学习的时候也更多是知道这个语法的用法。</p><p>后来 Python3 之后很多接口改成了迭代器的模式，自己才开始去看类似的代码，写了下感觉还好，用来处理数据生成和逻辑代码的解耦真是太舒服了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.python.org/dev/peps/pep-0255/">PEP-255</a></li><li><a href="https://www.python.org/dev/peps/pep-0380/">PEP-380</a></li><li><a href="http://stackoverflow.com/questions/9708902/in-practice-what-are-the-main-uses-for-the-new-yield-from-syntax-in-python-3">Stackoverflow 上一个关于 Python3 yield from 语法的问题</a></li><li><a href="http://flupy.org/resources/yield-from.pdf">Python3 yield from 解析</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 分区实践</title>
    <link href="/2017/08/26/mysql-partitions/"/>
    <url>/2017/08/26/mysql-partitions/</url>
    
    <content type="html"><![CDATA[<p>在项目中有需要优化之前有涉及分区的表，这里记录下不同的分区方法的相关测试。</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>在未来，native 的分区功能会被移除，只有在 InnoDB 和 NDB 才会继续保存该功能，本文是以 InnoDB 为例进行说明。简单来说，分区是指在根据表的某种用户自定义的规则，将数据分到不同的物理存储的文件中。在外部看来，这个表还是一样的，只是在 query 的时候，会根据具体的分区规则查询具体的分区。</p><h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> `origin` (<br>    a <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span>,<br>    b <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) UNSIGNED <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    c <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) UNSIGNED <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    d <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) UNSIGNED <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    e tinyint(<span class="hljs-number">4</span>) UNSIGNED <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    f <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) UNSIGNED <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    g <span class="hljs-type">char</span>(<span class="hljs-number">2</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    h <span class="hljs-type">date</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-keyword">PRIMARY</span> KEY (`a`,`b`,`c`,`d`,`e`,`f`,`g`,`h`) <span class="hljs-keyword">USING</span> BTREE,<br>    KEY `aid<span class="hljs-operator">-</span>country` (`a`,`g`) <span class="hljs-keyword">USING</span> BTREE,<br>    KEY `ctid<span class="hljs-operator">-</span>country` (`b`,`g`) <span class="hljs-keyword">USING</span> BTREE,<br>    KEY `product<span class="hljs-operator">-</span>country` (`c`,`g`) <span class="hljs-keyword">USING</span> BTREE<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8<br><span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> LINEAR HASH (<span class="hljs-keyword">YEAR</span>(`h`) <span class="hljs-operator">*</span> <span class="hljs-number">10000</span> <span class="hljs-operator">+</span> <span class="hljs-keyword">MONTH</span>(`h`) <span class="hljs-operator">*</span> <span class="hljs-number">100</span> <span class="hljs-operator">+</span> <span class="hljs-keyword">DAY</span>(`h`))<br>PARTITIONS <span class="hljs-number">8</span>;<br></code></pre></td></tr></table></figure><p>旨在优化的原始表的大体结构如上。里面的字段与实际表相比，只是少了部分的数据字段，索引和分区策略是一样的。当前的问题是，在这样子的分区策略下，查询的效率低下（特别是对 h 字段的跨日 \ 跨月查询），常见的是会去通过 h 做范围查询。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">mysql&gt; <span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> origin <span class="hljs-keyword">where</span> c = <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> g = <span class="hljs-string">&#x27;AD&#x27;</span> <span class="hljs-keyword">and</span> h = <span class="hljs-string">&#x27;2017-01-02&#x27;</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">1</span> \G;<br>*************************** <span class="hljs-number">1.</span> <span class="hljs-keyword">row</span> ***************************<br>           id: <span class="hljs-number">1</span><br>  select_type: SIMPLE<br>        <span class="hljs-keyword">table</span>: origin<br>   partitions: p6<br>         <span class="hljs-keyword">type</span>: <span class="hljs-keyword">ref</span><br>possible_keys: product-country<br>          key: product-country<br>      key_len: <span class="hljs-number">10</span><br>          <span class="hljs-keyword">ref</span>: const,const<br>         <span class="hljs-keyword">rows</span>: <span class="hljs-number">5</span><br>     filtered: <span class="hljs-number">10.00</span><br>        Extra: <span class="hljs-keyword">Using</span> <span class="hljs-keyword">where</span>; <span class="hljs-keyword">Using</span> <span class="hljs-keyword">index</span><br><span class="hljs-number">1</span> <span class="hljs-keyword">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span>, <span class="hljs-number">1</span> <span class="hljs-built_in">warning</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">mysql&gt; <span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> origin <span class="hljs-keyword">where</span> c = <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> g = <span class="hljs-string">&#x27;AD&#x27;</span> <span class="hljs-keyword">and</span> h &gt; <span class="hljs-string">&#x27;2017-01-02&#x27;</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">1</span> \G;<br>*************************** <span class="hljs-number">1.</span> <span class="hljs-keyword">row</span> ***************************<br>           id: <span class="hljs-number">1</span><br>  select_type: SIMPLE<br>        <span class="hljs-keyword">table</span>: origin<br>   partitions: p0,p1,p2,p3,p4,p5,p6,p7<br>         <span class="hljs-keyword">type</span>: <span class="hljs-keyword">ref</span><br>possible_keys: product-country<br>          key: product-country<br>      key_len: <span class="hljs-number">10</span><br>          <span class="hljs-keyword">ref</span>: const,const<br>         <span class="hljs-keyword">rows</span>: <span class="hljs-number">45</span><br>     filtered: <span class="hljs-number">33.33</span><br>        Extra: <span class="hljs-keyword">Using</span> <span class="hljs-keyword">where</span>; <span class="hljs-keyword">Using</span> <span class="hljs-keyword">index</span><br><span class="hljs-number">1</span> <span class="hljs-keyword">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span>, <span class="hljs-number">1</span> <span class="hljs-built_in">warning</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><p>origin 表的测试数据为 99999 条，上面的结果可以看到，两个语句都能使用到索引，但是不同的是，后者需要扫所有的分区，以至于其所扫的 rows 比前者多。这里我们可以得出结论</p><ol><li>hash 分区的字段不适合范围或者比较查询，如果在 where 条件中涉及到 hash；</li><li>所涉及的字段，应该使用相等判断（不等于也不行）索引是在分区之后的数据范围内查询。</li></ol><h2 id="上述的测试结果与我们日常的使用经验相吻合，我们希望找到方法可以做范围查询。range-分区"><a href="#上述的测试结果与我们日常的使用经验相吻合，我们希望找到方法可以做范围查询。range-分区" class="headerlink" title="上述的测试结果与我们日常的使用经验相吻合，我们希望找到方法可以做范围查询。range 分区"></a>上述的测试结果与我们日常的使用经验相吻合，我们希望找到方法可以做范围查询。<br><br>range 分区</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> `month_field` (<br>    a <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span>,<br>    b <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) UNSIGNED <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    c <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) UNSIGNED <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    d <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) UNSIGNED <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    e tinyint(<span class="hljs-number">4</span>) UNSIGNED <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    f <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) UNSIGNED <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    g <span class="hljs-type">char</span>(<span class="hljs-number">2</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    h <span class="hljs-type">date</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    m <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-keyword">PRIMARY</span> KEY (`a`,`b`,`c`,`d`,`e`,`f`,`g`,`h`, `m`) <span class="hljs-keyword">USING</span> BTREE,<br>    KEY `aid<span class="hljs-operator">-</span>country` (`a`,`g`) <span class="hljs-keyword">USING</span> BTREE,<br>    KEY `ctid<span class="hljs-operator">-</span>country` (`b`,`g`) <span class="hljs-keyword">USING</span> BTREE,<br>    KEY `product<span class="hljs-operator">-</span>country` (`c`,`g`) <span class="hljs-keyword">USING</span> BTREE<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8<br><span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">RANGE</span>(m) (<br>    <span class="hljs-keyword">PARTITION</span> p0 <span class="hljs-keyword">VALUES</span> LESS THAN (<span class="hljs-number">201701</span>),<br>    <span class="hljs-keyword">PARTITION</span> p1 <span class="hljs-keyword">VALUES</span> LESS THAN (<span class="hljs-number">201702</span>),<br>    <span class="hljs-keyword">PARTITION</span> p2 <span class="hljs-keyword">VALUES</span> LESS THAN (<span class="hljs-number">201703</span>),<br>    <span class="hljs-keyword">PARTITION</span> p3 <span class="hljs-keyword">VALUES</span> LESS THAN (<span class="hljs-number">201704</span>),<br>    <span class="hljs-keyword">PARTITION</span> p4 <span class="hljs-keyword">VALUES</span> LESS THAN (<span class="hljs-number">201705</span>),<br>    <span class="hljs-keyword">PARTITION</span> p5 <span class="hljs-keyword">VALUES</span> LESS THAN (<span class="hljs-number">201706</span>),<br>    <span class="hljs-keyword">PARTITION</span> p6 <span class="hljs-keyword">VALUES</span> LESS THAN (<span class="hljs-number">201707</span>),<br>    <span class="hljs-keyword">PARTITION</span> p7 <span class="hljs-keyword">VALUES</span> LESS THAN MAXVALUE<br>);<br></code></pre></td></tr></table></figure><p>上述 SQL 是另一种分区模式，通过 range 分区，与 hash 不同的是，其需要指定某些字段具体的范围确定到某个分区。month_field 这个表与之前的相比，只是加多了一个 m 字段来存相应的月份的信息，如 201701。</p><p>这里需要注意的是这个新增的 m 字段也加到了主键中，原因是 MySQL  本身有约束，用于分区的字段，<a href="https://dev.mysql.com/doc/refman/5.7/en/partitioning-limitations-partitioning-keys-unique-keys.html">必须在所有的唯一索引列</a>。</p><blockquote><p>every unique key on the table must use every column in the table’s partitioning expression.</p></blockquote><p>下面测试范围查找和精确查找</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">mysql&gt; <span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> month_field <span class="hljs-keyword">where</span> c = <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> g = <span class="hljs-string">&#x27;AD&#x27;</span> <span class="hljs-keyword">and</span> m &lt;= <span class="hljs-number">201703</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">1</span> \G;<br>*************************** <span class="hljs-number">1.</span> <span class="hljs-keyword">row</span> ***************************<br>           id: <span class="hljs-number">1</span><br>  select_type: SIMPLE<br>        <span class="hljs-keyword">table</span>: month_field<br>   partitions: p0,p1,p2,p3<br>         <span class="hljs-keyword">type</span>: <span class="hljs-keyword">ref</span><br>possible_keys: product-country<br>          key: product-country<br>      key_len: <span class="hljs-number">10</span><br>          <span class="hljs-keyword">ref</span>: const,const<br>         <span class="hljs-keyword">rows</span>: <span class="hljs-number">2</span><br>     filtered: <span class="hljs-number">33.33</span><br>        Extra: <span class="hljs-keyword">Using</span> <span class="hljs-keyword">where</span>; <span class="hljs-keyword">Using</span> <span class="hljs-keyword">index</span><br><span class="hljs-number">1</span> <span class="hljs-keyword">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span>, <span class="hljs-number">1</span> <span class="hljs-built_in">warning</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">mysql&gt; <span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> month_field <span class="hljs-keyword">where</span> c = <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> g = <span class="hljs-string">&#x27;AD&#x27;</span> <span class="hljs-keyword">and</span> m = <span class="hljs-number">201703</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">1</span> \G;<br>*************************** <span class="hljs-number">1.</span> <span class="hljs-keyword">row</span> ***************************<br>           id: <span class="hljs-number">1</span><br>  select_type: SIMPLE<br>        <span class="hljs-keyword">table</span>: month_field<br>   partitions: p3<br>         <span class="hljs-keyword">type</span>: <span class="hljs-keyword">ref</span><br>possible_keys: product-country<br>          key: product-country<br>      key_len: <span class="hljs-number">10</span><br>          <span class="hljs-keyword">ref</span>: const,const<br>         <span class="hljs-keyword">rows</span>: <span class="hljs-number">1</span><br>     filtered: <span class="hljs-number">10.00</span><br>        Extra: <span class="hljs-keyword">Using</span> <span class="hljs-keyword">where</span>; <span class="hljs-keyword">Using</span> <span class="hljs-keyword">index</span><br><span class="hljs-number">1</span> <span class="hljs-keyword">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span>, <span class="hljs-number">1</span> <span class="hljs-built_in">warning</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><p>第一个查询可以看出来，对其是用范围查询，也能根据分区策略只查对应的分区而不用像 hash 那样去扫全部的分区。同样的精确查找能去到指定的分区。与 hash 相比，这种分区策略适合有范围并且分布均衡的数据。后期也可以根据需要定期扩展分区。</p><h2 id="range-中二次计算"><a href="#range-中二次计算" class="headerlink" title="range 中二次计算"></a>range 中二次计算</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> `origin` (<br>    a <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span>,<br>    b <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) UNSIGNED <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    c <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) UNSIGNED <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    d <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) UNSIGNED <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    e tinyint(<span class="hljs-number">4</span>) UNSIGNED <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    f <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) UNSIGNED <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    g <span class="hljs-type">char</span>(<span class="hljs-number">2</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    h <span class="hljs-type">date</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-keyword">PRIMARY</span> KEY (`a`,`b`,`c`,`d`,`e`,`f`,`g`,`h`) <span class="hljs-keyword">USING</span> BTREE,<br>    KEY `aid<span class="hljs-operator">-</span>country` (`a`,`g`) <span class="hljs-keyword">USING</span> BTREE,<br>    KEY `ctid<span class="hljs-operator">-</span>country` (`b`,`g`) <span class="hljs-keyword">USING</span> BTREE,<br>    KEY `product<span class="hljs-operator">-</span>country` (`c`,`g`) <span class="hljs-keyword">USING</span> BTREE<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8<br><span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">RANGE</span>(<span class="hljs-keyword">YEAR</span>(`h`)<span class="hljs-operator">*</span><span class="hljs-number">100</span> <span class="hljs-operator">+</span> <span class="hljs-keyword">MONTH</span>(`h`)) (<br>    <span class="hljs-keyword">PARTITION</span> p0 <span class="hljs-keyword">VALUES</span> LESS THAN (<span class="hljs-number">201701</span>),<br>    <span class="hljs-keyword">PARTITION</span> p1 <span class="hljs-keyword">VALUES</span> LESS THAN (<span class="hljs-number">201702</span>),<br>    <span class="hljs-keyword">PARTITION</span> p2 <span class="hljs-keyword">VALUES</span> LESS THAN (<span class="hljs-number">201703</span>),<br>    <span class="hljs-keyword">PARTITION</span> p3 <span class="hljs-keyword">VALUES</span> LESS THAN (<span class="hljs-number">201704</span>),<br>    <span class="hljs-keyword">PARTITION</span> p4 <span class="hljs-keyword">VALUES</span> LESS THAN (<span class="hljs-number">201705</span>),<br>    <span class="hljs-keyword">PARTITION</span> p5 <span class="hljs-keyword">VALUES</span> LESS THAN (<span class="hljs-number">201706</span>),<br>    <span class="hljs-keyword">PARTITION</span> p6 <span class="hljs-keyword">VALUES</span> LESS THAN (<span class="hljs-number">201707</span>),<br>    <span class="hljs-keyword">PARTITION</span> p7 <span class="hljs-keyword">VALUES</span> LESS THAN MAXVALUE<br>);<br></code></pre></td></tr></table></figure><p>这里有一种特殊情况，在 range 中的值如果是是通过某些字段的值二次运算算出来的话，范围查询时也是会扫所有的分区。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">mysql&gt; <span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> origin <span class="hljs-keyword">where</span> c = <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> g = <span class="hljs-string">&#x27;AD&#x27;</span> <span class="hljs-keyword">and</span> h &gt;= <span class="hljs-string">&#x27;2017-06-24&#x27;</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">1</span> \G;<br>*************************** <span class="hljs-number">1.</span> <span class="hljs-keyword">row</span> ***************************<br>           id: <span class="hljs-number">1</span><br>  select_type: SIMPLE<br>        <span class="hljs-keyword">table</span>: origin<br>   partitions: p0,p1,p2,p3,p4,p5,p6,p7<br>         <span class="hljs-keyword">type</span>: <span class="hljs-keyword">ref</span><br>possible_keys: product-country<br>          key: product-country<br>      key_len: <span class="hljs-number">10</span><br>          <span class="hljs-keyword">ref</span>: const,const<br>         <span class="hljs-keyword">rows</span>: <span class="hljs-number">43</span><br>     filtered: <span class="hljs-number">33.33</span><br>        Extra: <span class="hljs-keyword">Using</span> <span class="hljs-keyword">where</span>; <span class="hljs-keyword">Using</span> <span class="hljs-keyword">index</span><br><span class="hljs-number">1</span> <span class="hljs-keyword">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span>, <span class="hljs-number">1</span> <span class="hljs-built_in">warning</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><h2 id="list-分区"><a href="#list-分区" class="headerlink" title="list 分区"></a>list 分区</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> `list` (<br>    a <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span>,<br>    b <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) UNSIGNED <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    c <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) UNSIGNED <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    d <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) UNSIGNED <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    e tinyint(<span class="hljs-number">4</span>) UNSIGNED <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    f <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) UNSIGNED <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    g <span class="hljs-type">char</span>(<span class="hljs-number">2</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    h <span class="hljs-type">date</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    m <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-keyword">PRIMARY</span> KEY (`a`,`b`,`c`,`d`,`e`,`f`,`g`,`h`, `m`) <span class="hljs-keyword">USING</span> BTREE,<br>    KEY `aid<span class="hljs-operator">-</span>country` (`a`,`g`) <span class="hljs-keyword">USING</span> BTREE,<br>    KEY `ctid<span class="hljs-operator">-</span>country` (`b`,`g`) <span class="hljs-keyword">USING</span> BTREE,<br>    KEY `product<span class="hljs-operator">-</span>country` (`c`,`g`) <span class="hljs-keyword">USING</span> BTREE<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8<br><span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> LIST COLUMNS(m) (<br>    <span class="hljs-keyword">PARTITION</span> p0 <span class="hljs-keyword">VALUES</span> <span class="hljs-keyword">IN</span> (<span class="hljs-number">201701</span>, <span class="hljs-number">201702</span>, <span class="hljs-number">201703</span>, <span class="hljs-number">201704</span>, <span class="hljs-number">201705</span>, <span class="hljs-number">201706</span>, <span class="hljs-number">201707</span>, <span class="hljs-number">201708</span>, <span class="hljs-number">201709</span>, <span class="hljs-number">201710</span>, <span class="hljs-number">201711</span>, <span class="hljs-number">201712</span>),<br>    <span class="hljs-keyword">PARTITION</span> p1 <span class="hljs-keyword">VALUES</span> <span class="hljs-keyword">IN</span> (<span class="hljs-number">201801</span>, <span class="hljs-number">201802</span>, <span class="hljs-number">201803</span>, <span class="hljs-number">201804</span>, <span class="hljs-number">201805</span>, <span class="hljs-number">201806</span>, <span class="hljs-number">201807</span>, <span class="hljs-number">201808</span>, <span class="hljs-number">201809</span>, <span class="hljs-number">201810</span>, <span class="hljs-number">201811</span>, <span class="hljs-number">201812</span>),<br>    <span class="hljs-keyword">PARTITION</span> p2 <span class="hljs-keyword">VALUES</span> <span class="hljs-keyword">IN</span> (<span class="hljs-number">201901</span>, <span class="hljs-number">201902</span>, <span class="hljs-number">201903</span>, <span class="hljs-number">201904</span>, <span class="hljs-number">201905</span>, <span class="hljs-number">201906</span>, <span class="hljs-number">201907</span>, <span class="hljs-number">201908</span>, <span class="hljs-number">201909</span>, <span class="hljs-number">201910</span>, <span class="hljs-number">201911</span>, <span class="hljs-number">201912</span>),<br>    <span class="hljs-keyword">PARTITION</span> p3 <span class="hljs-keyword">VALUES</span> <span class="hljs-keyword">IN</span> (<span class="hljs-number">202001</span>, <span class="hljs-number">202002</span>, <span class="hljs-number">202003</span>, <span class="hljs-number">202004</span>, <span class="hljs-number">202005</span>, <span class="hljs-number">202006</span>, <span class="hljs-number">202007</span>, <span class="hljs-number">202008</span>, <span class="hljs-number">202009</span>, <span class="hljs-number">202010</span>, <span class="hljs-number">202011</span>, <span class="hljs-number">202012</span>),<br>    <span class="hljs-keyword">PARTITION</span> p4 <span class="hljs-keyword">VALUES</span> <span class="hljs-keyword">IN</span> (<span class="hljs-number">202101</span>, <span class="hljs-number">202102</span>, <span class="hljs-number">202103</span>, <span class="hljs-number">202104</span>, <span class="hljs-number">202105</span>, <span class="hljs-number">202106</span>, <span class="hljs-number">202107</span>, <span class="hljs-number">202108</span>, <span class="hljs-number">202109</span>, <span class="hljs-number">202110</span>, <span class="hljs-number">202111</span>, <span class="hljs-number">202112</span>),<br>    <span class="hljs-keyword">PARTITION</span> p5 <span class="hljs-keyword">VALUES</span> <span class="hljs-keyword">IN</span> (<span class="hljs-number">202201</span>, <span class="hljs-number">202202</span>, <span class="hljs-number">202203</span>, <span class="hljs-number">202204</span>, <span class="hljs-number">202205</span>, <span class="hljs-number">202206</span>, <span class="hljs-number">202207</span>, <span class="hljs-number">202208</span>, <span class="hljs-number">202209</span>, <span class="hljs-number">202210</span>, <span class="hljs-number">202211</span>, <span class="hljs-number">202212</span>)<br>);<br></code></pre></td></tr></table></figure><p>list 的分区精确查询和范围查询都能使用其分区策略</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">mysql&gt; <span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> list <span class="hljs-keyword">where</span> c = <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> g = <span class="hljs-string">&#x27;AD&#x27;</span> <span class="hljs-keyword">and</span> m <span class="hljs-keyword">between</span> <span class="hljs-number">201701</span> <span class="hljs-keyword">and</span> <span class="hljs-number">201803</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">1</span> \G;<br>*************************** <span class="hljs-number">1.</span> <span class="hljs-keyword">row</span> ***************************<br>           id: <span class="hljs-number">1</span><br>  select_type: SIMPLE<br>        <span class="hljs-keyword">table</span>: list<br>   partitions: p0,p1<br>         <span class="hljs-keyword">type</span>: <span class="hljs-keyword">ref</span><br>possible_keys: product-country<br>          key: product-country<br>      key_len: <span class="hljs-number">10</span><br>          <span class="hljs-keyword">ref</span>: const,const<br>         <span class="hljs-keyword">rows</span>: <span class="hljs-number">12</span><br>     filtered: <span class="hljs-number">11.11</span><br>        Extra: <span class="hljs-keyword">Using</span> <span class="hljs-keyword">where</span>; <span class="hljs-keyword">Using</span> <span class="hljs-keyword">index</span><br><span class="hljs-number">1</span> <span class="hljs-keyword">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span>, <span class="hljs-number">1</span> <span class="hljs-built_in">warning</span> (<span class="hljs-number">0.01</span> sec)<br></code></pre></td></tr></table></figure><p>从建表语句可以看到，分区的字段的值是明确的，如果插入的数据不在指定的数据内，会报错。与 range 相比，你的数据分区可以由你自己指定，但是不能选择 MAXVALUE 类似的值，所以你必须提前规划好所有可能的值，包括是否分配均匀也是由自己确定。</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">mysql&gt; insert into list values (1, 2 ,3 ,4, 5, 6, &#x27;CN&#x27;, &#x27;2050<span class="hljs-string">-06</span><span class="hljs-string">-06</span>&#x27;, 205006);<br><span class="hljs-keyword">ERROR </span>1526 (HY000): Table has no partition for value from column_list<br></code></pre></td></tr></table></figure><h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>在分区之后，也可以通过相应的语句查询分区是否平均</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><br><span class="hljs-section">mysql&gt; select PARTITION_NAME, TABLE_ROWS FROM INFORMATION_SCHEMA.PARTITIONS where table_name = &#x27;origin&#x27;;</span><br><span class="hljs-section">+----------------+------------+</span><br><span class="hljs-section">| PARTITION_NAME | TABLE_ROWS |</span><br><span class="hljs-section">+----------------+------------+</span><br>| p0             |      11520 |<br>| p1             |      13152 |<br>| p2             |      13152 |<br>| p3             |      12640 |<br>| p4             |      11472 |<br>| p5             |      12911 |<br>| p6             |      12864 |<br><span class="hljs-section">| p7             |      12288 |</span><br><span class="hljs-section">+----------------+------------+</span><br></code></pre></td></tr></table></figure><p>这里主要讲了三种分区策略，其实 hash 还包括另一种简单的 hash ，我测试中用的是 liner hash，可以理解为更为平均的 hash，文档可见 这里。三种分区的策略简单如下</p><ul><li>hash：适用于数据范围较分散或者说暂不明确上下限，最后的查询也不涉及范围查询的情况；</li><li>range：适合于数据需要范围查询的，并且需要数据的分布也分区的字段有关；</li><li>list：适用于数据范围明确的，数据范围需要自己去控制。</li></ul><p>与 hash 相比，range 和 list 也都是后期通过增加相应的分区而不移动数据的，如果是 hash 修改分区策略的话就会涉及到数据的移动</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mysql</span>&gt; alter table `origin` partition by linear hash(YEAR(`h`)) partitions <span class="hljs-number">2</span>;<br><span class="hljs-attribute">Query</span> OK, <span class="hljs-number">99999</span> rows affected (<span class="hljs-number">15</span>.<span class="hljs-number">25</span> sec)<br><br><span class="hljs-attribute">mysql</span>&gt; alter table `list` ADD partition (partition p6 values IN (<span class="hljs-number">202301</span>, <span class="hljs-number">202302</span>));<br><span class="hljs-attribute">Query</span> OK, <span class="hljs-number">0</span> rows affected (<span class="hljs-number">0</span>.<span class="hljs-number">94</span> sec)<br><span class="hljs-attribute">Records</span>: <span class="hljs-number">0</span>  Duplicates: <span class="hljs-number">0</span>  Warnings: <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>还有需要注意的是，如果在 range 中使用了 MAXVALUE 的话，该分区必须是最后一个分区的定义，并且你也不能往这个表加分区了</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">mysql&gt; alter table `month_field` ADD partition (partition p61 values less than(201708));<br><span class="hljs-keyword">ERROR </span>1481 (HY000): MAXVALUE can only be used in last partition definition<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://dev.mysql.com/doc/refman/5.7/en/partitioning.html">MySQL 5.7 分区模块文档</a></li><li><a href="http://haitian299.github.io/2016/05/26/mysql-partitioning/">分区，分表，分库的应用场景</a></li><li><a href="https://dev.mysql.com/doc/refman/5.7/en/alter-table-partition-operations.html">修改 MySQL 表分区</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>mysql</tag>
      
      <tag>partitions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 中的虚拟基类</title>
    <link href="/2017/06/17/python-abstact-class/"/>
    <url>/2017/06/17/python-abstact-class/</url>
    
    <content type="html"><![CDATA[<p>Python 这类动态类型语言，Duck Typing 是一个比较突出的优点。属性，方法的惰性计算，给代码的编写带来了高度的灵活性。当然有利有弊，Duck Typing 这东西在 Python 中更多是一种规范，而不是强制约束。如果我们需要约束这些接口，需要做些什么呢？</p><h2 id="运行时检查"><a href="#运行时检查" class="headerlink" title="运行时检查"></a>运行时检查</h2><p>下面看一下简单的例子，这是个比较常见的场景，通过基类定义了一系列的接口，然后继承的子类根据自己特定的需求实现具体的接口。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">action</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">raise</span> NotImplementedError()<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bird</span>(<span class="hljs-title class_ inherited__">Animal</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">action</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;fly&quot;</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-title class_ inherited__">Animal</span>):<br>    <span class="hljs-keyword">pass</span><br><br>bird = Bird()<br>dog = Dog()<br><br>animals = [Bird(), Dog()]<br><span class="hljs-keyword">for</span> animal <span class="hljs-keyword">in</span> animals:<br>    <span class="hljs-built_in">print</span>(animal.action())<br><br><span class="hljs-comment"># 输出如下：</span><br><span class="hljs-comment"># fly</span><br><span class="hljs-comment"># Traceback (most recent call last):</span><br><span class="hljs-comment">#  File &quot;test.py&quot;, line 22, in &lt;module&gt;</span><br><span class="hljs-comment">#    print(animal.action())</span><br><span class="hljs-comment">#  File &quot;test.py&quot;, line 4, in action</span><br><span class="hljs-comment">#    raise NotImplementedError()</span><br><span class="hljs-comment"># NotImplementedError</span><br></code></pre></td></tr></table></figure><p>我们可以看到，Animal 的 action 的确是会抛出异常，但如果子类实现了该方法，则相应的方法查找则会屏蔽掉基类的该方法而使用自己当前的版本。</p><p>这的确是能实现简单的抽象方法的概念，但是，该错误直到运行时才能暴露出来。极端点的情况，你可能还要去判断这个 name 是否可以调用，调用的参数对不对。</p><h2 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h2><p>Python 本身是支持抽象基类的，最常用的是 collections 里面提供的一些抽象类。如常见的用于判断类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> collections<br><span class="hljs-built_in">isinstance</span>([], collections.MutableSequence) <span class="hljs-comment"># True</span><br><br><span class="hljs-comment"># 还有数类型</span><br><span class="hljs-keyword">import</span> numbers<br><span class="hljs-built_in">isinstance</span>(<span class="hljs-number">12313.123</span>, numbers.Number) <span class="hljs-comment"># True</span><br></code></pre></td></tr></table></figure><p>如果我们用来实现序列，那就更简单了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> collections<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sequence</span>(collections.MutableSequence):<br>    <span class="hljs-keyword">pass</span><br><br>seq = <span class="hljs-type">Sequence</span>()<br><br><span class="hljs-comment"># Traceback (most recent call last):</span><br><span class="hljs-comment">#   File &quot;test.py&quot;, line 8, in &lt;module&gt;</span><br><span class="hljs-comment">#     seq = Sequence()</span><br><span class="hljs-comment"># TypeError: Can&#x27;t instantiate abstract class Sequence with abstract methods # __delitem__, __getitem__, __len__, __setitem__, insert</span><br></code></pre></td></tr></table></figure><p>跟之前的代码相比，这个是在实例化的时候进行检查的，你继承了某些抽象类之后，在实例化的时候，会去检查是否有实现具体的方法。collections 中还有其它的基础类型的抽象类，如果要实现相应协议的话，可以去看看。</p><h2 id="自定义抽象类"><a href="#自定义抽象类" class="headerlink" title="自定义抽象类"></a>自定义抽象类</h2><p>同样的，我们也可以实现自己的抽象基类，然后通过具体的子类去定义具体的行为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> abc<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>(abc.ABC):<br><span class="hljs-meta">    @abc.abstractmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">name</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27; just docs</span><br><span class="hljs-string">        &#x27;&#x27;&#x27;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Base&quot;</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>(<span class="hljs-title class_ inherited__">Base</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">name</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self.__class__.__name__<br><br>a = A()<br><span class="hljs-built_in">print</span>(a.name())<br></code></pre></td></tr></table></figure><p>上述代码中，如果类 A 不定义 name 的方法，则会抛出 TypeError 的异常。但实际上，如果我们去修改 Base 中 name 的函数签名，例如加个参数什么的，上述代码依旧是能正常运行的。这样子的话，其实 Python 本身支持的抽象方法只是检验是否有这个可调用的类成员。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>(<span class="hljs-title class_ inherited__">Base</span>):<br>    name = <span class="hljs-built_in">print</span><br>    <span class="hljs-comment"># name = 1</span><br>    <span class="hljs-comment"># TypeError: &#x27;int&#x27; object is not callable</span><br></code></pre></td></tr></table></figure><h2 id="再看鸭子类型"><a href="#再看鸭子类型" class="headerlink" title="再看鸭子类型"></a>再看鸭子类型</h2><p>最开始接触 Python 的时候，觉得这一特性很好用啊，例如我要处理一大串对象，只要里面的对象实现了这个方法，就可以都扔到同一个队列里面进行处理，但这个东西很容易滥用。如果你在处理之后需要相应的回调，这又必须跑去实现回调函数，但因为函数调用的检查是在处理该对象的时候，如果忘了某些对象的相应方法，可能最后上线才能发现问题。</p><p>接触了一阵子的 golang，使用 interface 之后简直如沐春风，运行时的错误在编译阶段就能避免了，减少了很多查 bug 的时间。在这一点上，如果需要使用类似的特性，python 对程序员的能力要求反而更高了。</p><p>我个人比较推崇先去判断这个对象是什么类型，如判断它是不是可以迭代的，可调用的，这样子，你就知道了该对象支持什么样的方法。如果不行再去判断是否实现了具体的方法。当然，运行时去判断这些东西是有消耗的，具体的需要就要看业务场景了。</p><p>灵活是抛弃了一些约束的结果，没有了约束效率就会低下，哪样较好没有绝对的定论。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://docs.python.org/3/library/abc.html">Python abc 库的文档</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python3 字符串问题</title>
    <link href="/2017/05/17/python3-str-bytes/"/>
    <url>/2017/05/17/python3-str-bytes/</url>
    
    <content type="html"><![CDATA[<p>在写代码的时候遇到一个比较奇怪的问题，精简之后的代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> redis<br><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">from</span> urllib.parse <span class="hljs-keyword">import</span> urlparse<br><span class="hljs-keyword">except</span>:<br>    <span class="hljs-keyword">from</span> urlparse <span class="hljs-keyword">import</span> urlparse<br><br>key = <span class="hljs-string">&#x27;baidu&#x27;</span><br>val = <span class="hljs-string">&#x27;http://www.baidu.com&#x27;</span><br>schemes = [<span class="hljs-string">&#x27;http&#x27;</span>, <span class="hljs-string">&#x27;https&#x27;</span>, <span class="hljs-string">&#x27;socks&#x27;</span>]<br><br>rdb = redis.StrictRedis(host=<span class="hljs-string">&#x27;localhost&#x27;</span>, port=<span class="hljs-number">6379</span>, db=<span class="hljs-number">0</span>)<br>rdb.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;baidu&#x27;</span>, <span class="hljs-string">&#x27;http://www.baidu.com&#x27;</span>)<br><br>url = rdb.get(<span class="hljs-string">&#x27;baidu&#x27;</span>)<br><span class="hljs-comment"># print(type(url))</span><br>o = urlparse(url)<br><br><span class="hljs-built_in">print</span>(o.scheme <span class="hljs-keyword">in</span> schemes)<br></code></pre></td></tr></table></figure><p>上述代码初看之下没有问题，但是在 Python3 中跑的话与在 Python2 中跑的结果不一样。Python3 中输出 False，Python2 中输出 True。</p><p>为什么呢？</p><h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><p>上述问题是由 Python3 中 str 和 bytes 造成的。与 Python2 相比，Python3 的字符串类型改成了 str 和 bytes，其中 str 相当于 Python2 的 unicode，bytes 相当于 Python2 的 str。从 redis 中拿回的数据是 bytes 类型，bytes 类型的与 list 中的 str 去比较则是永远都是 False。</p><p>在 Python2 中，unicode 和 str 的混合使用会有隐式的类型转换，Python3 中则是完全两种类型，不存在比较的可能性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">u&#x27;&#x27;</span> == <span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment"># Python2 -&gt; True</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">b&#x27;&#x27;</span> == <span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment"># Python3 -&gt; False</span><br></code></pre></td></tr></table></figure><p>Python2 中的 unicode 和 str 实际上都继承于 basestring</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># python2</span><br><span class="hljs-built_in">isinstance</span>(<span class="hljs-string">&#x27;&#x27;</span>, basestring) <span class="hljs-comment"># True</span><br><span class="hljs-built_in">isinstance</span>(<span class="hljs-string">u&#x27;&#x27;</span>, basestring) <span class="hljs-comment"># True</span><br></code></pre></td></tr></table></figure><p>在 Python2 中处理字符串编码问题的时候，经常会让人感到疑惑，我究竟是要调用 decode 方法还是 encode 方法呢？哪怕你混用 decode 方法和 encode 方法都是没有问题的，不会有异常抛出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># python2</span><br>s = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(s)) <span class="hljs-comment"># str</span><br>s.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-comment"># 错误调用，不会报错</span><br>s.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-comment"># 正确调用</span><br></code></pre></td></tr></table></figure><p>但在 Python3 环境中，这两个类型就完全不同了。</p><h2 id="Python3-中的正确用法"><a href="#Python3-中的正确用法" class="headerlink" title="Python3 中的正确用法"></a>Python3 中的正确用法</h2><p>你如果去查看 Python3 中的 str 和 bytes 对象的方法，你会看到他们方法其实是大部分相同的，如 split, startswith 等等一类字符串的处理的方法两者都是有的。最重要的不同就是，str 只有 encode 方法，而 bytes 只有 decode 方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># python3</span><br>s = <span class="hljs-string">&#x27;&#x27;</span><br>s.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>e.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-comment"># AttributeError: &#x27;str&#x27; object has no attribute &#x27;decode&#x27;</span><br><br><span class="hljs-comment"># 其对应的方法参数还是需要和原对象一致</span><br>b = <span class="hljs-string">b&#x27;&#x27;</span><br>b.startswith(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment"># TypeError: startswith first arg must be bytes or a tuple of bytes, not str</span><br></code></pre></td></tr></table></figure><p>除此之外，在 Python2 中，很多时候为了类型转换，可能就直接通过 str(obj) 来进行操作，之前这样处理是没问题的，但现在这种处理方式不可行了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># python3</span><br>b = <span class="hljs-string">b&#x27;hello world&#x27;</span><br><span class="hljs-built_in">str</span>(b) <span class="hljs-comment"># b&#x27;hello world&#x27;</span><br></code></pre></td></tr></table></figure><p>上述代码可以看到，通过 str 之后，bytes 的确是变成了 str 类型，但是其多出了一个 b 的前缀。这里的正确姿势是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># python3</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(b, <span class="hljs-built_in">bytes</span>):<br>    b = b.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    b = <span class="hljs-built_in">str</span>(b)<br></code></pre></td></tr></table></figure><p>除此以外，不少的标准库的函数接收的类型也限制了，例如 hashlib 中的方法只接收 bytes 类型，json.loads 只接收 str 类型等等。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>我个人是比较喜欢 Python3 的更新的，默认的 utf-8 编码解决了很多的问题。</p><p>相比于 Python2，可能 Python3 的处理要繁琐一点，但安全性会好很多，一些很奇怪的问题可以及时发现。例如 decode 和 encode 方法的明确。同时，因为这些变化，我们需要在 bytes 可能出现的地方留心（一般是程序外部来的数据），进行类型转换，数据交互的层面统一使用 str 进行处理。</p><p>与 Python2 相比，str 和 bytes 的命名其实也更贴近实际的情况。我是这样去记两者的关系的：str 是 unicode 的 code 的序列，可认为是该字符在世界的唯一标识（code point），而 bytes 则是 str 通过某种编码（utf-8）实际保存的二进制数据。unicode 是种协议，而 utf-8 是这种协议的某种实现方式。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/">unicode</a></li><li><a href="https://docs.python.org/3/howto/unicode.html">Python3 Unicode HOWTO</a></li><li><a href="https://docs.python.org/2/howto/unicode.html">Python2 Unicode HOWTO</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>encoding</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 编码问题</title>
    <link href="/2017/03/26/python-encoding/"/>
    <url>/2017/03/26/python-encoding/</url>
    
    <content type="html"><![CDATA[<p>本文关注的是 python2 和 python3 在编码处理上的异同。所使用的python2 的版本为 2.7.12，python3 的版本为 3.5.2。</p><h2 id="unicode"><a href="#unicode" class="headerlink" title="unicode"></a>unicode</h2><p>unicode 是为了解决不同的语言背景下的统一的文字编码问题，简单来说就是给全世界所有的语言的字符唯一的 ID 来进行识别。例如，使用 python2 来输出汉字 “你好”</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-string">u&#x27;你好&#x27;</span><br><span class="hljs-built_in">print</span>(s) <span class="hljs-comment"># u&#x27;\u4f60\u597d&#x27;</span><br></code></pre></td></tr></table></figure><p>上述的 \u 开头的代码即 unicode 对汉字的唯一代码。但实际上，在计算机中，并不直接存放该代码。在 unicode 之前，普遍使用的是 ASCII 的方式进行编码，在英文世界中，一个字节可表示的 128 个符号已经足够了。如果普遍使用 unicode 则相应的英文存储的空间要扩大一倍以上。</p><p>所以就有了 utf-8 的出现。utf-8 是最普遍的 unicode 的实现方式，最主要的特点是可变长的编码形式。对于 ASCII 这种单字节的形式，第一个 bit 设置为 0，后面 7 位为有效位，即可完美兼容 ASCII。对于其他形式，则相应的位数有相应的规则，这里就不展开讨论了。</p><p>最后，需要注意的是，utf-8 是变长的，由前缀的 bit 位的规则来决定字节数。之后来谈谈在 python 中的实现。</p><h2 id="python2"><a href="#python2" class="headerlink" title="python2"></a>python2</h2><p>python2 的默认编码为 ASCII。在源代码文件中，如果用到非 ASCII 字符，需要在文件头部进行编码声明，当然，这并不影响实际程序的编码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br></code></pre></td></tr></table></figure><p>在 python2 中，与编码对应的有两种类型，str 和 unicode。简单来说，str 由 unicode 经过某种编码之后的字节组成。两者的关系如下</p><ul><li>都是 basestring 的子类</li><li>相对来说，unicode 才是真正意义上的字符串，调用 len 方法统计的是有多少个“字”，而 str 则是有多少字节</li><li>str  -&gt; decode(‘the_coding_of_str’) -&gt; unicode</li><li>unicode -&gt; encode(‘the_coding_you_want’) -&gt; str</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><br>u = <span class="hljs-string">u&#x27;你好&#x27;</span><br>s = u.encode(<span class="hljs-string">&quot;utf-8&quot;</span>)<br><span class="hljs-comment"># u.decode(&quot;utf-8&quot;)  # UnicodeEncodeError: &#x27;ascii&#x27; codec can&#x27;t encode ...</span><br><br>u0 = s.decode(<span class="hljs-string">&quot;utf-8&quot;</span>)<br><span class="hljs-comment"># s.encode(&quot;utf-8&quot;)  # UnicodeDecodeError: &#x27;ascii&#x27; codec can&#x27;t decode ...</span><br><br>s = <span class="hljs-string">&#x27;你好&#x27;</span>  <span class="hljs-comment"># 如果不加源文件的 coding 声明，这里会报错</span><br>u = s.decode(<span class="hljs-string">&quot;utf-8&quot;</span>)<br><span class="hljs-comment">#  u.decode(&quot;utf-8&quot;)  # UnicodeEncodeError: &#x27;ascii&#x27; codec can&#x27;t encode</span><br><br>s = u.encode(<span class="hljs-string">&quot;utf-8&quot;</span>)<br><span class="hljs-comment">#  s.encode(&quot;utf-8&quot;)  # UnicodeDecodeError: &#x27;ascii&#x27; codec can&#x27;t decode</span><br><br>u = <span class="hljs-string">u&#x27;abc&#x27;</span><br>s = <span class="hljs-string">&#x27;abc&#x27;</span><br><br><span class="hljs-built_in">print</span>(s + u)  <span class="hljs-comment"># abcabc</span><br><span class="hljs-built_in">print</span>(s == u)  <span class="hljs-comment"># True</span><br></code></pre></td></tr></table></figure><p>上述代码可以看到，decode 和 encode 的调用需要明确，unicode 需要根据一定的编码规则解析成机器可识别的字节流 str，而一堆字节流我们需要知道它所用的编码规则来解析成 unicode。</p><p>需要注意的是，如果是涉及 unicode 和 str 进行拼接和比较，则会有一次隐式转换，即先将 str 转成 unicode 再进行比较。如果 str 不是 ASCII 的话可能会出现转码错误。</p><h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h3><ol><li>python 源文件指定编码，一般推荐为 utf-8</li><li>硬编码的字符，使用 unicode 进行声明，如 <code>s = u&#39;你好&#39;</code></li><li>统一转成 unicode 来使用</li><li>Decode early, Unicode everywhere, Encode later</li></ol><h2 id="python3"><a href="#python3" class="headerlink" title="python3"></a>python3</h2><p>python3 中，相关的类型为 unicode 和 byte。与 python2 相对应的是</p><ul><li>python2:str &#x3D;&#x3D; python3:bytes</li><li>python2:unicode &#x3D; python3:str</li></ul><p>这样子更容易理解，str 存放的即是我想要的数据，bytes 存放的是实际的二进制数据。还有就是 python3 中将严格区分 str 和 bytes。str 类型只有 encode 方法，bytes 类型只有 decode 方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-string">&quot;你好&quot;</span><br>b = s.encode(<span class="hljs-string">&quot;utf-8&quot;</span>)<br><span class="hljs-built_in">print</span>(b)  <span class="hljs-comment"># b&#x27;\xe4\xbd\xa0\xe5\xa5\xbd&#x27;</span><br>s0 = b.decode(<span class="hljs-string">&quot;utf-8&quot;</span>)<br><span class="hljs-built_in">print</span>(s0)  <span class="hljs-comment"># 你好</span><br><br><span class="hljs-comment"># str 和 bytes 被认为是两种类型，比较和连接并不会进行自动的类型转换</span><br>s = <span class="hljs-string">&quot;abc&quot;</span><br>b = <span class="hljs-string">b&quot;abc&quot;</span><br><span class="hljs-built_in">print</span>(s == b)  <span class="hljs-comment"># False</span><br><span class="hljs-built_in">print</span>(s + b)  <span class="hljs-comment"># TypeError: Can&#x27;t convert &#x27;bytes&#x27; object to str implicitly</span><br></code></pre></td></tr></table></figure><p>对文件的操作也不同了，你通过 open 函数打开的文件返回的东西可能不同了。如果指定 <code>rb</code> 模式打开的文件，其内容为二进制流，即 bytes。如果是 <code>r</code> 模式，其内容为 str，这点需要额外注意。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">fp = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;./index.html&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(fp.read()))  <span class="hljs-comment"># &lt;class &#x27;str&#x27;&gt;</span><br><br>fp = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;./index.html&quot;</span>, <span class="hljs-string">&quot;rb&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(fp.read()))  <span class="hljs-comment"># &lt;class &#x27;bytes&#x27;&gt;</span><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>python3 比 python2 在编码上更加严格了，默认的编码就是 utf-8，已经不再需要在原文件头声明编码。decode 和 encode 方法也不再是两个类型都能调用，这个我认为是比较重要的，这样在写代码的时候就不需要纠结要用哪个方法了，最后是推荐阅读参考的第一个文章，很好的讲解了 unicode 的出现背景。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/">unicode 的出现背景和相关知识</a></li><li><a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html">阮一峰的关于 unicode 的笔记</a></li><li><a href="https://docs.python.org/2/howto/unicode.html">Unicode HOWTO python2</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>encoding</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python collections 库解析</title>
    <link href="/2017/03/14/python-collections/"/>
    <url>/2017/03/14/python-collections/</url>
    
    <content type="html"><![CDATA[<p>本文会简单介绍以下 python 标准库 collections 的相关使用。collections 在基础数据结构的基础上进一步封装了更高级的数据结构。</p><p>以下代码的环境为 python3.5.2</p><h2 id="defaultdict"><a href="#defaultdict" class="headerlink" title="defaultdict"></a>defaultdict</h2><p>defaultdict 是 dict 的子类，基本用法与 dict 一样，在 key 不存在是，添加了 <code>default_facetory</code> 提供的默认值的功能。</p><p>定义如下</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">collections.defaultdict(<span class="hljs-comment">[default_factory<span class="hljs-comment">[, ...]</span>]</span>)<br></code></pre></td></tr></table></figure><p>样例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">d = collections.defaultdict(<span class="hljs-built_in">int</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    d[i % <span class="hljs-number">3</span>] += <span class="hljs-number">1</span><br><span class="hljs-built_in">print</span>(d)<br><br><span class="hljs-comment"># 实际上，上述的代码类似于</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span>(collections.defaultdict):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__missing__</span>(<span class="hljs-params">self, key</span>):<br>        <span class="hljs-keyword">return</span> self.default_factory(key)<br>d = D(<span class="hljs-built_in">int</span>)<br><br><span class="hljs-comment"># 更简单的 lambda</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">constant_factory</span>(<span class="hljs-params">value</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">lambda</span>: value<br>d = collections.defaultdict(constant_factory(<span class="hljs-number">0</span>))<br></code></pre></td></tr></table></figure><p>最后，需要注意的是，defaultdict 生效只在 <code>obj[key]</code> 这种调用的模式下，如果使用 <code>obj.get</code> 则不会触发。</p><h2 id="OrderedDict"><a href="#OrderedDict" class="headerlink" title="OrderedDict"></a>OrderedDict</h2><p>基本用法也和 dict 一样，但是会记住 key 插入的顺序。它有两个额外的方法</p><ul><li><code>popitem(last=True)</code>: 弹出一个键值对，last&#x3D;False的话则弹出第一个</li><li><code>move_to_end(key, last=True)</code>: 移动某个 key 到最后（该 key 必须存在），last&#x3D;False 则移动到第一</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">od = collections.OrderedDict<br>d = od.fromkeys(<span class="hljs-string">&quot;abcde&quot;</span>)<br>d.move_to_end(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-literal">False</span>)<br><span class="hljs-keyword">for</span> key, val <span class="hljs-keyword">in</span> d.items():<br>    <span class="hljs-built_in">print</span>(key) <span class="hljs-comment"># b a c d e</span><br></code></pre></td></tr></table></figure><p>下面是一些有趣的例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LastUpdatedOrderedDict</span>(collections.OrderedDict):<br>    <span class="hljs-string">&#x27;&#x27;&#x27; 每一个 key 新增或者修改操作都将其置于最后，可用于实现类似 LRU 的算法</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__setitem__</span>(<span class="hljs-params">self, key, value</span>):<br>        <span class="hljs-keyword">if</span> key <span class="hljs-keyword">in</span> self:<br>            <span class="hljs-keyword">del</span> self[key]<br>        <span class="hljs-built_in">super</span>().__setitem__(key, value)<br>        <br><span class="hljs-comment"># 在初始化时指定 key 的排序依据</span><br>d = &#123;<span class="hljs-string">&#x27;banana&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;apple&#x27;</span>: <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;pear&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;orange&#x27;</span>: <span class="hljs-number">2</span>&#125;<br>collections.OrderedDict(<span class="hljs-built_in">sorted</span>(d.items(), key=<span class="hljs-keyword">lambda</span> t: t[<span class="hljs-number">0</span>])) <span class="hljs-comment"># sort by key</span><br>collections.OrderedDict(<span class="hljs-built_in">sorted</span>(d.items(), key=<span class="hljs-keyword">lambda</span> t: t[<span class="hljs-number">1</span>])) <span class="hljs-comment"># sort by value</span><br></code></pre></td></tr></table></figure><h2 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h2><p>同样是 dict 的子类，但是用于统计某个 key 的数量。它提供一些额外方法</p><ol><li><code>elements</code>: 返回所有大于 1 的 key，如果是 key 的数量大于 1 则会输出多次，同理，小于 0 则不输出</li><li><code>most_common([n])</code>: 返回 key 和其对应的 count，默认输出全部数据，n&#x3D;1 则返回 count 最大的</li><li><code>subtract([iterable-or-mapping])</code>: 对应的 count 的相减</li><li><code>fromkeys(iterable)</code>: 不可用，使用构造函数</li><li><code>update([iterable-or-mapping])</code>: 已存在的 key 则 count 增加</li></ol><p>常见的用法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python">c = collections.Counter() <span class="hljs-comment"># a new, empty counter</span><br>c = collections.Counter(&#123;<span class="hljs-string">&#x27;red&#x27;</span>: <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;blue&#x27;</span>: <span class="hljs-number">2</span>&#125;) <span class="hljs-comment"># from a mapping</span><br>c = collections.Counter(cats=<span class="hljs-number">4</span>, dogs=<span class="hljs-number">8</span>) <span class="hljs-comment"># from keyword args</span><br><br>c = collections.Counter(<span class="hljs-string">&#x27;hello&#x27;</span>) <span class="hljs-comment"># from an iterable</span><br><span class="hljs-built_in">print</span>(c[<span class="hljs-string">&#x27;l&#x27;</span>]) <span class="hljs-comment"># 2</span><br><br><span class="hljs-built_in">sum</span>(c.values())                 <span class="hljs-comment"># total of all counts</span><br>c.clear()                       <span class="hljs-comment"># reset all counts</span><br><span class="hljs-built_in">list</span>(c)                         <span class="hljs-comment"># list unique elements</span><br><span class="hljs-built_in">set</span>(c)                          <span class="hljs-comment"># convert to a set</span><br><span class="hljs-built_in">dict</span>(c)                         <span class="hljs-comment"># convert to a regular dictionary</span><br>c.items()                       <span class="hljs-comment"># convert to a list of (elem, cnt) pairs</span><br>collections.Counter(<span class="hljs-built_in">dict</span>(list_of_pairs))<br>c.most_common()[:-n-<span class="hljs-number">1</span>:-<span class="hljs-number">1</span>]       <span class="hljs-comment"># n least common elements</span><br><br>b + c                           <span class="hljs-comment"># 对应的 count 相加（相减）</span><br>b | c                           <span class="hljs-comment"># 并集，相同取最大的 count</span><br>b &amp; c                           <span class="hljs-comment"># 交集，相同取最小的 count</span><br><br>+c <span class="hljs-comment"># 相当于一个空的 counter 相加（或相减），但只保留整数 count 的 key</span><br>-c <span class="hljs-comment"># 同上</span><br></code></pre></td></tr></table></figure><h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><p><a href="https://docs.python.org/3/library/collections.html#deque-objects">deque</a> 是双端队列，首尾都可以进行插入和删除，同时也可以对某个位置进行插入。</p><p>需要注意的是，在初始化的时候指定了 maxlen，则在相应的更新操作则会造成已有的元素的移动</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">d = collections.deque(maxlen=<span class="hljs-number">3</span>)<br>d.extend(<span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>)) <span class="hljs-comment"># deque([0, 1, 2], maxlen=3)</span><br>d.append(<span class="hljs-number">4</span>) <span class="hljs-comment"># deque([1, 2, 4], maxlen=3)</span><br>d.insert(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>) <span class="hljs-comment"># IndexError: deque already at its maximum size</span><br><br>d.pop()<br>d.insert(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>) <span class="hljs-comment"># deque([-1, 1, 2], maxlen=3)</span><br></code></pre></td></tr></table></figure><p>一些样例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">tail</span>(<span class="hljs-params">filename, n=<span class="hljs-number">10</span></span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27; Return the last n lines of a file</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename) <span class="hljs-keyword">as</span> f:<br>        <span class="hljs-keyword">return</span> deque(f, n)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">delete_nth</span>(<span class="hljs-params">d, n</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27; 删除第 n 个元素</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    d.rotate(-n)<br>    d.popleft()<br>    d.rotate(n)<br></code></pre></td></tr></table></figure><h2 id="nametuple"><a href="#nametuple" class="headerlink" title="nametuple"></a>nametuple</h2><p><a href="https://docs.python.org/3/library/collections.html#collections.namedtuple">nametuple</a> 是种用于强化 tuple 的可用性的数据结构。将 tuple 的 index 对应到 key，增强代码的可读性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">Point = collections.namedtuple(<span class="hljs-string">&#x27;Point&#x27;</span>, [<span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>])<br><span class="hljs-comment"># Point = collections.namedtuple(&#x27;Point&#x27;, &#x27;x y&#x27;) # 也是可以的</span><br><br><span class="hljs-comment"># 增加的文档</span><br>Point.__doc__ += <span class="hljs-string">&quot;Point with (x, y)&quot;</span><br><br>p = Point._make((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))<br><span class="hljs-built_in">print</span>(p.x == p[<span class="hljs-number">0</span>]) <span class="hljs-comment"># True</span><br><span class="hljs-built_in">isinstance</span>(p, <span class="hljs-built_in">tuple</span>) <span class="hljs-comment"># True</span><br><span class="hljs-built_in">isinstance</span>(p, Point) <span class="hljs-comment"># True</span><br><br>p.x = <span class="hljs-number">1</span> <span class="hljs-comment"># AttributeError: can&#x27;t set attribute</span><br>p = p._replace(x=<span class="hljs-number">2</span>) <span class="hljs-comment"># 新对象，x=2,y=2</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span>(collections.namedtuple(<span class="hljs-string">&#x27;Point&#x27;</span>, <span class="hljs-string">&#x27;x y&#x27;</span>)):<br>    <span class="hljs-string">&quot;&quot;&quot; 这样则可以定义相应的方法</span><br><span class="hljs-string">    </span><br><span class="hljs-string">    下方 __slots__ = () 的设置则是为了不让对象生成 __dict__</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    __slots__ = ()<br></code></pre></td></tr></table></figure><p>上述的代码可见，nametuple 同时具备类对象的属性引用和 tuple 的不可变性，实际上，你可以当做一个不可变属性的类对象来使用。</p><h2 id="ChainMap"><a href="#ChainMap" class="headerlink" title="ChainMap"></a>ChainMap</h2><p>用于管理多个映射的数据结构。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">d1 = &#123;<span class="hljs-number">1</span>: <span class="hljs-number">2</span>, <span class="hljs-number">3</span>: <span class="hljs-number">4</span>, <span class="hljs-number">5</span>: <span class="hljs-number">6</span>&#125;<br>d2 = &#123;<span class="hljs-number">1</span>: <span class="hljs-number">1</span>, <span class="hljs-number">6</span>: <span class="hljs-number">7</span>&#125;<br><br>cm = collections.ChainMap(d1, d2)<br>cm.get(<span class="hljs-number">1</span>) <span class="hljs-comment"># 2</span><br><br>cm = collections.ChainMap(d2, d1)<br>cm.get(<span class="hljs-number">1</span>) <span class="hljs-comment"># 1</span><br><br>scm = cm.new_child() <span class="hljs-comment"># ChainMap(&#123;&#125;, &#123;1: 2, 3: 4, 5: 6&#125;, &#123;1: 1, 6: 7&#125;)</span><br>pcm = cm.parents <span class="hljs-comment"># ChainMap(&#123;1: 1, 6: 7&#125;)</span><br></code></pre></td></tr></table></figure><p>在上述代码中，可以看到对于同样的 key，会根据初始化时的顺序来定优先级，可以在数据级别实现类似于作用域的查找关系。</p><p>ChainMap 把状态存储在 <code>maps</code> 这个 list 中，用户是可以编辑的，可以随意修改其中的顺序和值。 <code>new_child(m=None)</code> 则是可以根据当前的数据新建一个 ChainMap 但是在 list 的最前方插入一个参数中指定的 m，如果没有则是一个空的字典。<code>parents</code> 则返回去掉第一个 map 的 ChainMap。</p><p>一些有趣的例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># python 变量查找顺序的模拟</span><br><span class="hljs-keyword">import</span> builtins<br>pylookup = collections.ChainMap(<span class="hljs-built_in">locals</span>(), <span class="hljs-built_in">globals</span>(), <span class="hljs-built_in">vars</span>(builtins))<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DeepChainMap</span>(collections.ChainMap):<br>    <span class="hljs-string">&#x27;&#x27;&#x27; 实现层级更新和删除</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__setitem__</span>(<span class="hljs-params">self, key, value</span>):<br>        <span class="hljs-keyword">for</span> mapping <span class="hljs-keyword">in</span> self.maps:<br>            <span class="hljs-keyword">if</span> key <span class="hljs-keyword">in</span> mapping:<br>                mapping[key] = value<br>                <span class="hljs-keyword">return</span><br>        self.maps[<span class="hljs-number">0</span>][key] = value<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__delitem__</span>(<span class="hljs-params">self, key</span>):<br>        <span class="hljs-keyword">for</span> mapping <span class="hljs-keyword">in</span> self.maps:<br>            <span class="hljs-keyword">if</span> key <span class="hljs-keyword">in</span> mapping:<br>                <span class="hljs-keyword">del</span> mapping[key]<br>                <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">raise</span> KeyError(key)<br></code></pre></td></tr></table></figure><h2 id="UserDict-UserList-UserString"><a href="#UserDict-UserList-UserString" class="headerlink" title="UserDict, UserList, UserString"></a>UserDict, UserList, UserString</h2><p>比直接继承 dict, list, str 的区别就是，你可以直接使用 <code>self.data</code> 去获取数据。在里面就以 dict, list, str 来保存数据，相应的接口来操纵这个数据。</p><p>在查找相关资料的时候，我没有发现使用这几个类去集成和去继承相应的 str, dict 有什么具体的优势。相关信息可参考 <a href="http://stackoverflow.com/questions/7148419/subclass-dict-userdict-dict-or-abc">这里</a>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://hg.python.org/cpython/file/tip/Modules/_collectionsmodule.c">collections 模块源码</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP 协议笔记</title>
    <link href="/2017/01/10/http-notes/"/>
    <url>/2017/01/10/http-notes/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在这里简单讲下 HTTP 协议相关的东西，包括方法，header，API 的设计等等。</p><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>以当前主流版本 <code>HTTP/1.1</code> 来稍微讲下一些比较重要的地方。</p><h3 id="URI-和-URL"><a href="#URI-和-URL" class="headerlink" title="URI 和 URL"></a>URI 和 URL</h3><ul><li>URI: Uniform Resource Identifier，统一资源标识符</li><li>URL: Uniform Resource Locator，统一资源定位符</li><li>URN: Uniform Resource Name，统一资源标识</li></ul><p>URL 是一种 URI，它标识一个互联网资源，并指定对其进行操作或获取该资源的方法。可能通过对主要访问手段的描述，也可能通过网络“位置”进行标识。</p><p>URN 是基于某命名空间通过名称指定资源的 URI。人们可以通过 URN 来指出某个资源，而无需指出其位置和获得方式。</p><blockquote><p>URL 类似于住址，告诉你一种寻址方式。同样的，这也是一个 URI。URN 可以理解为某个人的名字（没有重名）。</p></blockquote><p>它们的关系</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/c3/URI_Euler_Diagram_no_lone_URIs.svg/800px-URI_Euler_Diagram_no_lone_URIs.svg.png" alt="URI, URL, URN"></p><p>在日常开发中，很少需要区别 URL 和 URI。我们这里只讨论作为 <code>http</code> 或者 <code>https</code> 开头的各式各样的链接。每一条 URI，都是指向一个特定的资源。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li>HEAD：与 GET 方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据）。</li><li>GET：向指定的资源发出“显示”请求。使用 GET 方法应该只用在读取数据，而不应当被用于产生“副作用”的操作中，例如在 Web Application 中。其中一个原因是 GET 可能会被网络蜘蛛等随意访问。参见安全方法</li><li>POST：向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。</li><li>PUT：向指定资源位置上传其最新内容。</li><li>DELETE：请求服务器删除 Request-URI 所标识的资源。</li></ul><p>更多方法可见 <a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE#.E8.AF.B7.E6.B1.82.E6.96.B9.E6.B3.95">这里</a>。</p><p>最常见的就是 <code>GET</code>，<code>HEAD</code> 和 <code>POST</code> 方法。其中，就 <code>GET</code> 和 <code>HEAD</code> 方法而言，他们是安全方法，即他们的操作不应该会修改，删除指定的资源。任何的修改应该以 <code>GET</code>，<code>POST</code>，<code>DELETE</code> 来实现。</p><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p>通过指定的方法，对某个资源进行请求，服务器就会返回对应的状态码和数据。常见的状态码如下</p><ul><li>1xx 请求已经接受，接续处理</li><li>2xx 请求已经成功处理</li><li>3xx 重定向，需要在继续跟进返回的数据中指定的 URI</li><li>4xx 请求错误<ul><li>400 请求无法被服务器理解</li><li>401 权限错误</li><li>403 服务器理解该请求，但拒绝执行</li><li>404 找不到对应的资源</li><li>405 请求方法不对</li></ul></li><li>5xx 该请求正确，但服务器处理的时候出现问题<ul><li>500 未知错误</li><li>501 该功能未实现</li><li>502 网关或代理从上游服务器接到无效请求</li><li>503 服务器当前无法处理该请求</li><li>504 网关或者代理在指定时间内无法接收到上游请求，超时异常</li></ul></li></ul><p>上述的状态码和前面提到的方法，都是 HTTP 协议中定义的，但实际上服务器的行为是要通过代码实现，也就是说通过 <code>GET</code> 方法去更新，删除资源在逻辑上是没有问题的，但却是一种不推荐的行为。</p><h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><p>以下来讲下一些比较关键的 <code>header</code> 字段</p><h4 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h4><p>用于指定类型，如果未指定，则默认 <code>text/html</code>。API 返回的结果以 json 格式编码，则对应的 <code>Content-Type</code> 为 <code>application/json</code>。就表单而言，对应的则是 <code>multipart/form-data</code>。</p><h4 id="Content-Length"><a href="#Content-Length" class="headerlink" title="Content-Length"></a>Content-Length</h4><p>返回的请求的 <code>body</code> 的大小，单位为 <code>bytes</code>。</p><p>在非持久连接中，客户端以连接关闭来界定边界。但持久连接中，必须通过指定长度来表示内容的边界。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> BaseHTTPServer <span class="hljs-keyword">import</span> BaseHTTPRequestHandler,HTTPServer<br><br>PORT_NUMBER = <span class="hljs-number">8080</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myHandler</span>(<span class="hljs-title class_ inherited__">BaseHTTPRequestHandler</span>):<br><br>    <span class="hljs-comment">#  protocol_version = &quot;HTTP/1.1&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">do_GET</span>(<span class="hljs-params">self</span>):<br>        self.send_response(<span class="hljs-number">200</span>)<br>        self.send_header(<span class="hljs-string">&#x27;Content-type&#x27;</span>,<span class="hljs-string">&#x27;text/html&#x27;</span>)<br>        <span class="hljs-comment"># self.send_header(&#x27;Content-Length&#x27;, &#x27;5&#x27;)</span><br>        self.end_headers()<br>        self.wfile.write(<span class="hljs-string">&quot;Hello World !&quot;</span>)<br>        <span class="hljs-keyword">return</span><br><br><span class="hljs-keyword">try</span>:<br>    server = HTTPServer((<span class="hljs-string">&#x27;&#x27;</span>, PORT_NUMBER), myHandler)<br>    server.serve_forever()<br><span class="hljs-keyword">except</span> KeyboardInterrupt:<br>    server.socket.close()<br></code></pre></td></tr></table></figure><p>上述 Python 实现的简单的简单服务器，默认是 HTTP&#x2F;1.0 的协议。所以不需要指定 <code>Content-Length</code>，因为它的连接是非持久的。如果指定了 HTTP&#x2F;1.1 的版本，则需要指定 <code>Content-Length</code> 不然客户端不知道连接什么时候结束，一直处于 <code>pengdingg</code> 状态。</p><blockquote><p>HTTP&#x2F;1.1 则规定所有连接都必须是持久的，除非显式地在请求头部加上 <code>Connection: close</code></p></blockquote><h4 id="Transfer-Encoding"><a href="#Transfer-Encoding" class="headerlink" title="Transfer-Encoding"></a>Transfer-Encoding</h4><p>指的是 body 的编码形式。在 HTTP&#x2F;1.1 中新增的 <code>Transfer-Encoding: chunked</code> 用于正文的分块传输。很多时候，如果每次请求都需要额外计算 body 的长度就会很耗资源，特别是动态的生成的消息。对于这种情况，可以用这种分块的形式进行传输，每个块以 CRLF 标记结束。</p><p>同时，可以结合 <code>Content-Encoding: gzip</code> 对压缩后的正文进行分块传输。</p><blockquote><p>注意，这里的分块传输是指单次的响应消息的 body。</p></blockquote><h4 id="cookies"><a href="#cookies" class="headerlink" title="cookies"></a>cookies</h4><p>cookies 主要用于三个方面</p><ul><li>用户状态</li><li>个性化设置</li><li>行为追踪</li></ul><p>在首次请求的时候，客户端是不会携带任何信息的，如果有需要，服务端需要明确自己需要保留什么信息，并在响应信息里面通过 <code>Set-Cookie</code> 返回给客户端。一个响应信息可设置多个 cookie。</p><p><code>Set-Cookie</code> 可以通过 <code>Domain</code> 和 <code>Path</code> 的指令进行设置它的作用域，通过 <code>Expires</code> 和 <code>Max-Age</code> 来设置具体的过期时间。</p><p>如果不设置 <code>Domain</code>，该 cookie 可作用于当前的域名，但并不包括子域名。通过前置的 <code>.</code> 来包括所有的子域名。例如，<code>.baidu.com</code> 可作用域 <code>www.baidu.com</code> 和 <code>api.baidu.com</code>。而 <code>www.baidu.com</code> 的 <code>Domain</code> 设置则仅可以作用于自身。</p><p><code>HttpOnly</code> 的选项则说明该 cookie 不能通过 JavaScript 来传输，可以一定限度的防止 <code>XSS</code>。<code>Secure</code> 的选项则说明该 cookie 只能通过 SSL 或者 HTTPS 来进行传输。</p><h5 id="cookies-的使用"><a href="#cookies-的使用" class="headerlink" title="cookies 的使用"></a>cookies 的使用</h5><p>首先需要注意一点，任何来自用户的输入都是不可信的。因为当前用户标识是用 cookies 去做的，所以 cookies 的安全很重要。</p><p>需要注意以下几点</p><ol><li>cookies 的过期时间设置尽量短，不要设置过长的时间</li><li>用户修改密码之后，必须让其对应的 cookies 对应的 session 失效。</li><li><code>HttpOnly</code> 和 <code>Secure</code> 的选项尽量用上</li><li>如果可以的话，对 cookies 加入刷新机制</li><li>不要使用 user side session</li></ol><h4 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h4><p>缓存控制包括几个常见的 headers 字段</p><ul><li>ETag 校验值，某个资源的版本标识（指纹），由服务器端自定义生成方式</li><li>If-None-Match 包含在客户端的请求中</li></ul><p>两者的用法是，对于某个请求，服务端返回该资源的 <code>ETag</code> 信息。客户端如果需要再次请求，则需要带上该 <code>ETag</code> 并且包含另一个 <code>If-None-Math: &lt;ETag&gt;</code> header。如果服务器端未修改该资源，则返回 304 即可。</p><ul><li>Last-Modified 当前资源的最后修改时间，包含在响应信息中</li><li>If-Modified-Since 客户端请求时将上次收到的 <code>Last-Modified</code> 发送到服务器进行校验</li></ul><p><code>Last-Modified</code> 只能精确到秒级别，如果和 <code>ETag</code> 一起使用，服务器优先校验 <code>ETag</code>，一致的情况下就会才会比对 <code>Last-Modified</code>。</p><ul><li>Expires 服务端响应信息中返回，告诉客户端该资源的有效期</li><li>Cache-Control<ul><li>no-cache</li><li>no-store</li><li>max-age 允许使用的最大时间，单位为秒</li><li>public 无条件缓存，与其他缓存限制组合使用</li><li>private 只允许用户浏览器等缓存，即该缓存只是私有，CDN 等中介不可缓存</li></ul></li></ul><p><code>no-cache</code> 表示需要与服务器校验该资源是否已经更新，即可配合 <code>ETag</code> 进行使用。相反 <code>no-store</code> 则不进行任何考虑，所有的资源必须重新下载。</p><p><code>Cache-Control</code> 和 <code>Expires</code> 字段都用在服务器的响应信息中。</p><blockquote><p>POST 请求无法被缓存</p></blockquote><p>缓存的最佳实践</p><p><img src="https://developers.google.cn/web/fundamentals/performance/optimizing-content-efficiency/images/http-cache-decision-tree.png" alt="URI, URL, URN"></p><h4 id="自定义字段"><a href="#自定义字段" class="headerlink" title="自定义字段"></a>自定义字段</h4><p>HTTP 的 <code>header</code> 是允许自定义字段的，这些字段通常用于自定义的开发来标示特定的内容，如 Facebook 的 API 的返回数据中，有包含特定的版本信息的字段</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sml">&#123;<span class="hljs-symbol">&#x27;facebook</span>-api-version&#x27;: <span class="hljs-symbol">&#x27;v2</span>.<span class="hljs-number">8</span><span class="hljs-string">&#x27;&#125;</span><br></code></pre></td></tr></table></figure><h2 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h2><p>RESTful 的设计其实就是最大限度的使用 HTTP 协议本身已经定义好东西，包括各种方法作为动词，URI 做为操作的对象，不同的响应信息的返回值，状态码去表示操作的结果。</p><h3 id="以-Facebook-Marketing-API-为例"><a href="#以-Facebook-Marketing-API-为例" class="headerlink" title="以 Facebook Marketing API 为例"></a>以 Facebook Marketing API 为例</h3><p>Facebook Marketing API 用于去创建在 Facebook 上投放的广告。它由四个主要部分组成。</p><ul><li>Ad Account 管理不同的广告账户</li><li>Campaign 广告单元，从属于 Ad Account</li><li>Adset 广告单元，从属于 Campaign，一个 Campaign 包含多个 Adset</li><li>Ad 最小的广告单元，从属于 Adset，一个 Adset 可包含多个 Ad</li></ul><p>一些的 API URI 如下</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//g</span>raph.facebook.com<span class="hljs-regexp">/v2.8/</span>&lt;ad_unit_id&gt;<br>https:<span class="hljs-regexp">//g</span>raph.facebook.com<span class="hljs-regexp">/v2.8/</span>act_&lt;ad_account_id&gt;<br></code></pre></td></tr></table></figure><p>在这里，我们可以看到，在 API 中有指定对应的版本 <code>v2.8</code>。因为 Facebook 的每一个广告单元都有独立的 id，所以上述第一条链接可以直接用于 Campaign 或者 Adset 的读取或者更新。这里，我们称 <code>/&lt;ad_unit_id&gt;</code> 或者 <code>/act_&lt;ad_account_id&gt;</code> 为 endpoint，即表示除了共同前缀的独立部分。</p><p>下面以 Adset 的一系列操作为例</p><ul><li>创建，POST 方法，endpoint 为 <code>/act_&lt;ad_account_id&gt;/adsets</code></li><li>读取，GET 方法，endpoint 为 <code>/&lt;id&gt;</code><ul><li>获取实时的运营数据，GET 方法，endpoint 为 <code>/&lt;id&gt;/insights</code></li><li>获取 Adset 其下的 Ad，GET 方法，endpoint 为 <code>/&lt;id&gt;/ads</code></li></ul></li><li>更新，POST 方法，endpoint 为 <code>/&lt;id&gt;</code></li><li>删除，POST 方法，endpoint 为 <code>/&lt;id&gt;</code>，在参数中指定 <code>status=DELETED</code></li></ul><p>大概总结下</p><ul><li>在 URI 中指定版本号</li><li>操作对象本身以 id 指定，通过 URI 去访问</li><li>对象的层级关系以 URI 中的 <code>/</code> 进行分隔</li><li>读操作用 <code>GET</code>，写操作用 <code>POST</code></li></ul><p>这里跟别的 RESTful 的定义有区别，就是简化了方法，只用 <code>GET</code> 和 <code>POST</code> 来定义读写操作。</p><p>API 的返回信息很简单，通过状态码标示该次操作是否成功，不同的状态码表示不同的错误。例如 400 表示参数错误，401 表示验证错误，404 表示该资源不存在。</p><p>不管成功与否，API 调用的返回结果都会在 body 中以 json 的格式返回。如果是错误，则返回该次错误的原因。</p><h2 id="协议演变"><a href="#协议演变" class="headerlink" title="协议演变"></a>协议演变</h2><h3 id="HTTP-x2F-0-9"><a href="#HTTP-x2F-0-9" class="headerlink" title="HTTP&#x2F;0.9"></a>HTTP&#x2F;0.9</h3><p>HTTP 最初的版本，仅支持 <code>GET</code> 方法，没有 headers，也仅能是 HTML 的内容。</p><h3 id="HTTP-x2F-1-0"><a href="#HTTP-x2F-1-0" class="headerlink" title="HTTP&#x2F;1.0"></a>HTTP&#x2F;1.0</h3><p>加入了更多的方法，支持 headers 信息，支持状态码，支持更多的内容类型。</p><p>主要的问题是 HTTP&#x2F;1.0 没有支持连接复用，即每次请求之后连接就会关闭，这样子下一次请求必须重新连接，即重新进行 TCP 三次握手。</p><p>后期的一些实现是通过 <code>Connection: keep-alive</code> 来复用连接，但并不是广泛地支持。</p><h3 id="HTTP-x2F-1-1"><a href="#HTTP-x2F-1-1" class="headerlink" title="HTTP&#x2F;1.1"></a>HTTP&#x2F;1.1</h3><p>当前最主流的版本，连接默认是不会关闭的。需要在请求中加入 <code>Connection: close</code> 才会关闭连接。</p><p><code>Host</code> 信息变成强制性，如果没有 <code>Host</code> 则会 400 错误。通过 <code>Host</code> 字段，我们可以在同一个服务器上部署不同的域名的网站。</p><p><code>Pipelining</code> 的支持，在 HTTP&#x2F;1.0 中，发送请求必须等待确认才行，在 HTTP&#x2F;1.1 中，支持在同一个连接中发送多个请求而无需确认。这这种情况下，需要 <code>Content-Length</code> 或者分块消息 的支持来判断不同的响应消息是否结束。但即便是管道的支持，也没办法解决 <a href="https://zh.wikipedia.org/wiki/%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E">Head-of-line blocking 问题</a>。</p><p>支持 <code>Range</code> 对于同一个资源，可下载指定的 range bytes。</p><h3 id="HTTP-x2F-2"><a href="#HTTP-x2F-2" class="headerlink" title="HTTP&#x2F;2"></a>HTTP&#x2F;2</h3><p>在 HTTP&#x2F;2 出现之前，Google 的 <code>SPDY</code> 协议也用于解决 HTTP&#x2F;1.1 的问题。现在基本上已经整合到 HTTP&#x2F;2 中了。</p><p>HTTP&#x2F;2 包括以下的特性</p><ol><li>二进制协议，HTTP&#x2F;2 将由帧（Frames）和流（Streams）种数据组成。例如之前的 headers 和 body 将变成 <code>HEADERS</code> 和 <code>DATA</code> 帧。</li><li>每一个帧都携带唯一的 stream ID 来标示，帧也有自己的 header 和 payload。</li><li>多路复用，相对于 HTTP&#x2F;1.1 的 pipelining，请求的发送不用依赖于顺序，可以做到异步处理，这些有赖于 stream ID 来标记不同的帧。同时，也可以支持优先级和流量控制。</li><li>HPACK 头信息的压缩。</li><li>服务器推送。</li><li>安全性的提升。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们可以看到，在 HTTP 的协议中，主要分 headers 和 body 两个部分。对于一次传输而言，前者定义了该请求的一些元信息，包括数据的长度，编码和类型等等，我们通过这些信息去解析对应的实际内容。</p><p>但我们能限制实现的只能是服务端，客户端的是我们无法控制的，例如不同浏览器对不同的缓存的字段的实现不同，我们能做的就是认真考虑支持各种选项，并加强对客户端请求的校验。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://kamranahmed.info/blog/2016/08/13/http-in-depth/">Journey to HTTP&#x2F;2</a></li><li><a href="https://imququ.com/post/http2-resource.html">HTTP&#x2F;2 资料汇总</a></li><li><a href="http://www.ra.ethz.ch/cdstore/www8/data/2136/pdf/pd1.pdf">Key differences between HTTP&#x2F;1.0 and HTTP&#x2F;1.1</a></li><li><a href="https://zh.wikipedia.org/wiki/HTTP%E5%A4%B4%E5%AD%97%E6%AE%B5%E5%88%97%E8%A1%A8">HTTP headers 字段信息</a></li><li><a href="https://imququ.com/post/transfer-encoding-header-in-http.html">HTTP 协议中的 Transfer-Encoding</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies">cookies 详解</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie">Set-Cookie 详解</a></li><li><a href="https://www.v2ex.com/t/170974#reply49">关于静态资源使用不同的域名的讨论</a></li><li><a href="http://www.alloyteam.com/2012/03/web-cache-2-browser-cache/">Web 缓存机制</a></li><li><a href="https://developers.google.cn/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn">HTTP 缓存的实践</a></li><li><a href="https://github.com/aisuhua/restful-api-design-references">RESTful API 的参考</a></li><li><a href="https://developers.facebook.com/docs/marketing-api/reference">Facebook Marketing API</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang 错误处理</title>
    <link href="/2016/12/12/golang-error-handle/"/>
    <url>/2016/12/12/golang-error-handle/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Golang 中 error 的类型定义很简单，就是一个 <a href="https://github.com/golang/go/blob/master/src/builtin/builtin.go#L254">interface</a></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">type</span> <span class="hljs-type">error</span> <span class="hljs-keyword">interface</span> &#123;<br>Error() <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在标准库中，可以使用 <code>errors</code> 和 <code>fmt</code> 包来生成 error</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs golang">e1 := fmt.Errorf(<span class="hljs-string">&quot;%s&quot;</span>, <span class="hljs-string">&quot;error&quot;</span>)<br>e2 := errors.New(<span class="hljs-string">&quot;error&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="error-是变量，可用于比较"><a href="#error-是变量，可用于比较" class="headerlink" title="error 是变量，可用于比较"></a>error 是变量，可用于比较</h2><p>因为 error 是可比较的，我们可以通过比较来进行判断具体的错误。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">var</span> (<br>error1 = fmt.Errorf(<span class="hljs-string">&quot;error1&quot;</span>)<br>error2 = fmt.Errorf(<span class="hljs-string">&quot;error2&quot;</span>)<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">F</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> error1<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>err := F()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">switch</span> err &#123;<br><span class="hljs-keyword">case</span> error1:<br>fmt.Println(error1)<br><span class="hljs-keyword">case</span> error2:<br>fmt.Println(error2)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>例如，在 <a href="https://github.com/go-pg/pg">go-pg</a> 这个开源项目中，也在代码中定义了相应的 error 供我们判断情况 <a href="https://github.com/go-pg/pg/blob/v5/error.go">error.go</a>。下面的代码就是用来判断当做的错误是不是网络错误。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isNetworkError</span><span class="hljs-params">(err <span class="hljs-type">error</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> err == io.EOF &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br>_, ok := err.(net.Error)<br><span class="hljs-keyword">return</span> ok<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="压缩代码行数"><a href="#压缩代码行数" class="headerlink" title="压缩代码行数"></a>压缩代码行数</h2><p>在刚接触 Golang 的时候，我在每个返回 error 的函数中都进行了判断与返回，这样就导致了代码都长下面这样</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs golang">d, err := F()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br>c, err := F1()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br><span class="hljs-keyword">return</span> err<br>&#125;<br></code></pre></td></tr></table></figure><p>可以如下的写法，减少代码行数</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">var</span> d <span class="hljs-type">int</span><br><span class="hljs-keyword">if</span> d, err := F(); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err) <span class="hljs-comment">// some int</span><br><span class="hljs-keyword">return</span> err<br>&#125;<br>fmt.Println(d) <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure><p>这种写法适合遇到 error 就直接返回上层函数的情况。</p><p>不管是上面的代码，还是之前的代码，都有一个 <code>:=</code> 导致的作用域的小坑需要注意一下。如果 <code>:=</code> 左边的某个变量在外部的作用域已经定义，这里面的赋值会导致屏蔽掉外部的变量，创建一个新的变量在当前的作用域使用。如果需要对外部的变量进行变更的话，则需要赋值的 <code>=</code>。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">wrapper</span><span class="hljs-params">()</span></span> (err <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>n, err := work(i)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-comment">// err is shadowed during return</span><br>&#125;<br>fmt.Println(n)<br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上述的例子就是 err 被屏蔽了，会出现编译错误。</p><h2 id="错误统一处理"><a href="#错误统一处理" class="headerlink" title="错误统一处理"></a>错误统一处理</h2><p>还有一种写法就是，通过一个 struct 内部的 error 变量来获知是否有错误发生。例如</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">type</span> Controler <span class="hljs-keyword">struct</span> &#123;<br>err <span class="hljs-type">error</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Controler)</span></span> Work(num <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> num &gt; <span class="hljs-number">5</span> &#123;<br>c.err = fmt.Errorf(<span class="hljs-string">&quot;Number too big&quot;</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br>fmt.Println(num)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Controler)</span></span> InError() <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> c.err != <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Controler)</span></span> Error() <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> c.err<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>c := Controler&#123;&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>c.Work(i)<br>&#125;<br><br><span class="hljs-keyword">if</span> c.InError() &#123;<br>fmt.Println(c.Error())<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述的代码中，我不关心哪个步骤出了问题，我关心的是整体是否出错。这种场景下就可以用这种方法进行错误处理。同时，缺点也是优点，我们就会不知道到底哪里出的问题。</p><h2 id="错误还是异常"><a href="#错误还是异常" class="headerlink" title="错误还是异常"></a>错误还是异常</h2><p>Golang 中在语法层面区分了错误和异常，就是 <code>error</code> 和 <code>panic</code> 的区别。panic 函数实际上就是强制停止了函数，并返回上层函数，如果上层函数没有做 recover 检查的话（当然也可以在当前函数的 defer 处使用 recover），则整个程序就会停止。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">div</span><span class="hljs-params">(x, y <span class="hljs-type">float64</span>)</span></span> <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">if</span> y == <span class="hljs-number">0</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;zero&quot;</span>)<br>&#125;<br><span class="hljs-keyword">return</span> x / y<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">work</span><span class="hljs-params">(x, y <span class="hljs-type">float64</span>)</span></span> <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> r := <span class="hljs-built_in">recover</span>(); r != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Recovered in div&quot;</span>, r)<br>&#125;<br>&#125;()<br><span class="hljs-keyword">return</span> div(x, y)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>x := <span class="hljs-number">1.0</span><br>y := <span class="hljs-number">0.0</span><br>fmt.Println(work(x, y))<br>&#125;<br></code></pre></td></tr></table></figure><p>在标准库中，<a href="https://golang.org/src/encoding/json/decode.go#L151">json 的 decode.go</a> 中有使用 panic 的例子。在解析 json 格式的时候有多个递归，如果其中一个遇到错误，则调用 panic 函数，整个调用栈就会相继退出，然后在最上层的函数调用 recover 进行捕获。</p><p>然而，不少的标准库其实也没有太多地使用 panic 这个功能，第三方库更多也是以 error 代替这个功能。<a href="https://golang.org/doc/effective_go.html#panic">Effective Go</a> 中也推荐我们少用 panic 这个函数。</p><p>异常处理在 Golang 中更多是通过比较 error 的值来进行，不同的 error 执行不同的函数，当然，这样就意味着我们必须在二值返回的时候认真处理 error，所以有时候代码真的不能太优雅。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>上述的所有基础来自 error 是可比较的，interface 的相等是双方都是类型相同，并且方法 Error 的返回值相同。也正因为它是 interface 所以可以用于与 nil 的比较。</p><p>Golang 的错误处理我觉得很奇怪，我是习惯了 Python 那种使用 <code>try ... except</code> 代码块包含的方式去处理错误 &#x2F; 异常，这里我必须每个函数调用都判断一次。</p><p>例如在 <a href="https://github.com/go-pg/pg#select">go-pg</a> 中，通过 id 查询一个 model 的使用，如果找不到该记录的话，他是会返回一个找不到记录的错误，如果当前数据库那边有问题，该错误就会表示数据库那边的问题。但如果你是通过条件去找一堆 <code>id</code> 的话</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">var</span> ids []<span class="hljs-type">int</span><br>err := db.Model(&amp;Book&#123;&#125;).ColumnExpr(<span class="hljs-string">&quot;array_agg(id)&quot;</span>).Select(pg.Array(&amp;ids))<br></code></pre></td></tr></table></figure><p>如果找不到，这个 <code>err</code> 也还是 <code>nil</code>。这个处理逻辑的确是会让人迷惑。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://golang.org/ref/spec#Comparison_operators">Golang 中的比较</a></li><li><a href="https://blog.golang.org/defer-panic-and-recover">Defer, Panic and Recover</a></li><li><a href="http://www.infoq.com/cn/news/2012/11/go-error-handle">Golang 的错误处理机制的争议</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>error</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang sync 相关使用</title>
    <link href="/2016/10/29/golang-sync-package/"/>
    <url>/2016/10/29/golang-sync-package/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文大概讲下 golang sync 包的相关用法。sync 用在较为底层的库的同步上面，别的情况是推荐使用 channel 来同步进程。</p><h2 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h2><p>sync 包里面有两种互斥锁，分别是 <code>sync.Mutex</code> 和 <code>sync.RWMutex</code>。前者是基本的互斥锁，后者在前者的基础上实现的读写锁。</p><p>在这里我有一个简单的 stack 的实现，这里仅列出 push 方法的实现，可以看到，线程安全的的 stack 的 push 方法仅仅是比普通的 push 多出一个加锁解锁的过程。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">type</span> Stack <span class="hljs-keyword">struct</span> &#123;<br>data  []<span class="hljs-keyword">interface</span>&#123;&#125;<br>count <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> SafeStack <span class="hljs-keyword">struct</span> &#123;<br>stack *Stack<br>sync.RWMutex<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Stack)</span></span> Push(item <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s.data) == s.count &#123;<br>s.data = <span class="hljs-built_in">append</span>(s.data, item)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>s.data[s.count] = item<br>&#125;<br>s.count += <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *SafeStack)</span></span> Push(item <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>s.Lock()<br><span class="hljs-keyword">defer</span> s.Unlock()<br>s.stack.Push(item)<br>&#125;<br></code></pre></td></tr></table></figure><p>这里有个简单的 benchmark，简单的加锁解锁之后的性能仅剩下之前的十分之一了。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">BenchmarkStack</span>-<span class="hljs-number">4</span>        <span class="hljs-number">30000000</span>                <span class="hljs-number">38</span>.<span class="hljs-number">4</span> ns/op<br><span class="hljs-attribute">BenchmarkSafeStack</span>-<span class="hljs-number">4</span>     <span class="hljs-number">3000000</span>                <span class="hljs-number">403</span> ns/op<br></code></pre></td></tr></table></figure><h2 id="Pool"><a href="#Pool" class="headerlink" title="Pool"></a>Pool</h2><p>临时变量池。值得注意的是，golang 在 GC 的时候会将所有的 Pool 的临时变量全部删除，所以并不适合用在需要持久化用的环境里面。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">var</span> pool = sync.Pool&#123;<br>New: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>b := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> &amp;b<br>&#125;,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s := pool.Get().(*[]<span class="hljs-type">int</span>)<br>(*s)[<span class="hljs-number">0</span>] = <span class="hljs-number">99</span><br>pool.Put(s)<br>fmt.Println(s) <span class="hljs-comment">// &amp;[99]</span><br><br>d := pool.Get().(*[]<span class="hljs-type">int</span>)<br>fmt.Println(d) <span class="hljs-comment">// &amp;[99]</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h2><p>WaitGroup 用在等待子 goroutine 的场景。主 routine 通过指定需要等待的 routine 的个数，然后子 routine 手动通知上层任务完成。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// 注意这里不可直接用 wg 变量，而是需要传地址</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">work</span><span class="hljs-params">(i <span class="hljs-type">int</span>, wg *sync.WaitGroup)</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br>fmt.Printf(<span class="hljs-string">&quot;Work %d\n&quot;</span>, i)<br>time.Sleep(time.Duration(<span class="hljs-number">1</span>) * time.Second)<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> work(i, &amp;wg)<br>&#125;<br><span class="hljs-comment">// 如果 work 直接传值，这里就会死锁</span><br><span class="hljs-comment">// fatal error: all goroutines are asleep - deadlock!</span><br>wg.Wait()<br>fmt.Println(<span class="hljs-string">&quot;done&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Cond"><a href="#Cond" class="headerlink" title="Cond"></a>Cond</h2><p>条件变量，初始化时需要指定 locker。用于等待条件触发再去执行之后的操作。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">work</span><span class="hljs-params">(c *sync.Cond)</span></span> &#123;<br>time.Sleep(time.Duration(<span class="hljs-number">1</span>) * time.Second)<br>fmt.Println(<span class="hljs-string">&quot;Notify main&quot;</span>)<br>c.Signal()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> (<br>locker = <span class="hljs-built_in">new</span>(sync.Mutex)<br>cond   = sync.NewCond(locker)<br>)<br>cond.L.Lock()<br><span class="hljs-keyword">go</span> work(cond)<br>cond.Wait()<br>fmt.Println(<span class="hljs-string">&quot;Done&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以广播</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">work</span><span class="hljs-params">(cond *sync.Cond, i <span class="hljs-type">int</span>)</span></span> &#123;<br>cond.L.Lock()<br><span class="hljs-keyword">defer</span> cond.L.Unlock()<br>cond.Wait()<br>fmt.Println(<span class="hljs-string">&quot;work&quot;</span>, i)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> cond = sync.NewCond(<span class="hljs-built_in">new</span>(sync.Mutex))<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br><span class="hljs-keyword">go</span> work(cond, i)<br>&#125;<br><span class="hljs-comment">// 下面的 sleep 很重要</span><br>time.Sleep(time.Duration(<span class="hljs-number">2</span>) * time.Second)<br>fmt.Println(<span class="hljs-string">&quot;Wake up&quot;</span>)<br>cond.Broadcast()<br>time.Sleep(time.Duration(<span class="hljs-number">20</span>) * time.Second)<br>fmt.Println(<span class="hljs-string">&quot;Done&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>上述的代码我调试的时候出现了诡异的不稳定状态，work 函数中一直没有输出，或者没有输出全部的信息。</p><p>之前的代码中不包含上述的 sleep 两秒的代码，后来找了很久的原因无意中看到说有可能出现竞争。即 <code>cond.Broadcast()</code> 的执行优先于 work 的 <code>cond.L.Lock()</code>。因为广播是通知所有在 wait 的 routine。Golang 并不保证 routine 的执行顺序，所以应该有外部手段去控制相应的执行顺序。</p><p>为了解决上述的问题，官方文档推荐</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs golang">c.L.Lock()<br><span class="hljs-keyword">for</span> !condition() &#123;<br>    c.Wait()<br>&#125;<br>... <span class="hljs-built_in">make</span> use of condition ...<br>c.L.Unlock()<br></code></pre></td></tr></table></figure><p>通过额外的变量 condition 去控制 wait 的时机，这个就是后话了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>除了上述的数据结构，还有 <code>sync.Once</code> 等有用的东西，更多可参考官方文档。在我看来，互斥锁加上 channel 已经可以解决绝大部分的问题了。</p><p>需要注意的是，所有 sync 包的提供的数据结构都不允许复制，如果需要函数传值，则必须使用传地址的方式。这里还有很多细节还没有详细写，也可以看看 <a href="https://github.com/polaris1119/The-Golang-Standard-Library-by-Example/blob/master/chapter16/16.01.md">别人的</a> 的关于 sync 的使用。</p><p>sync 库的应用场景更偏向与底层，更高层的进程间通信更应该使用 channel 来使用，两者应该是相辅相成的关系。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://medium.com/@deckarep/dancing-with-go-s-mutexes-92407ae927bf#.yflgzc611">Dancing with go’s mutexes</a></li><li><a href="https://github.com/golang/go/wiki/MutexOrChannel">Mutex or channel</a></li><li><a href="https://golang.org/pkg/sync/">sync 官方文档</a></li><li><a href="https://github.com/polaris1119/The-Golang-Standard-Library-by-Example/blob/master/chapter16/16.01.md">别人写得 sync 包的使用</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>sync</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang context</title>
    <link href="/2016/10/19/golang-context/"/>
    <url>/2016/10/19/golang-context/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在去使用 Golang context 之前，推荐先去看 Golang pipeline 的<a href="https://blog.golang.org/pipelines">博文</a>，这里有讲到 Golang channel 的一些使用的技巧。</p><blockquote><p>1.6 的版本只能通过 <code>golang.org/x/net/context</code> 来使用， 1.7 之后才可以通过直接引用来使用</p></blockquote><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>Golang 创建了 goroutine 之后，在外部很难进行干预（只能依靠一个 chan 的关闭来通知）或者一些需要处理超时的请求很不方便，特别是多个 goroutine 进行协同工作时，我们需要一种模式来协同工作。</p><p>Golang 的 context 包就是解决这类问题的，它的基本结构如下</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">type</span> Context <span class="hljs-keyword">interface</span> &#123;<br>    Done() &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br>    Err() <span class="hljs-type">error</span><br>    Deadline() (deadline time.Time, ok <span class="hljs-type">bool</span>)<br>    Value(key <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-keyword">interface</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面以一些常见的例子来讲解下</p><h3 id="超时处理"><a href="#超时处理" class="headerlink" title="超时处理"></a>超时处理</h3><p>Golang 官方 wiki 的超时处理是 <a href="https://github.com/golang/go/wiki/Timeouts">这样的</a></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs golang">c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">error</span>, <span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; c &lt;- client.Call(<span class="hljs-string">&quot;Service.Method&quot;</span>, args, &amp;reply) &#125; ()<br><span class="hljs-keyword">select</span> &#123;<br>  <span class="hljs-keyword">case</span> err := &lt;-c:<br>    <span class="hljs-comment">// use err and reply</span><br>  <span class="hljs-keyword">case</span> &lt;-time.After(timeoutNanoseconds):<br>    <span class="hljs-comment">// call timed out</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过另外起 goroutine 来执行操作，本身则进行计时。当然简单的任务可以这样玩，但如果多个函数调用就非常囧了。我们假设有个函数如下</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">work</span><span class="hljs-params">(ctx context.Context)</span></span> (err <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br><span class="hljs-keyword">return</span> ctx.Err()<br><span class="hljs-keyword">default</span>:<br>fmt.Println(<span class="hljs-string">&quot;working&quot;</span>)<br>time.Sleep(time.Duration(<span class="hljs-number">1</span>) * time.Second)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p>则我们可以在 main 函数中这样用</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">var</span> (<br>ctx    context.Context<br>cancel context.CancelFunc<br>)<br>ctx, cancel = context.WithTimeout(context.Background(), time.Duration(<span class="hljs-number">2</span>)*time.Second)<br><span class="hljs-keyword">defer</span> cancel()<br><br>c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">error</span>, <span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; c &lt;- work(ctx) &#125;()<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>fmt.Println(<span class="hljs-string">&quot;Timeout&quot;</span>)<br>fmt.Println(ctx.Err()) <span class="hljs-comment">// context deadline exceeded</span><br><span class="hljs-keyword">case</span> err := &lt;-c:<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Sprintf(<span class="hljs-string">&quot;Error occor %s\n&quot;</span>, err)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Prefect work&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个例子其实跟之前 timeout 的做法类似，通过 goroutine 设置超时限制来达到控制函数超时的目的。那么我们多出来了什么？这里最明显的就是 <code>context.CancelFunc</code> 这个可以从外部控制的函数。除此之外，我们也可以通过参数 <code>ctx</code> 来通知子 context 外部的情况，如果外部取消或者超时了，我们可以进行诸如资源释放的操作，最后安全退出。</p><h3 id="外部控制"><a href="#外部控制" class="headerlink" title="外部控制"></a>外部控制</h3><p>如果在 ctx 对应的函数执行的过程中，外部的情况发生了变化，例如手动取消了进程，则该 goroutine 下对应的子 goroutine 也应该取消之后的操作。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">var</span> (<br>ctx    context.Context<br>cancel context.CancelFunc<br>)<br>ctx, cancel = context.WithCancel(context.Background())<br><span class="hljs-keyword">defer</span> cancel()<br><br>c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">error</span>, <span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; c &lt;- work(ctx) &#125;()<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-time.After(time.Duration(<span class="hljs-number">1</span>) * time.Second):<br>cancel()<br>fmt.Println(ctx.Err()) <span class="hljs-comment">// context canceled</span><br><span class="hljs-keyword">case</span> err := &lt;-c:<br>fmt.Println(err)<br>&#125;<br></code></pre></td></tr></table></figure><p>这里是外部取消了 work 的后续操作。同样的，之前的 <code>WithCancel</code> 也返回 cancel 函数可供使用，两者是等效的。</p><h2 id="with-函数"><a href="#with-函数" class="headerlink" title="with 函数"></a>with 函数</h2><p><code>context</code> 提供了几组 with 开头的方法，包括上面我们看到的 <code>WithCancel</code> 和 <code>WithTimeout</code>。它们的共同作用都是继承父级 context 来创建子 context，如果父级的 context 关闭了，其下的 context 也会关闭。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">var</span> (<br>ctx0    context.Context<br>cancel0 context.CancelFunc<br>ctx1    context.Context<br>cancel1 context.CancelFunc<br>)<br>ctx0, cancel0 = context.WithTimeout(context.Background(), time.Duration(<span class="hljs-number">50</span>)*time.Second)<br><span class="hljs-keyword">defer</span> cancel0()<br><br>ctx1, cancel1 = context.WithTimeout(ctx0, time.Duration(<span class="hljs-number">100</span>)*time.Second)<br><span class="hljs-keyword">defer</span> cancel1()<br><br>c0 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">error</span>, <span class="hljs-number">1</span>)<br>c1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">error</span>, <span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; c0 &lt;- work0(ctx0) &#125;()<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; c1 &lt;- work1(ctx1) &#125;()<br>time.Sleep(time.Duration(<span class="hljs-number">3</span>) * time.Second)<br>fmt.Println(<span class="hljs-string">&quot;cancel work0&quot;</span>)<br>cancel0()<br>time.Sleep(time.Duration(<span class="hljs-number">10</span>) * time.Second)<br></code></pre></td></tr></table></figure><p>上述的 <code>work0</code> 和 <code>work1</code> 函数的实现和之前的 <code>work</code> 一样，只是输出不同，下面是这个函数的输出</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">work1 <span class="hljs-keyword">is</span> working<br>work0 <span class="hljs-keyword">is</span> working<br>work1 <span class="hljs-keyword">is</span> working<br>work0 <span class="hljs-keyword">is</span> working<br>work1 <span class="hljs-keyword">is</span> working<br>work0 <span class="hljs-keyword">is</span> working<br>cancel work0<br>// wait <span class="hljs-number">10</span>s but <span class="hljs-keyword">nothing</span> <span class="hljs-keyword">else</span><br></code></pre></td></tr></table></figure><p>输出明确了 ctx0 和 ctx1 的关系。</p><h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p>在上述的代码中，都有用到 <code>context.Background()</code> 这个 context，这是最顶层的 context，伴随程序的生命周期。所有的 context 都从这里来，所以新建 context 的时候需要指定从这里派生出新的 context。</p><p>除了之前提到的超时和取消的函数之外，context 还可以传递参数</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithValue</span><span class="hljs-params">(parent Context, key <span class="hljs-keyword">interface</span>&#123;&#125;, val <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> Context<br><br><span class="hljs-comment">// for use</span><br>value, ok := ctx.Value(key).(<span class="hljs-type">string</span>)<br></code></pre></td></tr></table></figure><p>这个参数不是用来传递普通参数的，设计的初衷是用来传递 <code>request-scoped</code> 的参数，元数据。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>ctx 变量推荐作为函数的第一个参数传递使用，而不要放在结构体中</li><li>ctx 变量可以多个 goroutine 一起使用，不必担心安全问题</li><li>cancel 函数在声明之后应该直接跟着 <code>defer</code> 来使用</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://blog.golang.org/pipelines">Golang 使用 channel 实现 pipeline 模式</a></li><li><a href="https://blog.golang.org/context">Golang context 应用</a></li><li><a href="https://talks.golang.org/2014/gotham-context.slide#1">Golang context talk</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>context</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang 算术表达式解析</title>
    <link href="/2016/10/04/golang-expression/"/>
    <url>/2016/10/04/golang-expression/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>项目中需要用到解析算术表达式的模块，简单来说，就是 <code>eval</code> 函数，但并没有相应的标准库有类似的实现，所以想使用栈实现一个简单的算术表达式解析的模块。</p><p>首先，需要明确的是运算符优先级，这里只需要实现加减乘除，括号，and，or，不等号相关的符号即可。对应的优先级如下</p><ol><li>括号</li><li>类型运算符（前缀 + -）</li><li>乘，除</li><li>加，减</li><li>大于，小于，不大于，不小于</li><li>不等于，等于</li><li>and</li><li>or</li></ol><p>程序需要做的就是把优先级相关的东西去掉，然后转化成后缀表达式，即逆波兰表达式。</p><h2 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h2><p>需要两个栈，<code>result</code> 和 <code>ops</code> 前者用于保存结果，后者用于暂存操作符。</p><ol><li>如果遇到操作数，则 <code>result</code> 入栈</li><li>如果遇到操作符，则检查 <code>ops</code> 栈顶元素优先级</li><li>如果其优先级不低于当前操作符（左括号除外），则弹出 <code>ops</code> 栈顶元素并压入 <code>result</code> 中</li><li>重复此过程直到 <code>ops</code> 栈顶元素优先级小于当前操作符，或为左括号，或者 <code>ops</code> 为空</li><li>将当前操作符压入 <code>ops</code> 中</li><li>如果遇到左括号，直接压入 <code>ops</code></li><li>如果遇到右括号，则将 <code>ops</code> 中元素弹出，直到遇到左括号为止。左括号只弹出栈而不输出</li><li>表达式处理完毕，则将栈中元素依次压入 <code>result</code> 中</li></ol><p>例如，<code>1 * 2 + 3 * 4</code> 就变成 <code>1 2 * 3 4 * +</code>。后缀表达式的计算比中缀要容易得多，也不需要关心优先级，只需要简单的使用栈处理下就好。这里需要注意的是，由于比较运算法需要关注左右操作数的位置，所以实际运算的时候需要注意使用栈弹出之后位置就发生了交换。</p><p>上面的逻辑没有处理 <code>+</code> <code>-</code> 的类型前缀的情况。如果需要进行相关处理，则需要判断符号前面是不是数，如果是数的话，则认为当前的符号是二元操作符。因为一元操作符比二元操作符的优先级高，所以也可以将其转化为二元操作符。例如 <code>-1 + 1</code> 则可转变为 <code>-1 * 1 + 1</code>。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>首先用正则解析出合法的输入</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">var</span> legalArthmeticRegex <span class="hljs-type">string</span> = <span class="hljs-string">`^(\d+(\.\d+)?|\+|\-|\*|\/|and|or|\(|\)|==|&gt;=|&lt;=|!=|&gt;|&lt;)+$`</span><br></code></pre></td></tr></table></figure><p>然后需要实现一个简单的 <a href="https://github.com/lycheng/gox/blob/master/stacks/stack.go">stack</a>，Golang 里面竟然没有实现 stack 这样的东西啊。</p><p>然后解析出来之后，将其转为逆波兰式，这里需要用到 stack 来帮助解析。解析出来之后的计算就很简单了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calculateRPN</span><span class="hljs-params">(tokens []<span class="hljs-type">string</span>)</span></span> (result <span class="hljs-type">float64</span>, err <span class="hljs-type">error</span>) &#123;<br>stack := stacks.NewStack()<br><span class="hljs-keyword">for</span> _, token := <span class="hljs-keyword">range</span> tokens &#123;<br><span class="hljs-keyword">if</span> isNumber(token) &#123;<br>stack.Push(token)<br><span class="hljs-keyword">continue</span><br>&#125;<br><br><span class="hljs-keyword">if</span> stack.Size() &lt; <span class="hljs-number">2</span> &#123;<br>err = fmt.Errorf(<span class="hljs-string">&quot;reverse polish notation is wrong&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br>b := stack.Pop()<br>a := stack.Pop()<br>result, err = calculate(a.(<span class="hljs-type">string</span>), b.(<span class="hljs-type">string</span>), token)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>stack.Push(fmt.Sprintf(<span class="hljs-string">&quot;%.2f&quot;</span>, result))<br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p>最后输出的结果是 <code>float64</code> 的类型，布尔类型的结果只能以是否为 0 来进行判断。</p><h2 id="高级玩法"><a href="#高级玩法" class="headerlink" title="高级玩法"></a>高级玩法</h2><p>使用后缀表达式，没办法解决例如 <code>and</code> <code>or</code> 的优化，只能简单的处理计算而已。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>其实真正写的时间就一个下午而已，使用栈来实现的算法也是一搜一大堆。写下来发现其实感觉编译原理挺好玩的。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://github.com/lycheng/gox">gox</a></li><li><a href="https://msdn.microsoft.com/zh-cn/library/126fe14k.aspx">C++ 运算符优先级</a></li><li><a href="https://github.com/zdebeer99/goexpression">github 上一个类似的 Golang 项目 goexpression</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>eval</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang reflect 性能测试</title>
    <link href="/2016/08/07/golang-reflect-performance/"/>
    <url>/2016/08/07/golang-reflect-performance/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这阵子用 Golang 实现了一个类似于 python <code>in</code> 语法的小函数，项目 <a href="https://github.com/lycheng/gox">gox</a> 的 benchmark 测试的结果如下</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">BenchmarkOriIn</span>-<span class="hljs-number">4</span>        <span class="hljs-number">500000000</span>                <span class="hljs-number">3</span>.<span class="hljs-number">22</span> ns/op<br><span class="hljs-attribute">BenchmarkMyIn</span>-<span class="hljs-number">4</span>         <span class="hljs-number">10000000</span>               <span class="hljs-number">175</span> ns/op<br><span class="hljs-attribute">BenchmarkOriMapIn</span>-<span class="hljs-number">4</span>     <span class="hljs-number">100000000</span>               <span class="hljs-number">16</span>.<span class="hljs-number">3</span> ns/op<br><span class="hljs-attribute">BenchmarkMyMapIn</span>-<span class="hljs-number">4</span>       <span class="hljs-number">2000000</span>               <span class="hljs-number">784</span> ns/op<br><span class="hljs-attribute">ok</span>      github.com/lycheng/gox/container        <span class="hljs-number">7</span>.<span class="hljs-number">939</span>s<br></code></pre></td></tr></table></figure><p>其中，OriIn 是顺序查询 slice 和 array 的元素是否存在，OriMapIn 是原生的语法去判断 key 是否存在。上述的结果可以看到相当巨大的性能差异。</p><p>我实现的 In 的函数在处理 Map 的时候是通过遍历 keys 来查询的，因此每次的类型判断乘上数据量不仅仅是一个跟 N 有关的线性增长。</p><h2 id="profile"><a href="#profile" class="headerlink" title="profile"></a>profile</h2><p>使用 Golang 的 <code>runtime/pprof</code> 包来检查相应的 CPU 消耗，这里不考虑内存消耗的问题。</p><p>profile 程序</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;flag&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;runtime/pprof&quot;</span><br><br><span class="hljs-string">&quot;github.com/lycheng/gox/container&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> cpuprofile = flag.String(<span class="hljs-string">&quot;cpuprofile&quot;</span>, <span class="hljs-string">&quot;gox.prof&quot;</span>, <span class="hljs-string">&quot;write cpu profile to file&quot;</span>)<br><br><span class="hljs-comment">// l 如果太大则会内存不足</span><br><span class="hljs-keyword">var</span> l = flag.Int(<span class="hljs-string">&quot;len&quot;</span>, <span class="hljs-number">100000000</span>, <span class="hljs-string">&quot;find item in N sequence&quot;</span>)<br><span class="hljs-keyword">var</span> ori = flag.Bool(<span class="hljs-string">&quot;ori&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">&quot;use ori array func&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">oriFind</span><span class="hljs-params">(item <span class="hljs-type">int</span>, items []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">for</span> _, i := <span class="hljs-keyword">range</span> items &#123;<br><span class="hljs-keyword">if</span> i == item &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>flag.Parse()<br><span class="hljs-keyword">if</span> *cpuprofile != <span class="hljs-string">&quot;&quot;</span> &#123;<br>f, err := os.Create(*cpuprofile)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br>pprof.StartCPUProfile(f)<br><span class="hljs-keyword">defer</span> pprof.StopCPUProfile()<br>&#125;<br><br>items := []<span class="hljs-type">int</span>&#123;&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; *l; i++ &#123;<br>items = <span class="hljs-built_in">append</span>(items, i)<br>&#125;<br>item := items[<span class="hljs-built_in">len</span>(items)<span class="hljs-number">-1</span>]<br><br><span class="hljs-keyword">if</span> *ori &#123;<br>fmt.Println(oriFind(item, items))<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(container.In(item, items))<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>应用如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">go build profile.go</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">简单的数组遍历</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">./profile -ori <span class="hljs-literal">true</span></span><br>true<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用 reflect</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">./profile</span><br>true<br></code></pre></td></tr></table></figure><p>相对不用 <code>reflect</code> 只是简单的整型数组的查找，top10 的消耗如下</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt; go tool pprof profile gox.prof<br>Entering interactive mode (<span class="hljs-built_in">type</span> <span class="hljs-string">&quot;help&quot;</span> <span class="hljs-keyword">for</span> commands)<br>(pprof) top10<br><span class="hljs-number">3060</span>ms of <span class="hljs-number">3060</span>ms total (  <span class="hljs-number">100</span><span class="hljs-comment">%)</span><br>Dropped <span class="hljs-number">6</span> nodes (cum &lt;= <span class="hljs-number">15.30</span>ms)<br>Showing top <span class="hljs-number">10</span> nodes out of <span class="hljs-number">27</span> (cum &gt;= <span class="hljs-number">20</span>ms)<br>      flat  flat<span class="hljs-comment">%   sum%        cum   cum%</span><br>     <span class="hljs-number">810</span>ms <span class="hljs-number">26.47</span><span class="hljs-comment">% 26.47%     1790ms 58.50%  runtime.scang</span><br>     <span class="hljs-number">760</span>ms <span class="hljs-number">24.84</span><span class="hljs-comment">% 51.31%      980ms 32.03%  runtime.readgstatus</span><br>     <span class="hljs-number">630</span>ms <span class="hljs-number">20.59</span><span class="hljs-comment">% 71.90%      630ms 20.59%  runtime.memmove</span><br>     <span class="hljs-number">340</span>ms <span class="hljs-number">11.11</span><span class="hljs-comment">% 83.01%     1250ms 40.85%  main.main</span><br>     <span class="hljs-number">220</span>ms  <span class="hljs-number">7.19</span><span class="hljs-comment">% 90.20%      220ms  7.19%  runtime/internal/atomic.Load</span><br>     <span class="hljs-number">200</span>ms  <span class="hljs-number">6.54</span><span class="hljs-comment">% 96.73%      200ms  6.54%  runtime.memclr</span><br>      <span class="hljs-number">80</span>ms  <span class="hljs-number">2.61</span><span class="hljs-comment">% 99.35%       80ms  2.61%  main.oriFind</span><br>      <span class="hljs-number">20</span>ms  <span class="hljs-number">0.65</span><span class="hljs-comment">%   100%       20ms  0.65%  runtime.scanblock</span><br>         <span class="hljs-number">0</span>     <span class="hljs-number">0</span><span class="hljs-comment">%   100%       20ms  0.65%  runtime.(*mspan).sweep</span><br>         <span class="hljs-number">0</span>     <span class="hljs-number">0</span><span class="hljs-comment">%   100%       20ms  0.65%  runtime.(*mspan).sweep.func1</span><br></code></pre></td></tr></table></figure><p>gox 的版本</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt; go tool pprof profile gox.prof<br>Entering interactive mode (<span class="hljs-built_in">type</span> <span class="hljs-string">&quot;help&quot;</span> <span class="hljs-keyword">for</span> commands)<br>(pprof) top10<br><span class="hljs-number">5100</span>ms of <span class="hljs-number">5260</span>ms total (<span class="hljs-number">96.96</span><span class="hljs-comment">%)</span><br>Dropped <span class="hljs-number">15</span> nodes (cum &lt;= <span class="hljs-number">26.30</span>ms)<br>Showing top <span class="hljs-number">10</span> nodes out of <span class="hljs-number">29</span> (cum &gt;= <span class="hljs-number">200</span>ms)<br>      flat  flat<span class="hljs-comment">%   sum%        cum   cum%</span><br>    <span class="hljs-number">1010</span>ms <span class="hljs-number">19.20</span><span class="hljs-comment">% 19.20%     1010ms 19.20%  runtime.memmove</span><br>     <span class="hljs-number">780</span>ms <span class="hljs-number">14.83</span><span class="hljs-comment">% 34.03%     1450ms 27.57%  runtime.scang</span><br>     <span class="hljs-number">590</span>ms <span class="hljs-number">11.22</span><span class="hljs-comment">% 45.25%     2310ms 43.92%  github.com/lycheng/gox/container.inArray</span><br>     <span class="hljs-number">540</span>ms <span class="hljs-number">10.27</span><span class="hljs-comment">% 55.51%     1040ms 19.77%  github.com/lycheng/gox/container.equals</span><br>     <span class="hljs-number">530</span>ms <span class="hljs-number">10.08</span><span class="hljs-comment">% 65.59%      670ms 12.74%  runtime.readgstatus</span><br>     <span class="hljs-number">500</span>ms  <span class="hljs-number">9.51</span><span class="hljs-comment">% 75.10%      500ms  9.51%  reflect.Value.Int</span><br>     <span class="hljs-number">480</span>ms  <span class="hljs-number">9.13</span><span class="hljs-comment">% 84.22%      480ms  9.13%  reflect.Value.Index</span><br>     <span class="hljs-number">270</span>ms  <span class="hljs-number">5.13</span><span class="hljs-comment">% 89.35%     3770ms 71.67%  main.main</span><br>     <span class="hljs-number">200</span>ms  <span class="hljs-number">3.80</span><span class="hljs-comment">% 93.16%      200ms  3.80%  reflect.Value.Len</span><br>     <span class="hljs-number">200</span>ms  <span class="hljs-number">3.80</span><span class="hljs-comment">% 96.96%      200ms  3.80%  runtime.memclr</span><br></code></pre></td></tr></table></figure><p>两种代码的执行时间只是 5s 和 3s 的区别，而 <code>container.inArray</code> 在这里面就占用了 2310ms，几乎花了一半的时间在类型判断和比较上面。</p><p><code>gox</code> 这东西可能在数据量较小的情况下可以使用。但在我平时工作的应用场景里面，很少用到这种异构的数组。每个元素去判断类型消耗实在是太大了啊。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>reflect</code> 这东西感觉还是少用点会比较好，除非用来编写奇怪动态数据，例如根据 key 修改 struct 的某些数据。文章后面的参考中有较好的第三方库。</p><p>而在我编写的过程中，也很容易出现各种 panic 的情况，例如需要覆盖各种可能的数据类型，这种情况不好处理，万一有所遗漏则就是 bug 了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://blog.golang.org/profiling-go-programs">profiling in golang</a></li><li><a href="https://github.com/fatih/structs">Golang 中动态修改 struct 的库</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>reflect</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker 简要记录</title>
    <link href="/2016/07/16/docker-simple-note/"/>
    <url>/2016/07/16/docker-simple-note/</url>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>docker 目前在 ubuntu apt 上面的版本官方并不维护，需要手动添加它的源才比较好。详细的官方文档可见 <a href="https://docs.docker.com/engine/installation/linux/ubuntulinux/">这里</a>。</p><p>因为国外的 docker registry 太慢，所以可以选择国内的服务 <a href="https://get.daocloud.io/">daocloud</a> 来进行加速。常用的镜像都能很快的下载。当然有能力的可以选择自己搭建私有的 registry。</p><p>安装之后可以看 docker 是否已经启动</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo systemctl status docker<br></code></pre></td></tr></table></figure><h3 id="安装镜像"><a href="#安装镜像" class="headerlink" title="安装镜像"></a>安装镜像</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">sudo</span> docker pull hello-world<br><span class="hljs-comment"># OR</span><br>dao pull hello-world<br></code></pre></td></tr></table></figure><p>上面两者是等效的，默认的 tag 都是 latest。安装之后可以列出 images 来查看</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo docker images</span><br></code></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-comment"># 删除镜像</span><br><span class="hljs-comment"># 前提是没有正在运行的相关容器</span><br>sudo docker rmi &lt;image&gt;<span class="hljs-symbol">:&lt;tag&gt;</span><br></code></pre></td></tr></table></figure><p>在镜像安装的时候可以看到这样的东西</p><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ldif">Pulling repository library/redis:2.8<br><br><span class="hljs-attribute">128182e1e85d</span>: Download complete<br><span class="hljs-attribute">7f1aa6a73799</span>: Download complete<br><span class="hljs-attribute">1a9852d2edd3</span>: Download complete<br><span class="hljs-attribute">a3ed95caeb02</span>: Download complete<br><span class="hljs-attribute">fbe8a4f1aa87</span>: Download complete<br><span class="hljs-attribute">b94de088b6d8</span>: Download complete<br><span class="hljs-attribute">6c8ccd839b1d</span>: Download complete<br><span class="hljs-attribute">0fded1c9651d</span>: Download complete<br><span class="hljs-attribute">51f5c6a04d83</span>: Download complete<br></code></pre></td></tr></table></figure><p>上面的的每一行代表镜像的每一层（layer），仅可读，表示镜像那时候的文件系统的不同。在创建新的容器的时候，则在最新的层上面创建一层可读可写的容器层。如果把做了的修改保存下来，则就是新的层，这个 image 就更新了。</p><h3 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">加载镜像到容器中</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">每执行以此就有一个新的容器</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">有一大堆参数指定各种例如网络，存储的信息</span><br>sudo docker run &lt;image&gt;:&lt;tag&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">daemon 的形式来跑服务</span><br>sudo docker run -d &lt;image&gt;:&lt;tag&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">列出容器信息</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-a 表示所有的容器，如果去掉则仅仅是正在运行的容器</span><br>sudo docker ps -a<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除容器</span><br>sudo docker rm &lt;id&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除已经退出的容器</span><br>sudo docker rm `sudo docker ps -aq -f status=exited`<br></code></pre></td></tr></table></figure><h3 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h3><p>docker-compose 是 docker 用来管理多个容器的工具。通过配置文件定义容器的参数，相应容器的依赖，对外的端口等等。</p><p>它的配置文件大概会长这样</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">redash:</span><br>  <span class="hljs-attr">image:</span> <span class="hljs-string">redash/redash:latest</span><br>  <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;5000:5000&quot;</span><br>  <span class="hljs-attr">links:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">redis</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">postgres</span><br>  <span class="hljs-attr">environment:</span><br>    <span class="hljs-attr">REDASH_STATIC_ASSETS_PATH:</span> <span class="hljs-string">&quot;../rd_ui/dist/&quot;</span><br>    <span class="hljs-attr">REDASH_LOG_LEVEL:</span> <span class="hljs-string">&quot;INFO&quot;</span><br>    <span class="hljs-attr">REDASH_REDIS_URL:</span> <span class="hljs-string">&quot;redis://redis:6379/0&quot;</span><br>    <span class="hljs-attr">REDASH_DATABASE_URL:</span> <span class="hljs-string">&quot;postgresql://postgres@postgres/postgres&quot;</span><br>    <span class="hljs-attr">REDASH_COOKIE_SECRET:</span> <span class="hljs-string">veryverysecret</span><br><span class="hljs-attr">redis:</span><br>  <span class="hljs-attr">image:</span> <span class="hljs-string">redis:2.8</span><br><span class="hljs-attr">postgres:</span><br>  <span class="hljs-attr">image:</span> <span class="hljs-string">postgres:9.3</span><br>  <span class="hljs-attr">volumes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">/opt/postgres-data:/var/lib/postgresql/data</span><br><span class="hljs-attr">redash-nginx:</span><br>  <span class="hljs-attr">image:</span> <span class="hljs-string">redash/nginx:latest</span><br>  <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;80:80&quot;</span><br>  <span class="hljs-attr">links:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">redash</span><br></code></pre></td></tr></table></figure><p>之后保存配置文件 <code>docker-compose.yml</code> 然后在当前的目录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo docker-compose up<br><br><span class="hljs-comment"># 单独启用其中某个服务</span><br>sudo docker-compose up postgres<br></code></pre></td></tr></table></figure><h2 id="root"><a href="#root" class="headerlink" title="root"></a>root</h2><p>容器内部的用户是 root，跟宿主的 root 是不同的。默认的情况下，run 参数 <code>--privileged=false</code>，同是 root 用户，但却不是所有的权限。可以基本不用担心安全问题。</p><p>到如果设置为 true 的话，问题就大了</p><blockquote><p>由于 Docker 容器与宿主机处于共享同一个内核操作系统的状态，因此，Docker 容器将完全拥有内核的管理权限</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://docs.docker.com/engine/understanding-docker/">官方文档</a></li><li><a href="https://docs.docker.com/engine/userguide/storagedriver/imagesandcontainers/">docker 的存储的相关概念</a></li><li><a href="https://docs.docker.com/compose/overview/">docker compose</a></li><li><a href="http://docs.daocloud.io/allen-docker/docker-root">docker root 安全问题</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang 学习 4</title>
    <link href="/2016/07/09/golang-learning-4/"/>
    <url>/2016/07/09/golang-learning-4/</url>
    
    <content type="html"><![CDATA[<p>前面 1 ~ 3 系列是看着书来写的，后面的是自己遇到的一些问题的总结。</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>Golang 是强类型语言，类型的转换必须显式转换，interface 除外。</p><p>数值类型的转换，哪怕是底层类型相同的 <code>int</code> 和 <code>int32</code> 也不能直接赋值。同理，自定义的类型哪怕底层类型相同也不能直接赋值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyInt <span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> i <span class="hljs-type">int</span> = <span class="hljs-number">100</span><br>    <span class="hljs-keyword">var</span> j <span class="hljs-type">int32</span> = <span class="hljs-type">int32</span>(i) <span class="hljs-comment">// 显式类型转换</span><br>    <span class="hljs-keyword">var</span> k MyInt = MyInt(i) <span class="hljs-comment">// 显式类型转换</span><br>    fmt.Println(i)<br>    fmt.Println(j)<br>    fmt.Println(k)<br>&#125;<br></code></pre></td></tr></table></figure><p>string 类型的转化可以借助 package <code>fmt</code> 和 <code>strconv</code> 来进行。</p><p>interface 的类型转换没那么复杂，但两者必须是包含关系，例如 A interface 的方法包含 b 的方法，则可以 <code>a = A</code> 但不能 <code>A = a</code>，例如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> w io.Writer<br>w = os.Stdout           <span class="hljs-comment">// OK: *os.File has Write method</span><br>w = <span class="hljs-built_in">new</span>(bytes.Buffer)   <span class="hljs-comment">// OK: *bytes.Buffer has Write method</span><br>w = time.Second         <span class="hljs-comment">// compile error: time.Duration lacks Write method</span><br><br><span class="hljs-keyword">var</span> rwc io.ReadWriteCloser<br>rwc = os.Stdout         <span class="hljs-comment">// OK: *os.File has Read, Write, Close methods</span><br>rwc = <span class="hljs-built_in">new</span>(bytes.Buffer) <span class="hljs-comment">// compile error: *bytes.Buffer lacks Close method</span><br><br>w = rwc                 <span class="hljs-comment">// OK</span><br>rwc = w                 <span class="hljs-comment">// compile error: io.Writer lacks Close method</span><br></code></pre></td></tr></table></figure><p>当一个变量赋值到一个 interface 变量时，再转换回来需要需要使用类型断言</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Stringer <span class="hljs-keyword">interface</span> &#123;<br>    String() <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">str</span><span class="hljs-params">(val <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">switch</span> s := val.(<span class="hljs-keyword">type</span>) &#123; <span class="hljs-comment">// 类型断言</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-type">string</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;I&#x27;m String:&quot;</span> + s<br>    <span class="hljs-keyword">case</span> Stringer:<br>        <span class="hljs-keyword">return</span> s.String()<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;I don&#x27;t KNOW&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">type</span> Human <span class="hljs-keyword">struct</span> &#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h Human)</span></span> String() <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;WOW&quot;</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Animal <span class="hljs-keyword">struct</span> &#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(str(<span class="hljs-string">&quot;asdada&quot;</span>)) <span class="hljs-comment">// I&#x27;m String:asdada</span><br><br>    h := Human&#123;&#125;<br>    fmt.Println(str(h)) <span class="hljs-comment">// WOW</span><br><br>    a := Animal&#123;&#125;<br>    fmt.Println(str(a)) <span class="hljs-comment">// I don&#x27;t KNOW</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上述的函数 <code>str</code> 中，接收的参数是空的 interface，在函数调用的时候进行了隐式的类型转换，因为任何类型都包括空的 interface。</p><h3 id="interface-内存结构"><a href="#interface-内存结构" class="headerlink" title="interface 内存结构"></a>interface 内存结构</h3><p>Golang 中的 interface 包括两个部分</p><ol><li>底层的数据</li><li>描述符，即方法表</li></ol><p>方法表中，关联着相关类型和方法列表。这些都不是动态类型，所以可以用来进行类型检查。底层数据存放的是复制的一份新的原始数据。在调用的时候，将底层数据作为方法的第一个参数来进行调用。</p><p>空的 interface 就是方法表为空的变量。</p><h2 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h2><p>slice 是变长数组，在使用的时候有些需要注意的地方。</p><p>首先看下 slice 的结构</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Slice <span class="hljs-keyword">struct</span>&#123;<br>    <span class="hljs-type">byte</span>*    array;        <span class="hljs-comment">// actual data</span><br>    uintgo    <span class="hljs-built_in">len</span>;        <span class="hljs-comment">// number of elements</span><br>    uintgo    <span class="hljs-built_in">cap</span>;        <span class="hljs-comment">// allocated number of elements</span><br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">appendSlice</span><span class="hljs-params">(array []<span class="hljs-type">int</span>)</span></span> &#123;<br>    array[<span class="hljs-number">0</span>] = <span class="hljs-number">10000</span><br>    fmt.Printf(<span class="hljs-string">&quot;%p\n&quot;</span>, array)<br>    array = <span class="hljs-built_in">append</span>(array, <span class="hljs-number">5</span>)<br>    fmt.Printf(<span class="hljs-string">&quot;%p\n&quot;</span>, array) <span class="hljs-comment">// 与上面的地址不同</span><br>    array[<span class="hljs-number">0</span>] = <span class="hljs-number">10001</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    l := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br>    fmt.Println(l) <span class="hljs-comment">// [1 2 3 4]</span><br>    appendSlice(l)<br>    fmt.Println(l) <span class="hljs-comment">// [10000 2 3 4]</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中，修改 slice 里面元素的值成功了，但是 append 失败了。因为 Golang 中传参数是复制的，对 slice 内部的 array 复制进去了，所以修改是成功的。但是 append 之后其实是将旧的 slice 复制到了新的 slice，然后已经是一个新的值了，所以修改是不成功的。</p><h2 id="new-amp-make"><a href="#new-amp-make" class="headerlink" title="new &amp; make"></a>new &amp; make</h2><p><code>new</code> 方法返回空值的结构体的指针，类似于 <code>&amp;File&#123;fd, name, nil, 0&#125;</code> 这样的结构，不过其内部的成员都各自为其类型对应的空值。</p><p><code>make</code> 用于 slice, channel, map 类型的初始化。与 <code>new</code> 不同的是，<code>make</code> 分配对象相应的指定的存储空间，但不会置对应的空值，不返回指针。</p><h2 id="重复声明和重复赋值"><a href="#重复声明和重复赋值" class="headerlink" title="重复声明和重复赋值"></a>重复声明和重复赋值</h2><p>Golang 中的 <code>:=</code> 是赋值和声明的简写，该符号左边至少需要有一个新的变量，如果对以后的变量进行操作则会报错。</p><p>需要注意的是，如果在外层作用域定义的变量，再用 <code>:=</code> 进行赋值操作的话，则会屏蔽掉外层作用域的变量，特别是循环内部判断 <code>error</code> 的时候需要特别注意。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++ &#123;<br>    j, err := f()<br><br>    fmt.Println(j)<br>    fmt.Println(err) <span class="hljs-comment">// some error</span><br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">break</span><br>    &#125;<br>&#125;<br>fmt.Println(err) <span class="hljs-comment">// nil</span><br></code></pre></td></tr></table></figure><h2 id="一点总结"><a href="#一点总结" class="headerlink" title="一点总结"></a>一点总结</h2><p>用 Golang 大概一个多月，除了上手时候有点纠结外，感觉这门语言还是很舒服的。当然，标准库和第三方库还是不能和 Python 比，但编译检查静态错误的这个点开发起来很舒服，一些可能的问题能够尽早的发现。</p><p>interface 这点的引入能够减少不少的重复代码，变量默认零值也能让人逃开奇奇怪怪的构造函数的坑。</p><p>感觉在开发大型项目上，特别是系统级软件会比较适合。在使用过 Python 开发之后，越发觉得有必要加强开发工具对人的约束，代码风格的统一以及对无用 import 和无用变量的约束能够对共同开发起到良好的补充。</p><p>之后如果有耐心，希望可以把几个 Golang 常用的场景写下</p><ol><li>Golang 的反射，动态修改</li><li>Golang 的并发</li><li>…</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://research.swtch.com/interfaces">interface 内存结构</a></li><li><a href="https://golang.org/doc/effective_go.html">Effective Go</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang 学习 3</title>
    <link href="/2016/07/04/golang-learning-3/"/>
    <url>/2016/07/04/golang-learning-3/</url>
    
    <content type="html"><![CDATA[<h2 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h2><p>Golang 中的包 <code>package</code> 是代码组织的基本单位。与 <code>struct</code> 的方法相同，大写字母开头的就是该包对外可以访问的方法，变量。</p><p>每个文件开头的 <code>package</code> 关键字用来标识该文件所在的包名，通常就是包含该文件的文件目录名。</p><p>当导入包遇到重名的时候，可以像下面的代码一样</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;crypto/rand&quot;</span><br>    mrand <span class="hljs-string">&quot;math/rand&quot;</span> <span class="hljs-comment">// alternative name mrand avoids conflict</span><br>)<br></code></pre></td></tr></table></figure><h3 id="匿名导入"><a href="#匿名导入" class="headerlink" title="匿名导入"></a>匿名导入</h3><p>因为在使用别的包的时候，如果仅仅是 import 但不使用的话是会报错的，但有种情况是仅仅希望执行某个包对应的 <code>init</code> 函数，因为在 import 的时候，会自动调用包里面各个文件的 <code>init</code> 函数。</p><p>像官网的例子，读取图片文件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;image&quot;</span><br>    <span class="hljs-string">&quot;image/jpeg&quot;</span><br>    _ <span class="hljs-string">&quot;image/png&quot;</span> <span class="hljs-comment">// register PNG decoder</span><br>)<br></code></pre></td></tr></table></figure><p>上述导入的 <code>image/png</code> 实际执行了以下的函数，详见 <a href="https://golang.org/src/image/png/reader.go#L847">源文件</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>    image.RegisterFormat(<span class="hljs-string">&quot;png&quot;</span>, pngHeader, Decode, DecodeConfig)<br>&#125;<br></code></pre></td></tr></table></figure><p>执行了 <a href="https://golang.org/src/image/format.go#L24">image&#x2F;format</a> 的 <code>RegisterFormat</code> 去注册解码器</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Formats is the list of registered formats.</span><br><span class="hljs-keyword">var</span> formats []format<br><br><span class="hljs-comment">// RegisterFormat registers an image format for use by Decode.</span><br><span class="hljs-comment">// Name is the name of the format, like &quot;jpeg&quot; or &quot;png&quot;.</span><br><span class="hljs-comment">// Magic is the magic prefix that identifies the format&#x27;s encoding. The magic</span><br><span class="hljs-comment">// string can contain &quot;?&quot; wildcards that each match any one byte.</span><br><span class="hljs-comment">// Decode is the function that decodes the encoded image.</span><br><span class="hljs-comment">// DecodeConfig is the function that decodes just its configuration.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">RegisterFormat</span><span class="hljs-params">(name, magic <span class="hljs-type">string</span>, decode <span class="hljs-keyword">func</span>(io.Reader)</span></span> (Image, <span class="hljs-type">error</span>), decodeConfig <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(io.Reader)</span></span> (Config, <span class="hljs-type">error</span>)) &#123;<br>    formats = <span class="hljs-built_in">append</span>(formats, format&#123;name, magic, decode, decodeConfig&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，这里的仅仅是用来读文件，如果需要对 png 进行操作的话，还是需要导入 png 的 package。除了这里的图片操作以外，数据库操作也是类似的 <a href="https://github.com/go-sql-driver/mysql#usage">代码</a>。</p><h3 id="工作区"><a href="#工作区" class="headerlink" title="工作区"></a>工作区</h3><p>Golang 中需要配置 <code>$GOPATH</code> 来指定工作区，换个角度来讲，只要控制 <code>$GOPATH</code> 就可以控制不同的工作区，防止不同的项目依赖互相污染。</p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>在编译的时候不知道变量的值，但是运行时可以进行检查判断，更新，这在 Golang 中就是反射。简单来说，反射是一种检验变量的类型和值的机制。这里面的操作对象是 interface。</p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> x <span class="hljs-type">float64</span> = <span class="hljs-number">3.4</span><br>v := reflect.ValueOf(x)<br>fmt.Println(<span class="hljs-string">&quot;type:&quot;</span>, v.Type())<br>fmt.Println(<span class="hljs-string">&quot;kind is float64:&quot;</span>, v.Kind() == reflect.Float64)<br>fmt.Println(<span class="hljs-string">&quot;value:&quot;</span>, v.Float())<br><br><span class="hljs-comment">// type: float64</span><br><span class="hljs-comment">// kind is float64: true</span><br><span class="hljs-comment">// value: 3.4</span><br></code></pre></td></tr></table></figure><h3 id="从-interface-value-到-reflection-object-的"><a href="#从-interface-value-到-reflection-object-的" class="headerlink" title="从 interface value 到 reflection object 的"></a>从 interface value 到 reflection object 的</h3><p>reflect pacakge 的两个基本函数 <code>reflect.TypeOf</code> 和 <code>reflect.ValueOf</code>，都是接收 <code>interface&#123;&#125;</code> 的参数。任何类型都包含 empty interface，所以任何 interface 都能转成 <code>interface&#123;&#125;</code>。</p><p>如上述的代码一样，可以通过判断 reflect object 的类型来进行相应的输出</p><h3 id="从-reflection-object-到-interface-object"><a href="#从-reflection-object-到-interface-object" class="headerlink" title="从 reflection object 到 interface object"></a>从 reflection object 到 interface object</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyInt <span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> x MyInt = <span class="hljs-number">7</span><br><br>    v := reflect.ValueOf(x)<br>    y := v.Interface().(MyInt) <span class="hljs-comment">// 这里如果用 int 会 panic</span><br><br>    fmt.Println(v)<br>    fmt.Println(v.Kind()) <span class="hljs-comment">// int</span><br>    fmt.Println(v.Type()) <span class="hljs-comment">// main.MyInt</span><br>    fmt.Println(y)<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码可以看到，<code>Kind</code> 方法不能正确辨识变量的类型，但 <code>Type</code> 可以，虽然底层类型都是一样的。</p><p>v 调用 <code>Interface</code> 之后返回的是 empty interface，可以用 <code>fmt.Println</code> 等方法能正确识别为 int 类型。</p><h3 id="想要修改-reflection-object，那该变量必须是-settable"><a href="#想要修改-reflection-object，那该变量必须是-settable" class="headerlink" title="想要修改 reflection object，那该变量必须是 settable"></a>想要修改 reflection object，那该变量必须是 settable</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> x <span class="hljs-type">float64</span> = <span class="hljs-number">3.4</span><br>v := reflect.ValueOf(x)<br>v.SetFloat(<span class="hljs-number">7.1</span>) <span class="hljs-comment">// panic</span><br><br>fmt.Println(<span class="hljs-string">&quot;settability of v:&quot;</span>, v.CanSet()) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>错误的原因是 <code>reflect.Value.SetFloat using unaddressable value</code>，该变量是无法寻址的。reflect 中，可寻址标识可以修改变量实际存储的东西。在上面的函数调用中，复制了 <code>x</code>，即使修改也只是对函数内部的临时变量进行修改。</p><p>改成指针</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">p := reflect.ValueOf(&amp;x) <span class="hljs-comment">// Note: take the address of x.</span><br>fmt.Println(<span class="hljs-string">&quot;type of p:&quot;</span>, p.Type())<br>fmt.Println(<span class="hljs-string">&quot;settability of p:&quot;</span>, p.CanSet()) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>指针也不行，我们实际需要修改的东西是 <code>p</code> 指向的内存，而不是 <code>p</code> 本身。正确的用法如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> x <span class="hljs-type">float64</span> = <span class="hljs-number">3.4</span><br>p := reflect.ValueOf(&amp;x)<br>v := p.Elem()<br><br>v.SetFloat(<span class="hljs-number">7.1</span>)<br>fmt.Println(v.Interface())<br>fmt.Println(x)<br>fmt.Println(v)<br></code></pre></td></tr></table></figure><p>这里有点绕，需要仔细理解下才行。</p><p>三个用法看下来发现其实反射用起来是比较危险的，因为无法进行静态分析，程序可能在某个地方就 panic 了，在实际场景中因该尽量避免使用反射。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://wizardforcel.gitbooks.io/gopl-zh/content/">Go 语言圣经</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang 学习 2</title>
    <link href="/2016/06/25/golang-learning-2/"/>
    <url>/2016/06/25/golang-learning-2/</url>
    
    <content type="html"><![CDATA[<h2 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h2><p>用于聚合数据的结构体，简单用法如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Employee <span class="hljs-keyword">struct</span> &#123;<br>    ID        <span class="hljs-type">int</span><br>    Name      <span class="hljs-type">string</span><br>    Address   <span class="hljs-type">string</span><br>    DoB       time.Time<br>    Position  <span class="hljs-type">string</span><br>    Salary    <span class="hljs-type">int</span><br>    ManagerID <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">var</span> dilbert Employee<br><br><span class="hljs-comment">// . 操作</span><br>dilbert.Salary = <span class="hljs-number">4000</span><br><br><span class="hljs-comment">// 指针也是同样</span><br>ptr := &amp;Employee&#123;&#125;<br>ptr.ID = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>结构体还是该结构体的指针，都支持 . 操作，两者是等效的。在需要传结构体当作参数的时候，最好是使用指针的方式，这就减少了复制结构体的成本。</p><p>结构体的成员大小写也跟 Go 本身的包导出规则类似，小写开头的参数如果使用在包外使用会报错。</p><h3 id="匿名嵌入"><a href="#匿名嵌入" class="headerlink" title="匿名嵌入"></a>匿名嵌入</h3><p>当需要一个结构体内加入另一个结构体的时候，可以用匿名成员，只在结构体内写类型或类型指针而不是成员变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> AA <span class="hljs-keyword">struct</span> &#123;<br>    A <span class="hljs-type">int</span><br>    C <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> BB <span class="hljs-keyword">struct</span> &#123;<br>    AA<br>    B <span class="hljs-type">int</span><br>    C <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-comment">// 直接访问而不是指定 b.AA.A</span><br><br>b := BB&#123;&#125;<br>b.A = <span class="hljs-number">1</span><br>b.B = <span class="hljs-number">2</span><br>b.C = <span class="hljs-number">3</span><br>b.AA.C = <span class="hljs-number">1111</span><br>fmt.Println(b) <span class="hljs-comment">// 结果 &#123;1 1111&#125; 2 3</span><br></code></pre></td></tr></table></figure><p>上面最后可以看到，如果是同名成员的话，会优先访问本类型的成员，忽略匿名成员，这点和其它语言类似。</p><p>但是初始化的时候还是得按照类型来。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">bb := BB&#123;<br>    AA: AA&#123;A: <span class="hljs-number">1</span>&#125;,<br>    B:  <span class="hljs-number">2</span>,<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>函数声明时，在函数前面加类型，则为该类型添加了一个方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Point <span class="hljs-keyword">struct</span> &#123;<br>    X <span class="hljs-type">float64</span><br>    Y <span class="hljs-type">float64</span><br>&#125;<br><br><span class="hljs-comment">// 这里如果使用 p Point 来声明，在使用的时候也是一样的</span><br><span class="hljs-comment">// 但是调用的时候会发生以此 Point 的复制，所以尽量使用指针</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Point)</span></span> ScaleBy(factor <span class="hljs-type">float64</span>) &#123;<br>    p.X *= factor<br>    p.Y *= factor<br>&#125;<br><br>Point&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;.ScaleBy(<span class="hljs-number">2</span>) <span class="hljs-comment">// 临时变量则无法获取其地址，不能这样用</span><br></code></pre></td></tr></table></figure><p>须明确一点，<strong>所有的函数调用都是传值的，哪怕是 receiver</strong>。所以对于数据量大的方法更多应该考虑指针的 receiver。</p><h2 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h2><h3 id="方法集合"><a href="#方法集合" class="headerlink" title="方法集合"></a>方法集合</h3><p>类似于 <code>duck typing</code> 的意思，<code>interface</code>是一种类型，它定义一组方法，任何有实现这些方法的类型都能使用。常用于函数的参数定义中，我们不去关心这个类型具体做什么，而是关心这个类型能不能做我们想要的某些东西。如下面的 <code>fmt.Stringer</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> fmt<br><span class="hljs-comment">// The String method is used to print values passed</span><br><span class="hljs-comment">// as an operand to any format that accepts a string</span><br><span class="hljs-comment">// or to an unformatted printer such as Print.</span><br><span class="hljs-keyword">type</span> Stringer <span class="hljs-keyword">interface</span> &#123;<br>    String() <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><p>假如有一个函数，需要使用上述的 <code>String()</code>，则你在函数声明的时候可以传入一个 <code>fmt.Stringer</code>，任何实现了 <code>String()</code> 方法的类型都可以使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testString</span><span class="hljs-params">(i fmt.Stringer)</span></span> &#123;<br>    fmt.Println(i.String())<br>&#125;<br><br><span class="hljs-keyword">type</span> Human <span class="hljs-keyword">struct</span> &#123;<br>    Name <span class="hljs-type">string</span><br>    Age  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h Human)</span></span> String() <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;Name %s, Age %d&quot;</span>, h.Name, h.Age)<br>&#125;<br></code></pre></td></tr></table></figure><p>值得注意的是，这里 <code>Human</code> 的 <code>String</code> 方法使用变量而不是指针作为 recevier。因为值类型的方法可以使用指针去访问，但是反过来不行。使用值类型的方法相对更通用一些。</p><h3 id="通用类型"><a href="#通用类型" class="headerlink" title="通用类型"></a>通用类型</h3><p>interface 无关是指针还是值，它是什么取决于你怎么去处理。</p><p>在很多标准库的定义中，很多函数接收 <code>v inteface&#123;&#125;</code> 的参数，意味着可以传入任何类型的变量。</p><p>使用原则简单来说就是 <a href="https://en.wikipedia.org/wiki/Robustness_principle">宽以待人，严于律己</a>，如果返回 interface 类型的话则会需要后人去猜测变量的类型。你会看到在许多的函数参数中都会有 interface 类型，使用上更多是传入一个指针，这样就可以确认函数修改 &#x2F; 更新的值是确定的。</p><h2 id="Goroutines-amp-amp-Channels"><a href="#Goroutines-amp-amp-Channels" class="headerlink" title="Goroutines &amp;&amp; Channels"></a>Goroutines &amp;&amp; Channels</h2><p>使用简单的语法就可以开启一个新的线程去执行函数</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">go</span> <span class="hljs-function"><span class="hljs-title">f</span>()</span><br></code></pre></td></tr></table></figure><p>主函数也是一个 <code>goroutine</code>，当主函数退出，所有的 <code>goroutine</code> 都会退出。</p><p>不同的 <code>goroutine</code> 之间使用 <code>channel</code> 进行通信，<code>channel</code> 是指定类型的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>) <span class="hljs-comment">// 无缓冲</span><br>ch1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// 有缓冲</span><br><br>ch &lt;- x  <span class="hljs-comment">// 发送</span><br>x = &lt;-ch <span class="hljs-comment">// 接收</span><br>&lt;-ch     <span class="hljs-comment">// 接收并抛弃</span><br></code></pre></td></tr></table></figure><p>上方代码中创建的无缓冲的 <code>channel</code>，这样子接受者和发送者都会同时阻塞，相当于两者做一次同步，当通过无缓冲的 <code>channel</code> 进行发送时，接受者收到数据发生在发送者唤醒之前。</p><p>需要注意的是，哪怕是有缓冲的 <code>channel</code> 在其没有元素的时候，接收动作 <code>&lt;-ch</code> 是阻塞的，直到有数据过来。</p><h3 id="select-的多路复用"><a href="#select-的多路复用" class="headerlink" title="select 的多路复用"></a>select 的多路复用</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ch1:<br>    <span class="hljs-comment">// ...</span><br><span class="hljs-keyword">case</span> x := &lt;-ch2:<br>    <span class="hljs-comment">// ...use x...</span><br><span class="hljs-keyword">case</span> ch3 &lt;- y:<br>    <span class="hljs-comment">// ...</span><br><span class="hljs-keyword">default</span>:<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当有多个 <code>channel</code> 需要进行监控的时候，可以用 <code>select</code> 的语法进行操作，只有在某个 <code>channel</code> 有数据时才会执行相应的 <code>case</code>，否则执行 <code>default</code> 块。</p><p><code>time</code> 包中有一个 Tick 函数能很方便地执行定时任务</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    tick := time.Tick(<span class="hljs-number">3</span> * time.Second)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;<br>        <span class="hljs-keyword">select</span> &#123;<br>        <span class="hljs-keyword">case</span> &lt;-tick:<br>            fmt.Println(<span class="hljs-string">&quot;Do Some Thing&quot;</span>)<br>        <span class="hljs-keyword">default</span>:<br>            fmt.Println(<span class="hljs-string">&quot;Sleep 1s&quot;</span>)<br>            time.Sleep(time.Duration(<span class="hljs-number">1</span>) * time.Second)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 输出如下</span><br>Sleep <span class="hljs-number">1</span>s<br>Sleep <span class="hljs-number">1</span>s<br>Sleep <span class="hljs-number">1</span>s<br>Do Some Thing<br>Sleep <span class="hljs-number">1</span>s<br>Sleep <span class="hljs-number">1</span>s<br>Sleep <span class="hljs-number">1</span>s<br>Do Some Thing<br>Sleep <span class="hljs-number">1</span>s<br>Sleep <span class="hljs-number">1</span>s<br>Sleep <span class="hljs-number">1</span>s<br>Do Some Thing<br>Sleep <span class="hljs-number">1</span>s<br>Sleep <span class="hljs-number">1</span>s<br>Sleep <span class="hljs-number">1</span>s<br>Do Some Thing<br>Sleep <span class="hljs-number">1</span>s<br>...<br></code></pre></td></tr></table></figure><h3 id="channel-泄漏"><a href="#channel-泄漏" class="headerlink" title="channel 泄漏"></a>channel 泄漏</h3><p>上述代码中，<code>tick</code> 在循环之外还会继续作用，这种情况叫做 <code>channel</code> 的泄漏，它只适合用在整个程序生命周期都存在的情况。</p><p>当你试图去 <code>close</code> 的时候，则会报错</p><blockquote><p>invalid operation: close(tick) (cannot close receive-only channel)</p></blockquote><p>还有另一种 tick 能使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">ticker := time.NewTicker(<span class="hljs-number">1</span> * time.Second)<br>&lt;-ticker.C    <span class="hljs-comment">// receive from the ticker&#x27;s channel</span><br>ticker.Stop() <span class="hljs-comment">// cause the ticker&#x27;s goroutine to terminate</span><br></code></pre></td></tr></table></figure><h3 id="退出多个-goroutine"><a href="#退出多个-goroutine" class="headerlink" title="退出多个 goroutine"></a>退出多个 goroutine</h3><p>如果维护了多个 goroutine 的话，需要类似于广播的一类事件，可以通过关闭一个 channel 来进行类似的操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> done = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;) <span class="hljs-comment">// 注意是无缓冲的</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">cancelled</span><span class="hljs-params">()</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-done:<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">worker</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> &#123;<br>        <span class="hljs-keyword">if</span> cancelled() &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>        fmt.Printf(<span class="hljs-string">&quot;worker %d work\n&quot;</span>, i)<br>        time.Sleep(time.Duration(<span class="hljs-number">1</span>) * time.Second)<br>    &#125;<br>    fmt.Printf(<span class="hljs-string">&quot;worker %d cancelled\n&quot;</span>, i)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">manager</span><span class="hljs-params">()</span></span> &#123;<br>    time.Sleep(time.Duration(<span class="hljs-number">2</span>) * time.Second)<br>    fmt.Println(<span class="hljs-string">&quot;close workers&quot;</span>)<br>    <span class="hljs-built_in">close</span>(done)<br>    time.Sleep(time.Duration(<span class="hljs-number">5</span>) * time.Second)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br>        j := i<br>        <span class="hljs-keyword">go</span> worker(j)<br>    &#125;<br>    manager()<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="一些有趣的文章"><a href="#一些有趣的文章" class="headerlink" title="一些有趣的文章"></a>一些有趣的文章</h2><ol><li><a href="http://marcio.io/2015/07/handling-1-million-requests-per-minute-with-golang/">Handling 1 Million Requests per Minute with Go</a></li><li><a href="http://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go">Golang 的 interface</a></li><li><a href="http://research.swtch.com/interfaces">Golang interface 的内存实现</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang 学习 1</title>
    <link href="/2016/06/07/golang-learning-1/"/>
    <url>/2016/06/07/golang-learning-1/</url>
    
    <content type="html"><![CDATA[<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>不可变的字节序列。对于不同编码的字符串所有都是同样的操作，字符串的每一位都是一个 ASCII 值，需要额外进处理去解析 unicode 字符串。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;unicode/utf8&quot;</span><br><br>s := <span class="hljs-string">&quot;Hello, 世界&quot;</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); &#123;<br>    r, size := utf8.DecodeRuneInString(s[i:])<br>    fmt.Printf(<span class="hljs-string">&quot;%d\t%c\n&quot;</span>, i, r)<br>    i += size<br>&#125;<br><br><span class="hljs-comment">// 也可以使用 range，Go 本身会自动处理 unicode</span><br><span class="hljs-comment">// 步长的递进可以看到也不是 1</span><br><span class="hljs-keyword">for</span> i, r := <span class="hljs-keyword">range</span> <span class="hljs-string">&quot;Hello, 世界&quot;</span> &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;%d\t%q\t%d\n&quot;</span>, i, r, r)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量的值在编译期间就确定了。常量定义可用一个 <code>iota</code> 去生成，类似于枚举类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Weekday <span class="hljs-type">int</span><br><br><span class="hljs-keyword">const</span> (<br>    Sunday Weekday = <span class="hljs-literal">iota</span> <span class="hljs-comment">// 0</span><br>    Monday                <span class="hljs-comment">// 1 以下以此类推</span><br>    Tuesday<br>    Wednesday<br>    Thursday<br>    Friday<br>    Saturday<br>)<br></code></pre></td></tr></table></figure><h3 id="无类型常量"><a href="#无类型常量" class="headerlink" title="无类型常量"></a>无类型常量</h3><p>如果常量的定义的时候不指定类型，如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>    E = <span class="hljs-number">2.71828182845904523536028747135266249775724709369995957496696763</span><br>)<br></code></pre></td></tr></table></figure><p>编译器会提供一个比基础类型更高的运算精度，并且可以无需显式的类型转换就能直接赋值给基础类型。 </p><h2 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>固定长度的特定元素的序列，因为不可扩展，一般直接用 <code>slice</code>。</p><h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><p>与数组不同的是，在初始化的时候无需指定长度。而且对 slice 的比较操作也是非法的。</p><p>需要注意的是，slice 的切片操作不是复制，而是引用，意味着修改会改变原始数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">a := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br>b := a[:<span class="hljs-number">3</span>]<br>b[<span class="hljs-number">0</span>] = <span class="hljs-number">12313</span><br><br><span class="hljs-comment">// a = [12313 2 3 4 5]</span><br><span class="hljs-comment">// b = [12313 2 3]</span><br></code></pre></td></tr></table></figure><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map 可以用于和 <code>nil</code> 进行比较，但赋值操作必须先进行 <code>make</code> 来创建 map。</p><p>可以用 <code>map[string]bool</code> 来实现简单的 set 操纵</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">set := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>)<br>set[<span class="hljs-string">&quot;a&quot;</span>] = <span class="hljs-literal">true</span><br><br>fmt.Println(set[<span class="hljs-string">&quot;a&quot;</span>]) <span class="hljs-comment">// true</span><br>fmt.Println(set[<span class="hljs-string">&quot;b&quot;</span>]) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>因为类型是确定的，所以在使用的时候可以放心使用，在不存在 key 的情况下返回的都是该类型的空值。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>Go 中函数是 first-class function，函数的参数传递是值传递，因此引用类型的传递会对函数体外的变量进行修改。</p><p>函数声明时，可提供返回值的参数变量名，之后该变量就会被声明成该函数内部的一个局部变量，按照该类型来进行初始化，返回时也不需要明确返回。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum</span><span class="hljs-params">(x, y <span class="hljs-type">float64</span>)</span></span> (z <span class="hljs-type">float64</span>) &#123;<br>    z = x + y<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum</span><span class="hljs-params">(vals...<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    total := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, val := <span class="hljs-keyword">range</span> vals &#123;<br>        total += val<br>    &#125;<br>    <span class="hljs-keyword">return</span> total<br>&#125;<br><br><span class="hljs-comment">// 对于一个 slice 可以用下面的方法求和</span><br>values := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br>fmt.Println(sum(values...)) <span class="hljs-comment">// &quot;10&quot;</span><br></code></pre></td></tr></table></figure><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><h4 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h4><p>Go 中使用 <code>defer</code> 关键字来指定在函数 return 之后的操作，如常见的打开文件，关闭文件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// src.Close() 在 return 之后执行</span><br>src, err := os.Open(srcName)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">defer</span> src.Close()<br></code></pre></td></tr></table></figure><p>这里有几个点需要注意的</p><p>1 <code>defer</code>中的函数参数是声明的时候确定的，与 <code>return</code> 的位置无关</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span> &#123;<br>    i := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">defer</span> fmt.Println(i) <span class="hljs-comment">// print 0</span><br>    i++<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p>2 <code>defer</code> 的执行顺序为 FILO，后声明的 <code>defer</code> 先执行</p><p>3 <code>defer</code> 可以更新命名的返回值（named return variables）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">c</span><span class="hljs-params">()</span></span> (i <span class="hljs-type">int</span>) &#123;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; i++ &#125;() <span class="hljs-comment">// return 2</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="panic-amp-recover"><a href="#panic-amp-recover" class="headerlink" title="panic &amp; recover"></a>panic &amp; recover</h4><p><code>panic</code> 函数执行之后，正常的函数流程就会停止，转去执行 <code>defer</code> 定义的行为。</p><p><code>recover</code> 只能在 <code>defer</code> 内的函数使用。三者加起来的用法大概如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    f()<br>    fmt.Println(<span class="hljs-string">&quot;Returned normally from f.&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">if</span> r := <span class="hljs-built_in">recover</span>(); r != <span class="hljs-literal">nil</span> &#123;<br>            fmt.Println(<span class="hljs-string">&quot;Recovered in f&quot;</span>, r)<br>        &#125;<br>    &#125;()<br>    fmt.Println(<span class="hljs-string">&quot;Calling g.&quot;</span>)<br>    g(<span class="hljs-number">0</span>)<br>    fmt.Println(<span class="hljs-string">&quot;Returned normally from g.&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">g</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">3</span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;Panicking!&quot;</span>)<br>        <span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;%v&quot;</span>, <span class="hljs-string">&quot;asdadada&quot;</span>))<br>    &#125;<br>    <span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;Defer in g&quot;</span>, i)<br>    fmt.Println(<span class="hljs-string">&quot;Printing in g&quot;</span>, i)<br>    g(i + <span class="hljs-number">1</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>最后的输出</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Calling</span> g.<br><span class="hljs-attribute">Printing</span> in g <span class="hljs-number">0</span><br><span class="hljs-attribute">Printing</span> in g <span class="hljs-number">1</span><br><span class="hljs-attribute">Printing</span> in g <span class="hljs-number">2</span><br><span class="hljs-attribute">Printing</span> in g <span class="hljs-number">3</span><br><span class="hljs-attribute">Panicking</span>!<br><span class="hljs-attribute">Defer</span> in g <span class="hljs-number">3</span><br><span class="hljs-attribute">Defer</span> in g <span class="hljs-number">2</span><br><span class="hljs-attribute">Defer</span> in g <span class="hljs-number">1</span><br><span class="hljs-attribute">Defer</span> in g <span class="hljs-number">0</span><br><span class="hljs-attribute">Recovered</span> in f asdadada<br><span class="hljs-attribute">Returned</span> normally from f.<br></code></pre></td></tr></table></figure><p>可以简单的看出</p><ol><li><code>Panicking</code> 是在所有的 <code>defer</code> 执行之后再进行工作</li><li><code>recover</code> 可以简单的理解为在 <code>defer</code> 中处理 <code>panic</code> 函数传过来的值</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.gitbook.com/book/wizardforcel/gopl-zh/details">gopl-zh</a></li><li><a href="https://blog.golang.org/defer-panic-and-recover">defer, panic and recover</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang 开发配置 @ ubuntu 16.04 LTS</title>
    <link href="/2016/05/29/golang-at-ubuntu-16.04/"/>
    <url>/2016/05/29/golang-at-ubuntu-16.04/</url>
    
    <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>ubuntu 16.04 的源的 Golang 的版本是 1.6+ 的，不用像 14.04 那样需要自己手动去更新版本。</p><p>在 <code>$HOME/.zshrc</code> 上配置该变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> GOPATH=/home/lycheng/projects/go<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-string">&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:<span class="hljs-variable">$GOPATH</span>/bin&quot;</span><br></code></pre></td></tr></table></figure><p>其中 <code>$GOPATH</code> 是一个重要的环境变量，该目录用于存放源代码和可执行文件。大概的结构如下</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">├── bin <span class="hljs-comment"># 可执行文件</span><br>│   ├── govendor<br>│   ├── motion<br>│   └── <span class="hljs-string">...</span><br>├── pkg <span class="hljs-comment"># 外部的包依赖</span><br>│   └── linux_amd64<br>│       ├── 9fans.net<br>│       ├── github.com<br>│       └── <span class="hljs-string">...</span><br>└── src <span class="hljs-comment"># 源代码</span><br>    ├── 9fans.net<br>    │   └── go<br>    ├── github.com<br>    │   ├── alecthomas<br>    │   ├── aws<br>    │   └── <span class="hljs-string">...</span><br>    ├── golang.org<br>    │   └── x<br>    ├── gopkg.in<br>    │   └── alecthomas<br>    └── sourcegraph.com<br>        └── sqs<br></code></pre></td></tr></table></figure><p>基本上开发实在 <code>$GOPATH/src/github.com/&#123;username&#125;/&#123;project&#125;</code> 下进行，同时使用 github 作为版本管理平台，完美。</p><h2 id="编辑器-x2F-IDE"><a href="#编辑器-x2F-IDE" class="headerlink" title="编辑器 &#x2F; IDE"></a>编辑器 &#x2F; IDE</h2><p>我的主力开发工具是 vim</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 16.04 里面的没人 vim 不开 python 支持了</span><br><span class="hljs-comment"># 这是单纯的命令行版本</span><br>sudo apt-get install vim-nox<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 也可以使用别的项目</span><br><span class="hljs-comment"># 主要是需要 https://github.com/fatih/vim-go</span><br>git <span class="hljs-built_in">clone</span> git://github.com/lycheng/dot-vimrc.git ~/.vim<br><span class="hljs-built_in">ln</span> -s ~/.vim/vimrc ~/.vimrc<br>git <span class="hljs-built_in">clone</span> https://github.com/gmarik/vundle.git ~/.vim/bundle/vundle<br></code></pre></td></tr></table></figure><p>在 vim 里面</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clojure"><span class="hljs-symbol">:BundleInstall</span><br><span class="hljs-symbol">:GoInstallBinaries</span><br></code></pre></td></tr></table></figure><p>编译 YCM</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/.vim/bundle/YouCompleteMe<br>./install.py --clang-completer --gocode-completer<br></code></pre></td></tr></table></figure><p>YCM 不是一个必要的条件，可参考文末的 <a href="http://farazdagi.com/blog/2015/vim-as-golang-ide/">文章</a> 去配置 <code>neocomplete.vim</code> 作为代码提示插件。</p><p>idea 和 vscode 都有对 Golang 很好的支持，一般情况下我都是开着 vscode 看代码然后使用 vim 进行开发。</p><p>因为众所周知的原因，vim vscode 不少的依赖是需要架梯子去下载的。可设置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> http_proxy=http://127.0.0.1:1080/<br><span class="hljs-built_in">export</span> https_proxy=<span class="hljs-variable">$http_proxy</span><br></code></pre></td></tr></table></figure><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><p>一般普通的包的安装只要简单的命令即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go get -u github.com/kardianos/govendor<br></code></pre></td></tr></table></figure><p><code>go get</code> 命令包含两层意思</p><ol><li>下载源码包到 <code>$GOPATH/src/..</code> 中</li><li>生成链接对象 （*.a） 到 <code>$GOPATH/pkg/...</code> 中，如有必要也会生成可执行文件到 <code>$GOPATH/bin</code> 中</li></ol><p>用该命令能很方便的进行 Golang 的第三方包的下载，实际使用的使用也只需要</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;github.com/&#123;username&#125;/&#123;proj&#125;/&#123;package&#125;...&quot;</span><br></code></pre></td></tr></table></figure><p>就能正常使用了。但如果需要项目级别的依赖管理，就需要用到 <code>govendor</code></p><h3 id="govendor"><a href="#govendor" class="headerlink" title="govendor"></a>govendor</h3><p>使用 govendor 必须是要求 Golang 版本 1.5+。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go get -u github.com/kardianos/govendor<br></code></pre></td></tr></table></figure><p>基本用法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Setup your project.</span><br><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;my project in GOPATH&quot;</span><br>govendor init<br><br><span class="hljs-comment"># Add existing GOPATH files to vendor.</span><br>govendor add +external<br><br><span class="hljs-comment"># View your work.</span><br>govendor list<br><br><span class="hljs-comment"># Look at what is using a package</span><br>govendor list -v <span class="hljs-built_in">fmt</span><br><br><span class="hljs-comment"># Specify a specific version or revision to fetch</span><br>govendor fetch golang.org/x/net/context@a4bbce9fcae005b22ae5443f6af064d80a6f5a55<br>govendor fetch golang.org/x/net/context@v1   <span class="hljs-comment"># Get latest v1.*.* tag or branch.</span><br>govendor fetch golang.org/x/net/context@=v1  <span class="hljs-comment"># Get the tag or branch named &quot;v1&quot;.</span><br><br><span class="hljs-comment"># Update a package to latest, given any prior version constraint</span><br>govendor fetch golang.org/x/net/context<br></code></pre></td></tr></table></figure><p>初始化之后 govendor 会在项目文件内创建一个 vendor 的文件夹，会将相应的第三方依赖下载到该目录下，目录的组织机构和 <code>$GOPATH</code> 一样。</p><p>更多的细节可见 <a href="https://github.com/kardianos/govendor">这里</a></p><h2 id="个人见解"><a href="#个人见解" class="headerlink" title="个人见解"></a>个人见解</h2><p>在用了两年 Python 之后，再来尝试 Golang，其实第一感觉是它的语法挺啰嗦的。然后认认真真写了几天代码之后其实感觉挺好的，啰嗦带来的好处就是有些问题，特别是变量的类型问题在运行前就可以发现了，<code>go fmt</code> 带来的好处是各个人的代码都起码不会太难看。</p><p>因为是静态类型，各种工具的支持很棒，例如 <a href="https://sourcegraph.com/">这个</a> 东西就很棒，在 github 上看代码太舒服了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://farazdagi.com/blog/2015/vim-as-golang-ide/">配置 VIM 作为 IDE</a></li><li><a href="https://sourcegraph.com/">一个超棒的 chrome 插件 &#x2F; 网站，用于浏览 github 的源代码，目前只支持 Golang</a></li><li><a href="https://github.com/kardianos/govendor">govendor</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>virtualenvwrapper 使用记录</title>
    <link href="/2016/03/12/virtualenvwrapper/"/>
    <url>/2016/03/12/virtualenvwrapper/</url>
    
    <content type="html"><![CDATA[<p><a href="http://virtualenvwrapper.readthedocs.org/en/latest/">virtualenvwrapper</a> 是个方便管理 virtualenv 工具。</p><h2 id="初始化环境"><a href="#初始化环境" class="headerlink" title="初始化环境"></a>初始化环境</h2><p>当前使用的是 Arch 所以默认版本为 python3，以下为在该环境下的使用方法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pip2 install virtualenvwrapper<br>...<br>export WORKON_HOME=~/Envs<br>mkdir -p $WORKON_HOME<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在使用默认版本 py3 的环境里面，如果需要使用 py2 的话，则需要另外加一行</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果只是 py3 的话不需要理会</span><br>export VIRTUALENVWRAPPER_PYTHON=/usr/local/bin/python2.7<br><br>source /usr/bin/virtualenvwrapper.sh<br>mkvirtualenv env<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">加载系统现有的包去初始化环境</span><br>mkvirtualenv env --system-site-packages<br></code></pre></td></tr></table></figure><p>在 <code>.zshrc</code> 中加入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">source /usr/bin/virtualenvwrapper.sh<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">具体的文件位置不一定</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">官方文档的例子是 <span class="hljs-built_in">source</span> /usr/local/bin/virtualenvwrapper.sh</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">可用 find / -name virtualenvwrapper.sh 去确定.</span><br></code></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建环境</span><br>mkvirtualenv <span class="hljs-built_in">env</span><br><br>pip2 install requests<br><br><span class="hljs-comment"># 切换环境</span><br>workon env2<br><br><span class="hljs-comment"># 离开环境</span><br>deactivate<br><br><span class="hljs-comment"># 查看当前环境安装的包</span><br>lssitepackages<br><br><span class="hljs-comment"># 其他操作</span><br>lsvirtualenv, rmvirtualenv<br></code></pre></td></tr></table></figure><h2 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 在已有的项目使用虚拟环境，然后在下次进入该项目的时候就回自动启用虚拟环境</span><br><br><span class="hljs-attribute">setvirtualenvproject</span><span class="hljs-meta"> [virtualenv_path project_path]</span><br></code></pre></td></tr></table></figure><p>在设置了虚拟环境之后，执行 <code>workon env</code> 就可以自动跳转到项目路径，如果在别的路径下面使用可以不自动跳转 <code>workon env -n</code></p><h2 id="其它一些东西"><a href="#其它一些东西" class="headerlink" title="其它一些东西"></a>其它一些东西</h2><p>如果需要在 env 环境下手动安装依赖，需要指定 python，如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">/home/lycheng/Env/tw/bin/python setup.py install<br></code></pre></td></tr></table></figure><p>命令行更好的提示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-variable">$WORKON_HOME</span>/postactivate</span><br>PS1=&quot;$_OLD_VIRTUAL_PS1&quot;<br>_OLD_RPROMPT=&quot;$RPROMPT&quot;<br>RPROMPT=&quot;%&#123;$&#123;fg_bold[white]&#125;%&#125;(env: %&#123;$&#123;fg[green]&#125;%&#125;`basename \&quot;$VIRTUAL_ENV\&quot;`%&#123;$&#123;fg_bold[white]&#125;%&#125;)%&#123;$&#123;reset_color&#125;%&#125; $RPROMPT&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-variable">$WORKON_HOME</span>/postdeactivate</span><br>RPROMPT=&quot;$_OLD_RPROMPT&quot;<br></code></pre></td></tr></table></figure><h2 id="暂时的问题"><a href="#暂时的问题" class="headerlink" title="暂时的问题"></a>暂时的问题</h2><p>目前还有的问题就是，通过 cd 真的会自动切换虚拟环境，但是在 tmux 中，新建 session，切分窗口也不能自动使用路径对应的虚拟环境。必须手动重新加载一次。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://virtualenvwrapper.readthedocs.org/en/latest/index.html">官方文档</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>virtualenv</tag>
      
      <tag>virtualenvwrapper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript 面向对象</title>
    <link href="/2015/12/20/javascript-oo/"/>
    <url>/2015/12/20/javascript-oo/</url>
    
    <content type="html"><![CDATA[<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p>以下是几种创建对象的方法</p><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createPerson</span>(<span class="hljs-params">name, age</span>) &#123;<br>  <span class="hljs-keyword">var</span> o = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>(&#123;&#125;);<br>  o.<span class="hljs-property">name</span> = name;<br>  o.<span class="hljs-property">age</span> = age;<br>  o.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(o.<span class="hljs-property">name</span>);<br>  &#125;;<br>  <span class="hljs-keyword">return</span> o;<br>&#125;<br></code></pre></td></tr></table></figure><p>缺点是：无法识别对象</p><h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>  &#125;;<br>&#125;<br><span class="hljs-keyword">var</span> persion1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;lycheng&quot;</span>, <span class="hljs-number">123</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1.<span class="hljs-property">constructor</span> == <span class="hljs-title class_">Person</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>上述代码中，如果不用 <code>new</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> person2 = <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;person2&quot;</span>, <span class="hljs-number">123</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person2); <span class="hljs-comment">// undefined</span><br><span class="hljs-variable language_">global</span>.<span class="hljs-title function_">sayName</span>(); <span class="hljs-comment">// person2</span><br></code></pre></td></tr></table></figure><p>因为当在全局环境中调用函数，<code>this</code> 总是指向 <code>global</code>，所以在使用构造函数的时候必须使用 <code>new</code> 来新建对象。</p><p>构造函数模式比起工厂模式更加像面向对象了，但是有个问题就是内部的函数都是每个对象不同的。意味着在新建对象的时候又要重新新建一个方法对象。</p><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;<br>&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;lycheng&quot;</span>;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">age</span> = <span class="hljs-number">25</span>;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>,name);<br>&#125;;<br><br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><span class="hljs-keyword">var</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1.<span class="hljs-property">sayName</span> == person2.<span class="hljs-property">sayName</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>从上面的代码可见，对象 person1 和 person2 的 sayName 函数是同一个了。也可以才用下方的字面值的写法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;<br>&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;<br>  <span class="hljs-attr">constructor</span>: <span class="hljs-title class_">Person</span>, <span class="hljs-comment">// 用于类型判断</span><br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;lycheng&quot;</span>,<br>  <span class="hljs-attr">skills</span>: [<span class="hljs-string">&quot;javascript&quot;</span>, <span class="hljs-string">&quot;python&quot;</span>],<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">25</span>,<br>  <span class="hljs-attr">sayName</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>简单的原型模式大概如此，这种方法的问题在于，没有构造函数，所有的实例共享所有的变量，如果是引用类型的化，则会出现问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>person1.<span class="hljs-title function_">sayName</span>();<br>person1.<span class="hljs-property">skills</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;linux&quot;</span>);<br><br><span class="hljs-keyword">var</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person2.<span class="hljs-property">skills</span>);  <span class="hljs-comment">// [ &#x27;javascript&#x27;, &#x27;python&#x27;, &#x27;linux&#x27; ]</span><br></code></pre></td></tr></table></figure><h3 id="组合使用构造函数和原型"><a href="#组合使用构造函数和原型" class="headerlink" title="组合使用构造函数和原型"></a>组合使用构造函数和原型</h3><p>所以常用的会有混合使用构造函数和原型对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">skills</span> = [];<br>&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;<br>  <span class="hljs-attr">sayName</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;lycheng&quot;</span>, <span class="hljs-number">25</span>);<br>person1.<span class="hljs-property">skills</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;linux&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1.<span class="hljs-property">skills</span>); <span class="hljs-comment">// [ &quot;linux&quot; ]</span><br><br><span class="hljs-keyword">var</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;lyc&quot;</span>, <span class="hljs-number">18</span>);<br>person2.<span class="hljs-property">skills</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;vim&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person2.<span class="hljs-property">skills</span>); <span class="hljs-comment">// [ &quot;vim&quot; ]</span><br></code></pre></td></tr></table></figure><p>这种是比较常用的方法，还有更多的动态原型模式，寄生构造函数模式就不一一赘述了。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>在之前的文章里也提到过原型，javascript 实现面向对象主要通过原型来实现。通过使用原型，可以实现实例对象共有的方法。这种原型对象的关系称为原型链。</p><p>每个对象都有原型，通过指针可以查看原型对象，直到最后为 null。通过这样的方法，如果一个对象的原型指向另一个对象，就可以通过这样的方式实现继承。</p><h3 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params">name, age</span>) &#123;<br>  <span class="hljs-comment">// 继承属性</span><br>  <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name, age);<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br><br><span class="hljs-comment">// 继承方法</span><br><span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Student</span>;<br><br><span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayAge</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>);<br>&#125;;<br><br><span class="hljs-keyword">var</span> student = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;lycheng&quot;</span>, <span class="hljs-number">25</span>);<br>student.<span class="hljs-title function_">sayName</span>();<br>student.<span class="hljs-title function_">sayAge</span>();<br></code></pre></td></tr></table></figure><p>上述代码中主要通过构造函数来继承实例属性，通过原型链来实现原型方法和属性的继承。</p><h3 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create"></a>Object.create</h3><p>ES5 中可以使用新的方法实现继承，将上述的代码改成如下即可</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-type">Student</span>.proto<span class="hljs-keyword">type</span> = <span class="hljs-type">Object</span>.create(<span class="hljs-type">Person</span>.prototype);<br></code></pre></td></tr></table></figure><p>简单来讲</p><blockquote><p>new X is Object.create(X.prototype) with additionally running the constructor function.</p></blockquote><p><code>Object.create</code> 执行构造函数，但其实我们这里并不需要构造函数，我们仅仅需要的是它的原型部分。但这里两者起到的作用是一样的。</p><h2 id="个人想法"><a href="#个人想法" class="headerlink" title="个人想法"></a>个人想法</h2><p>javascript 一些面向对象的实现看起来很诡异，感觉像是硬要为了实现面向对象而将这一套方法论套在基于原型的 javascript 里面。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://www.ituring.com.cn/book/946">Javascript 高级程序设计</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain">继承与原型链</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript#JavaScript_Review">javascript 面向对象介绍</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create">create</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react 安利文</title>
    <link href="/2015/12/06/about-react/"/>
    <url>/2015/12/06/about-react/</url>
    
    <content type="html"><![CDATA[<p><a href="https://facebook.github.io/react/">React</a> 是 Facebook 开源的一款 <em>仅仅</em> 是 javascript 库。当然，现在已经是讲类似的理念推广到了 React Native 去，用于开发 Android 和 iOS 的程序。</p><p>这篇文章是一篇 <em>安利</em> 文，没有涉及到更多的高深的东西，老手请右上角。</p><h2 id="基本的东西"><a href="#基本的东西" class="headerlink" title="基本的东西"></a>基本的东西</h2><h3 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> <span class="hljs-title class_">TodoList</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createClass</span>(&#123;<br>  <span class="hljs-attr">render</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> createItem = <span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;item.id&#125;</span>&gt;</span>&#123;item.text&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>;<br>    &#125;;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>&#123;this.props.items.map(createItem)&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span>;<br>  &#125;<br>&#125;);<br><span class="hljs-keyword">var</span> <span class="hljs-title class_">TodoApp</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createClass</span>(&#123;<br>  <span class="hljs-attr">getInitialState</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">items</span>: [], <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;&#x27;</span>&#125;;<br>  &#125;,<br>  <span class="hljs-attr">onChange</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<span class="hljs-attr">text</span>: e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>&#125;);<br>  &#125;,<br>  <span class="hljs-attr">handleSubmit</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>    e.<span class="hljs-title function_">preventDefault</span>();<br>    <span class="hljs-keyword">var</span> nextItems = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">items</span>.<span class="hljs-title function_">concat</span>([&#123;<span class="hljs-attr">text</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">text</span>, <span class="hljs-attr">id</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()&#125;]);<br>    <span class="hljs-keyword">var</span> nextText = <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<span class="hljs-attr">items</span>: nextItems, <span class="hljs-attr">text</span>: nextText&#125;);<br>  &#125;,<br>  <span class="hljs-attr">render</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>TODO<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">TodoList</span> <span class="hljs-attr">items</span>=<span class="hljs-string">&#123;this.state.items&#125;</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">&#123;this.handleSubmit&#125;</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;this.onChange&#125;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;this.state.text&#125;</span> /&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>&#123;&#x27;Add #&#x27; + (this.state.items.length + 1)&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;);<br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">TodoApp</span> /&gt;</span></span>, mountNode);<br></code></pre></td></tr></table></figure><p>这是个官网偷回来的例子，简单来说就是一个输入，enter 之后添加一个 ToDoList 的条目。基本结构再 ToDoApp 的 render 函数里面可以看到。</p><p>在 render 里面也可以看到通过参数调用 ToDoList 去渲染已经添加的 ToDo 条目。</p><h3 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h3><p>上述的不像 javascript 的代码是 jsx，最后真正使用的时候需要编译成 javascript 来写，当然也可以用 react 手写 javascript，那会麻烦很多。</p><p>值得一提的是，我刚开始用的时候，编译需要用到 <code>JSXTransformer.js</code> 这个东西，在官网新版已经不见了。新版使用的是 <a href="https://babeljs.io/">babel</a> 进行编译。Google 搜出来第一个中文的关于 React 的网站就是使用的旧版，除了编译以外，一些调用方法也发生了改变。</p><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p>这个是核心的东西，上述代码中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<span class="hljs-attr">items</span>: nextItems, <span class="hljs-attr">text</span>: nextText&#125;);<br></code></pre></td></tr></table></figure><p>调用该函数之后，React 会重新渲染，重新执行 render 函数去生成新的页面。每次重新生成的时候，会通过 diff 去判断哪些元素需要更新，而不是全部是重新刷新。</p><p>但不是所有的变量都需要 state，大部分的变量只需要 props 就好了。</p><h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><p>在上面的例子我们看到，我们定义了两个类 TodoApp 和 TodoList。两者是一个从属关系，当页面逻辑比较丰富的时候，可以抽出更多的类，一些也可以复用。关系如下</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">TodoApp<br><span class="hljs-bullet">- </span>ToDoList<br></code></pre></td></tr></table></figure><p>如果需要更复杂的关系，可以新增一个 ToDoItem</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">ToDoApp<br><span class="hljs-bullet">-</span> ToDoList<br><span class="hljs-bullet"> -</span> ToDoItem<br></code></pre></td></tr></table></figure><p>没有用过除了 jQuery 的前端库，第一次用下来的感觉是非常流畅，没有之前用 jQuery 时候的割裂感。这个感觉是之前感觉是数据和展现是脱节的，需要手动去处理很多数据变更之后的东西，清理现场等等。</p><p>这篇 <a href="https://facebook.github.io/react/docs/reconciliation.html">文章</a> 聊了下 react 组件化的东西，强烈推荐。</p><h2 id="总结下"><a href="#总结下" class="headerlink" title="总结下"></a>总结下</h2><p>在公司项目中一次开发中，因为前一晚刚好看了下 react 的东西，于是觉得合适就开始用起来了，基本没有门槛，分类分层次组件的东西写起来感觉很清爽，很多时候只需要注意维护 state 就好了。</p><p>感觉是前端这块工具发展得很快，多尝试下各种新的东西对自己一些思维上的帮助是很大的。react 这种组件的方式对于我这种一直用着 jQuery 那种库来写前端的人来说简直就是一次思维方式的洗礼。</p><h2 id="更多好玩的东西"><a href="#更多好玩的东西" class="headerlink" title="更多好玩的东西"></a>更多好玩的东西</h2><ol><li><a href="https://blog.coding.net/blog/React-server-rendering">React 服务器渲染</a></li><li><a href="https://facebook.github.io/react/docs/reconciliation.html">React Diff</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于 《Python 学习笔记》</title>
    <link href="/2015/12/03/about-python-reading-notes/"/>
    <url>/2015/12/03/about-python-reading-notes/</url>
    
    <content type="html"><![CDATA[<p>最近看 <a href="https://github.com/qyuhen/book">Python 学习笔记</a> 记录下一些之前没注意的东西。</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><h3 id="虚拟机初始化顺序"><a href="#虚拟机初始化顺序" class="headerlink" title="虚拟机初始化顺序"></a>虚拟机初始化顺序</h3><ol><li>创建解释器和主线程状态对象,这是整个进程的根对象。</li><li>初始化内置类型。数字、列表等类型都有专门的缓存策略需要处理。</li><li>创建 <code>__builtin__</code> 模块,该模块持有所有内置类型和函数。</li><li>创建 sys 模块,其中包含了 sys.path、modules 等重要的运行行期信息。</li><li>初始化 import 机制。</li><li>初始化内置 Exception。</li><li>创建 <code>__main__</code> 模块,准备运行行所需的名字空间。</li><li>通过 site.py 将 site-packages 中的第三方方扩展库添加到搜索路径列表。</li><li>执行行入入口口 py 文文件。执行行前会将 <code>__main__.__dict__</code> 作为名字空间传递进去。</li><li>程序执行行结束。</li><li>执行行清理操作,包括调用用退出函数,GC 清理现场,释放所有模块等。</li><li>终止止进程。</li></ol><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>一切皆对象，引用计数来进行拉圾回收机制。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br>a = <span class="hljs-number">456</span><br>sys.getrefcount(a)  <span class="hljs-comment"># 2</span><br>b = a<br>sys.getrefcount(a)  <span class="hljs-comment"># 3</span><br><span class="hljs-keyword">del</span> b<br>sys.getrefcount(a)  <span class="hljs-comment"># 2</span><br></code></pre></td></tr></table></figure><p>初始化之后计数是 2 的原因是，当你调用 <code>sys.getrefcount</code> 的时候，<code>a</code> 复制了一遍，所以就是 2 了。</p><h3 id="名字空间"><a href="#名字空间" class="headerlink" title="名字空间"></a>名字空间</h3><p>python 中的变量，更多的时候用名字来表示会更好理解，在 Py 里面，变量仅仅用来指向内存中的某一个实际的对象 <code>name-&gt;object</code>，所以在函数传值也仅仅是告诉函数需要用到的参数是哪个，如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">alter</span>(<span class="hljs-params">bar</span>):<br>    bar.append(<span class="hljs-number">4</span>)<br>    bar = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br><br>foo = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;foo&#x27;</span>, foo <span class="hljs-comment"># [1, 2, 3]</span><br>alter(foo)<br><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;foo&#x27;</span>, foo <span class="hljs-comment"># [1, 2, 3, 4]</span><br></code></pre></td></tr></table></figure><p>上述的代码中，<code>bar = [0, 1]</code> 实际上是改变了函数名字空间内的 <code>bar</code> 的指向而已，不对函数外的 <code>foo</code> 有任何影响。</p><p>在 Py 中，可以通过函数 <code>globals</code> 和 <code>locals</code> 查看模块的名字空间，以及函数内的名字空间，在函数外部调用的时候，两者相同。</p><p>也可以通过 <code>&lt;module&gt;.__dict__</code> 查看其它模块的名字空间。</p><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>总是引用传递。</p><p>避免循环引用。</p><h2 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h2><h3 id="int"><a href="#int" class="headerlink" title="int"></a>int</h3><p><code>int</code> 类型是特殊处理的，[-5, 257) 之前的小数字通过固定数组来存储，通过下标来获得指针。其它情况通过 <code>PyIntBlock</code> 缓存区存储整数类型，直到进程结束，这部分内存才还给操作系统。</p><p>所以对大整数一类的操作需要谨慎，多使用 <code>xrange</code> 去替代 <code>range</code>，这样一些内存就能省下来。</p><h3 id="float"><a href="#float" class="headerlink" title="float"></a>float</h3><p>精度不足，一些小数的操作需要谨慎</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">3</span> * <span class="hljs-number">0.1</span> == <span class="hljs-number">0.3</span> <span class="hljs-comment"># False</span><br></code></pre></td></tr></table></figure><p>使用 <code>Decimal</code> 去替代 <code>float</code> 就能解决问题。内存方面也采取和 <code>int</code> 的策略，但没有针对小的浮点数去处理。</p><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>动态生成的字符串可用 <code>intern</code> 进行池化，简单来说，就是让这个字符串变成一个引用，而不是一个每次都重新生成的字符串，用于节省内存。</p><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>列表对象和存储元素指针的数组是分开的两块内存，后者在堆上分配。</p><p>如果需要频繁进行元素的增删，可用数组 <code>array</code> 代替，这个直接内存数据，省了创建对象的开销。</p><h3 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h3><p>要去判断两个字典间的差异，可以使用视图。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">d1 = <span class="hljs-built_in">dict</span>(a = <span class="hljs-number">1</span>, b = <span class="hljs-number">2</span>)<br>d2 = <span class="hljs-built_in">dict</span>(b = <span class="hljs-number">2</span>, c = <span class="hljs-number">3</span>)<br><br>v1 = d1.viewitems()<br>v2 = d2.viewitems()<br><br>v1 &amp; v2 <span class="hljs-comment"># &#123;(&#x27;b&#x27;, 2)&#125;</span><br>v1 | v2 <span class="hljs-comment"># &#123;(&#x27;a&#x27;, 1), (&#x27;b&#x27;, 2), (&#x27;c&#x27;, 3)&#125;</span><br>v1 - v2 <span class="hljs-comment"># &#123;(&#x27;a&#x27;, 1)&#125;</span><br></code></pre></td></tr></table></figure><p>视图还有一个很实用的地方就是，当你更新了原来的 <code>dict</code> 之后，视图也会同时更新。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>默认参数使用可变类型时需要注意，它的值在函数创建的时候就存在了，这个很容易出错</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params">a, b=[]</span>):<br>    b.append(a)<br>    <span class="hljs-keyword">return</span> b<br><br>test(<span class="hljs-number">1</span>) <span class="hljs-comment"># b = [1]</span><br>test(<span class="hljs-number">2</span>) <span class="hljs-comment"># b = [1, 2]</span><br>test(<span class="hljs-number">1</span>, []) <span class="hljs-comment"># return [1] b = [1, 2]</span><br>test(<span class="hljs-number">3</span>) <span class="hljs-comment"># b = [1, 2, 3]</span><br></code></pre></td></tr></table></figure><p>需要用这类可变类型的参数时，可以 <code>b=None</code> 再在函数内进行判断。</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>函数参数和内部变量都存在 <code>locals</code> 的名字空间中。</p><p>名字的查找顺序为 <code>locals -&gt; enclosing function -&gt; globals -&gt; __builtins__</code></p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>当函数离开创建环境时，依然保留其上下文状态。下例，是因为 x 的添加到 <code>func_closure</code> 列表中，引用计数增加了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>():<br>    x = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br>    <span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(<span class="hljs-built_in">id</span>(x)) <span class="hljs-comment"># same</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">a</span>():<br>        x.append(<span class="hljs-number">3</span>)<br>        <span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(<span class="hljs-built_in">id</span>(x))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">b</span>():<br>        <span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(<span class="hljs-built_in">id</span>(x))<br><br>    <span class="hljs-keyword">return</span> a, b<br>a, b = test()<br>a() <span class="hljs-comment"># same</span><br>b() <span class="hljs-comment"># same</span><br></code></pre></td></tr></table></figure><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">coroutine</span>():<br>    <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;start&#x27;</span><br>    result = <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        s = <span class="hljs-keyword">yield</span> result<br>        result = s.split(<span class="hljs-string">&#x27;,&#x27;</span>)<br><br>c = coroutine()<br><br><span class="hljs-comment"># 启动协程</span><br>c.send(<span class="hljs-literal">None</span>)<br><br><span class="hljs-comment"># 向协程发送消息</span><br><span class="hljs-built_in">print</span> c.send(<span class="hljs-string">&#x27;a,b&#x27;</span>)<br><span class="hljs-built_in">print</span> c.send(<span class="hljs-string">&#x27;c,d&#x27;</span>)<br><br>c.close()<br></code></pre></td></tr></table></figure><p>上面的代码的流程如下：</p><ol><li>创建协程后对象,必须使用用 send(None) 或 next() 启动。</li><li>协程在执行行 yield result 后让出执行行绪,等待消息。</li><li>调用用方方发送 send(“a,b”) 消息,协程恢复执行行,将接收到的数据保存到 s,执行行后续流程。</li><li>再次循环到 yeild,协程返回</li><li>直到关闭或被引发异常</li></ol><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><h3 id="搜索路径"><a href="#搜索路径" class="headerlink" title="搜索路径"></a>搜索路径</h3><ol><li>当前的进程根目录</li><li>PYTHONPATH 环境变量指定的路径列表</li><li>Python 标准库的目录列表</li><li>路径文件保存的目录</li></ol><p>当进程启动之后，所有的这些路径都被组织到 <code>sys.path</code> 列表中，任何 <code>import</code> 操作都会按照 <code>sys.path</code> 来查找模块。</p><p>进程中的模块对象都是唯一的。在首次成功导入之后，模块对象被添加到 <code>sys.modules</code> ，以后的操作都总是先检查模块对象是否已经存在。</p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="字段和属性"><a href="#字段和属性" class="headerlink" title="字段和属性"></a>字段和属性</h3><p>字段（field）和属性（property）是不同的，</p><ol><li>实例字段存储在 <code>instance.__dict__</code>, 代表单个对象实体的状态。</li><li>静态字段存储在 <code>class.__dict__</code>, 为所有同类型实例共享。</li><li>必须通过类型和实例对象才能访问字段。</li><li>以双下划线开头的 <code>class</code> 和 <code>instance</code> 成员视为私有，会被重命名。(module 成员不变)</li></ol><p>属性 (Property) 是由 getter、setter、deleter 几个方方法构成的逻辑，在查找中，属性优先于实例字段。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(<span class="hljs-title class_ inherited__">object</span>):<br><span class="hljs-meta">    @property</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">name</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self.__name<br><br><span class="hljs-meta">    @name.setter</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">name</span>(<span class="hljs-params">self, value</span>):<br>        self.__name = value<br><br>u = User()<br><br><span class="hljs-built_in">print</span> u.__dict__ <span class="hljs-comment"># &#123;&#125;</span><br>u.name = <span class="hljs-string">&quot;lycheng&quot;</span><br><span class="hljs-built_in">print</span> u.__dict__ <span class="hljs-comment"># &#123;&#x27;_User__name&#x27;: &#x27;lycheng&#x27;&#125;</span><br><span class="hljs-built_in">print</span> u.name<br></code></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>特殊方法</p><ol><li><code>__new__</code>: 创建对象实例。</li><li><code>__init__</code>: 初始化对象状态。</li><li><code>__del__</code>: 对象回收前被调用用。</li></ol><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>多重继承成员搜索顺序,也就是 mro (method resolution order) 要稍微复杂一一点。归纳一一下就<br>是:从下到上 (深度优先,从派生生类到基类),从左到右 (基类声明顺序)。mro 和我们前面面提及的成<br>员查找规则是有区别的，<code>__mro__</code> 列表中并没有 instance。所以在表述时,需要注意区别。</p><p>super 依照 mro 搜索顺序搜索基类成员</p><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><h3 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">singleton</span>(<span class="hljs-params">cls</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrap</span>(<span class="hljs-params">*args, **kwargs</span>):<br>        o = <span class="hljs-built_in">getattr</span>(cls, <span class="hljs-string">&quot;__instance__&quot;</span>, <span class="hljs-literal">None</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> o:<br>            o = cls(*args, **kwargs)<br>            cls.__instance__ = o<br>        <span class="hljs-keyword">return</span> o<br>    <span class="hljs-keyword">return</span> wrap<br><br><br><span class="hljs-meta">@singleton</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, x</span>):<br>        self.x = x<br><br><span class="hljs-built_in">print</span> A<br><br>a, b = A(<span class="hljs-number">1</span>), A(<span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span> a <span class="hljs-keyword">is</span> b <span class="hljs-comment"># True</span><br></code></pre></td></tr></table></figure><p>将 func wrap 换成 class wrap</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">singleton</span>(<span class="hljs-params">cls</span>):<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">wrap</span>(<span class="hljs-title class_ inherited__">cls</span>):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, *args, **kwargs</span>):<br>            o = <span class="hljs-built_in">getattr</span>(cls, <span class="hljs-string">&quot;__instance__&quot;</span>, <span class="hljs-literal">None</span>)<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> o:<br>                o = <span class="hljs-built_in">object</span>.__new__(cls)<br>                cls.__instance__ = o<br>            <span class="hljs-keyword">return</span> o<br>    <span class="hljs-keyword">return</span> wrap<br><br><span class="hljs-meta">@singleton</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">self</span>): <span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(<span class="hljs-built_in">id</span>(self))<br><br>a, b = A(), A()<br><span class="hljs-built_in">print</span> a <span class="hljs-keyword">is</span> b<br></code></pre></td></tr></table></figure><p>创建继承自自原类型的 class wrap,然后在 <code>__new__</code> 里里面面做手手脚就行行了。上述这个代码可以通过装饰器去修改类型的一些函数，也可以用以下的代码去增加额外的成员。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">action</span>(<span class="hljs-params">cls</span>):<br>    cls.func = <span class="hljs-built_in">staticmethod</span>(<span class="hljs-keyword">lambda</span>: <span class="hljs-string">&#x27;hello world&#x27;</span>)<br>    <span class="hljs-keyword">return</span> cls<br><br><span class="hljs-meta">@action</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Func</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-built_in">print</span> Func.func()<br></code></pre></td></tr></table></figure><h2 id="元类"><a href="#元类" class="headerlink" title="元类"></a>元类</h2><p>元类的关系</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">Data = <span class="hljs-built_in">type</span>(<span class="hljs-string">&quot;Data&quot;</span>, (<span class="hljs-built_in">object</span>,), &#123;<span class="hljs-string">&quot;x&quot;</span>: <span class="hljs-number">1</span>&#125;) <span class="hljs-comment"># 实际创建类型的指令</span><br><span class="hljs-keyword">class</span> = metaclass(...)       <span class="hljs-comment"># 元类创建类型</span><br>instance = <span class="hljs-keyword">class</span>(...)        <span class="hljs-comment"># 类型创建实例</span><br><br>instance.__class__ <span class="hljs-keyword">is</span> <span class="hljs-keyword">class</span>  <span class="hljs-comment"># 实例的类型</span><br><span class="hljs-keyword">class</span>.__class__ <span class="hljs-keyword">is</span> metaclass <span class="hljs-comment"># 类型的类型</span><br></code></pre></td></tr></table></figure><p>自定义元类，需要注意的是，自定义元类都是从 <code>type</code> 继承而来，并且是重写 <code>__new__</code> 方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">InjectMeta</span>(<span class="hljs-title class_ inherited__">type</span>): <span class="hljs-comment"># 从 type 继承</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, name, bases, attrs</span>):<br>        t = <span class="hljs-built_in">type</span>.__new__(cls, name, bases, attrs)<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">print_id</span>(<span class="hljs-params">self</span>):<br>            <span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(<span class="hljs-built_in">id</span>(self))<br><br>        t.print_id = print_id  <span class="hljs-comment"># 为类型对象添加实例方方法。</span><br>        t.s = <span class="hljs-string">&quot;Hello, World!&quot;</span>  <span class="hljs-comment"># 添加静态字段。</span><br>        <span class="hljs-keyword">return</span> t<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">cls, name, bases, attrs</span>):<br>        <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;class&#x27;</span>, cls<br>        <span class="hljs-built_in">type</span>.__init__(cls, name, bases, attrs)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Data</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    __metaclass__ = InjectMeta<br><br><span class="hljs-built_in">print</span> Data.s<br>Data().print_id()<br></code></pre></td></tr></table></figure><p>以下是使用元类实现的静态类和密封类（禁止继承）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticClassMeta</span>(<span class="hljs-title class_ inherited__">type</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, name, bases, attr</span>):<br>        t = <span class="hljs-built_in">type</span>.__new__(cls, name, bases, attr)<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">ctor</span>(<span class="hljs-params">cls, *args, **kwargs</span>):<br>            <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&quot;Cannot create a instance of the static class!&quot;</span>)<br>        t.__new__ = <span class="hljs-built_in">staticmethod</span>(ctor)<br>        <span class="hljs-keyword">return</span> t<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Data</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    __metaclass__ = StaticClassMeta<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SealedClassMeta</span>(<span class="hljs-title class_ inherited__">type</span>):<br>    _types = <span class="hljs-built_in">set</span>()<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">cls, name, bases, attrs</span>):<br>        <span class="hljs-keyword">if</span> cls._types <span class="hljs-keyword">and</span> <span class="hljs-built_in">set</span>(bases):<br>            <span class="hljs-keyword">raise</span> SyntaxError(<span class="hljs-string">&quot;Cannot inherit from a sealed class!&quot;</span>)<br>        cls._types.add(cls)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Data</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    __metaclass__ = SealedClassMeta<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>(<span class="hljs-title class_ inherited__">Data</span>):<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><h2 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h2><h3 id="heapq"><a href="#heapq" class="headerlink" title="heapq"></a>heapq</h3><p>最小堆，完全平衡二叉树，所有节点都小于其子节点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> heapq <span class="hljs-keyword">import</span> heappush, heappop<br><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> sample<br><br>src = sample(xrange(<span class="hljs-number">100</span>), <span class="hljs-number">10</span>)<br><br>heap = []<br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> src:<br>    heappush(heap, x) <span class="hljs-comment"># type(heap) == &#x27;list&#x27;</span><br><br><span class="hljs-keyword">while</span> heap:<br>    <span class="hljs-built_in">print</span> heappop(heap)<br></code></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol><li><a href="https://github.com/qyuhen/book">https://github.com/qyuhen/book</a></li><li><a href="https://www.python.org/dev/peps/pep-3129/">https://www.python.org/dev/peps/pep-3129/</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于 git 的一些东西</title>
    <link href="/2015/10/07/about-git/"/>
    <url>/2015/10/07/about-git/</url>
    
    <content type="html"><![CDATA[<p>用了很久的 git 了，但更多的是用基本的东西，也没有深究过是不是合适。长假过来重新总结一下。</p><h2 id="git-flow"><a href="#git-flow" class="headerlink" title="git flow"></a>git flow</h2><p>主分支有两个，master 和 develop。</p><p>develop 是当前的主要开发分支，当足够稳定可以进行发布版本的话就可以把代码 <code>merge</code> 到 master。</p><p>其余的称为辅助分支，如下：</p><ul><li>feature，可能从 develop 派生出来，但最后一定合并到 develop<ul><li>feature 可以只留在本地</li></ul></li><li>release, 用于准备进行发布的版本，允许针对部署环境的小修改，bug 的修改<ul><li>bug 修改以及一些其它的修复在之后需要合并回 develop 和 master</li><li>合并到 master 之后记得加上 tag</li></ul></li><li>hotfix, 从 master 派生出来，进行发布时意料之外的 bug 的修复<ul><li>修复之后进行版本号的更新 </li><li>最后也需要合并代码到 develop</li></ul></li></ul><p>需要注意的是，在这里合并分支使用的是 <code>git merge --no-ff &lt;branch&gt;</code> 来进行合并。这样合并后会新增一个节点，这样子保证了版本演进的清晰。</p><h2 id="有用的东西"><a href="#有用的东西" class="headerlink" title="有用的东西"></a>有用的东西</h2><h3 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h3><p><code>rebase</code> 试用于不想保留分支信息的情况，你 <code>checkout</code> 了一个新分支出来，修改了提交了几个 <code>commit</code> 之后，如果之前的分支也有别人的提交，你进行合并的时候就造成了分支的交叉。如果你不想合并就使用 <code>git rebase &lt;origin&gt;</code> ，这样子就会把你在当前的分支的提交取消，把你的修改更新到原来的分支去。</p><p><code>rebase</code> 适合在本地只修改几个文件，新建的分支也不需要发布到远端。</p><h3 id="日志查找"><a href="#日志查找" class="headerlink" title="日志查找"></a>日志查找</h3><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs monkey"><span class="hljs-meta"># 查找最近五个小时的提交</span><br>git <span class="hljs-built_in">log</span> --since=<span class="hljs-string">&quot;5 hours&quot;</span><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta"># 查找五个小时之前的提交</span><br>git <span class="hljs-built_in">log</span> --before=<span class="hljs-string">&quot;5 hours&quot;</span><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta"># 按精确的 commit 范围提交 [beg, <span class="hljs-keyword">end</span>) 7 位 hash 码</span><br>git <span class="hljs-built_in">log</span> &lt;beg&gt;...&lt;<span class="hljs-keyword">end</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="修改提交"><a href="#修改提交" class="headerlink" title="修改提交"></a>修改提交</h3><h4 id="增补提交"><a href="#增补提交" class="headerlink" title="增补提交"></a>增补提交</h4><p>在已经提交之后，修改某个文件，然后使用下方命令即可直接复用刚才的提交</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">git commit -C HEAD -<span class="hljs-selector-tag">a</span> <span class="hljs-attr">--amend</span><br></code></pre></td></tr></table></figure><h4 id="反转提交"><a href="#反转提交" class="headerlink" title="反转提交"></a>反转提交</h4><p>如果代码没有提交，可以简单使用 <code>git reset</code>。</p><p>如果提交了的话，则可以使用 <code>git revert -n HEAD</code> 撤销提交，添加了 <code>-n</code> 参数之后，撤销的改动不会马上提交，撤销了提交，之后修改后再重新提交。</p><h3 id="压缩版本库"><a href="#压缩版本库" class="headerlink" title="压缩版本库"></a>压缩版本库</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git gc</span><br></code></pre></td></tr></table></figure><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 指定查找指定版本库的信息</span><br><span class="hljs-attribute">git</span> grep xmmap v1.<span class="hljs-number">5</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="最后的最后"><a href="#最后的最后" class="headerlink" title="最后的最后"></a>最后的最后</h2><p>目前在用的时候可能回用到的就是上面这些了，还是历史版本的修改，二分查找一类的高级功能尚未涉及。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://nvie.com/posts/a-successful-git-branching-model/">http://nvie.com/posts/a-successful-git-branching-model/</a></li><li><a href="http://gitbook.liuhui998.com/4_2.html">http://gitbook.liuhui998.com/4_2.html</a></li><li><a href="https://git-scm.com/docs">https://git-scm.com/docs</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Travis Cli</title>
    <link href="/2015/08/30/travis-cli/"/>
    <url>/2015/08/30/travis-cli/</url>
    
    <content type="html"><![CDATA[<p>发现这个东西是因为之前看 <a href="https://github.com/mitsuhiko/werkzeug">werkzeug</a> 的 README 时候发现有个图片，然后看了下是实时生成的。然后就跟着进去发现了 <a href="https://travis-ci.org/">travis CI</a>，这是用于持续集成的项目，通过配置文件去定义自己的构建，测试。以 Python 为例，可以测试不同的 Py 版本，自定义测试环境（依赖包等等）。</p><p>于是就在自己的 <a href="https://github.com/lycheng/pylib">项目</a> 上试用了下。</p><p>首先是，<a href="https://testrun.org/tox/latest/">tox</a>，这个也是新发现的东西，用于 Python 的测试。需要注意的是，tox 用在可安装的包中，所以必须编写自己的 setup.py 文件。</p><p>我的 tox 配置文件如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml">[<span class="hljs-string">tox</span>]<br><span class="hljs-string">envlist</span> <span class="hljs-string">=</span> <span class="hljs-string">py27.py34</span><br><br>[<span class="hljs-string">testenv</span>]<br><span class="hljs-string">deps=nose</span><br><br><span class="hljs-string">commands=</span><br>    <span class="hljs-string">nosetests</span><br></code></pre></td></tr></table></figure><p>我用的是 nosetest 来进行测试，测试的环境是 py2.7 和 py3.4。上面的配置文件也标明了测试的依赖和测试的命令。奇怪的是，一定要 sudo 权限运行，tox 明明是用 virtualenv 来设置测试环境的，却必须要用 root 权限。这个回头看下。</p><p>配置好之后，执行命令 sudo tox -e py 就可以进行测试。一般到这里就是常见的开发测试了，接下来配置 Travis Cli。</p><p>首先需要去它们网站设置需要测试的项目，之后需要配置 .travis.yml 文件，我的配置如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">language:</span> <span class="hljs-string">python</span><br><span class="hljs-attr">sudo:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">python:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;2.7&quot;</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;3.4&quot;</span><br><br><span class="hljs-attr">install:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">pip</span> <span class="hljs-string">install</span> <span class="hljs-string">tox</span> <span class="hljs-string">nose</span><br><br><span class="hljs-attr">script:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">tox</span> <span class="hljs-string">-e</span> <span class="hljs-string">py</span><br></code></pre></td></tr></table></figure><p>这个也是很简单的配置语法，也是需要配置依赖，设置想要测试的版本，接下来就是提交你的东西了。</p><p>Travis Cli 每次 commit 之后就会执行构建，之后会通过邮件通知用户，你也可以去网站看到构建结果。然后你可以贴个图到 README ，这样用你的代码的人一眼就可以看到你的代码的情况了。</p><p><img src="https://api.travis-ci.org/repositories/lycheng/pylib.svg?branch=master" alt="svg"></p>]]></content>
    
    
    
    <tags>
      
      <tag>ci</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jekyll + Github Pages</title>
    <link href="/2015/08/23/Jekyll-Github-Pages/"/>
    <url>/2015/08/23/Jekyll-Github-Pages/</url>
    
    <content type="html"><![CDATA[<p>现在的目录结构如下</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs stylus">├── about<span class="hljs-selector-class">.html</span><br>├── config<span class="hljs-selector-class">.rb</span><br>├── _config<span class="hljs-selector-class">.yml</span><br>├── css<br>│   └── blog<span class="hljs-selector-class">.css</span><br>├── index<span class="hljs-selector-class">.html</span><br>├── _layouts<br>│   ├── layout<span class="hljs-selector-class">.html</span><br>│   └── post<span class="hljs-selector-class">.html</span><br>├── LICENSE<br>├── _posts<br>│   ├── <span class="hljs-number">2015</span>-<span class="hljs-number">08</span>-<span class="hljs-number">23</span>-first<span class="hljs-selector-class">.md</span><br>│   └── <span class="hljs-number">2015</span>-<span class="hljs-number">08</span>-<span class="hljs-number">23</span>-Jekyll-Github-Pages<span class="hljs-selector-class">.md</span><br>├── README<span class="hljs-selector-class">.md</span><br>├── sass<br>│   ├── blog<span class="hljs-selector-class">.scss</span><br>│   └── partials<br>│       ├── _layout<span class="hljs-selector-class">.scss</span><br>│       ├── _post<span class="hljs-selector-class">.scss</span><br>│       ├── _public<span class="hljs-selector-class">.scss</span><br>│       └── _reset<span class="hljs-selector-class">.scss</span><br>└── static<br>    └── css<br>        └── blog.css<br></code></pre></td></tr></table></figure><p>其中，<code>config.rb</code> 是 compass 的配置文件，<code>sass</code> 用于存放 <code>*.scss</code> 文件。当前使用的 <code>sass</code> 的写法参考的是之前的项目，需要更多研究下这个东西。</p><p><code>_config.yml</code> 为 <code>jekyll</code> 的配置文件，<code>_layout</code> 文件夹存放的是页面结构定义的 html，<code>_post</code> 存放的是实际的日志文件。</p>]]></content>
    
    
    
    <tags>
      
      <tag>blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
